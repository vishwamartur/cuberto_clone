/*! For license information please see bundle.js.LICENSE.txt */
!(function () {
  "use strict";
  var t = {
      4370: function (t, e, n) {
        n(8783), n(1038);
        var i = n(857);
        t.exports = i.Array.from;
      },
      3662: function (t, e, n) {
        n(6992), n(1532), n(1539), n(8783);
        var i = n(857);
        t.exports = i.Map;
      },
      9116: function (t, e, n) {
        n(9601);
        var i = n(857);
        t.exports = i.Object.assign;
      },
      8188: function (t, e, n) {
        n(6992), n(1539), n(189), n(8783);
        var i = n(857);
        t.exports = i.Set;
      },
      9074: function (t, e, n) {
        n(6992), n(1539), n(4129);
        var i = n(857);
        t.exports = i.WeakMap;
      },
      9662: function (t, e, n) {
        var i = n(614),
          r = n(6330),
          s = TypeError;
        t.exports = function (t) {
          if (i(t)) return t;
          throw new s(r(t) + " is not a function");
        };
      },
      6077: function (t, e, n) {
        var i = n(614),
          r = String,
          s = TypeError;
        t.exports = function (t) {
          if ("object" == typeof t || i(t)) return t;
          throw new s("Can't set " + r(t) + " as a prototype");
        };
      },
      1223: function (t, e, n) {
        var i = n(5112),
          r = n(30),
          s = n(3070).f,
          o = i("unscopables"),
          a = Array.prototype;
        void 0 === a[o] &&
          s(a, o, {
            configurable: !0,
            value: r(null),
          }),
          (t.exports = function (t) {
            a[o][t] = !0;
          });
      },
      5787: function (t, e, n) {
        var i = n(7976),
          r = TypeError;
        t.exports = function (t, e) {
          if (i(e, t)) return t;
          throw new r("Incorrect invocation");
        };
      },
      9670: function (t, e, n) {
        var i = n(111),
          r = String,
          s = TypeError;
        t.exports = function (t) {
          if (i(t)) return t;
          throw new s(r(t) + " is not an object");
        };
      },
      7556: function (t, e, n) {
        var i = n(7293);
        t.exports = i(function () {
          if ("function" == typeof ArrayBuffer) {
            var t = new ArrayBuffer(8);
            Object.isExtensible(t) &&
              Object.defineProperty(t, "a", {
                value: 8,
              });
          }
        });
      },
      8457: function (t, e, n) {
        var i = n(9974),
          r = n(6916),
          s = n(7908),
          o = n(3411),
          a = n(7659),
          l = n(4411),
          c = n(6244),
          u = n(6135),
          h = n(4121),
          d = n(1246),
          p = Array;
        t.exports = function (t) {
          var e = s(t),
            n = l(this),
            f = arguments.length,
            m = f > 1 ? arguments[1] : void 0,
            g = void 0 !== m;
          g && (m = i(m, f > 2 ? arguments[2] : void 0));
          var v,
            _,
            y,
            x,
            b,
            S,
            E = d(e),
            T = 0;
          if (!E || (this === p && a(E)))
            for (v = c(e), _ = n ? new this(v) : p(v); v > T; T++)
              (S = g ? m(e[T], T) : e[T]), u(_, T, S);
          else
            for (
              b = (x = h(e, E)).next, _ = n ? new this() : [];
              !(y = r(b, x)).done;
              T++
            )
              (S = g ? o(x, m, [y.value, T], !0) : y.value), u(_, T, S);
          return (_.length = T), _;
        };
      },
      1318: function (t, e, n) {
        var i = n(5656),
          r = n(1400),
          s = n(6244),
          o = function (t) {
            return function (e, n, o) {
              var a,
                l = i(e),
                c = s(l),
                u = r(o, c);
              if (t && n != n) {
                for (; c > u; ) if ((a = l[u++]) != a) return !0;
              } else
                for (; c > u; u++)
                  if ((t || u in l) && l[u] === n) return t || u || 0;
              return !t && -1;
            };
          };
        t.exports = {
          includes: o(!0),
          indexOf: o(!1),
        };
      },
      2092: function (t, e, n) {
        var i = n(9974),
          r = n(1702),
          s = n(8361),
          o = n(7908),
          a = n(6244),
          l = n(5417),
          c = r([].push),
          u = function (t) {
            var e = 1 === t,
              n = 2 === t,
              r = 3 === t,
              u = 4 === t,
              h = 6 === t,
              d = 7 === t,
              p = 5 === t || h;
            return function (f, m, g, v) {
              for (
                var _,
                  y,
                  x = o(f),
                  b = s(x),
                  S = i(m, g),
                  E = a(b),
                  T = 0,
                  M = v || l,
                  w = e ? M(f, E) : n || d ? M(f, 0) : void 0;
                E > T;
                T++
              )
                if ((p || T in b) && ((y = S((_ = b[T]), T, x)), t))
                  if (e) w[T] = y;
                  else if (y)
                    switch (t) {
                      case 3:
                        return !0;
                      case 5:
                        return _;
                      case 6:
                        return T;
                      case 2:
                        c(w, _);
                    }
                  else
                    switch (t) {
                      case 4:
                        return !1;
                      case 7:
                        c(w, _);
                    }
              return h ? -1 : r || u ? u : w;
            };
          };
        t.exports = {
          forEach: u(0),
          map: u(1),
          filter: u(2),
          some: u(3),
          every: u(4),
          find: u(5),
          findIndex: u(6),
          filterReject: u(7),
        };
      },
      1589: function (t, e, n) {
        var i = n(1400),
          r = n(6244),
          s = n(6135),
          o = Array,
          a = Math.max;
        t.exports = function (t, e, n) {
          for (
            var l = r(t),
              c = i(e, l),
              u = i(void 0 === n ? l : n, l),
              h = o(a(u - c, 0)),
              d = 0;
            c < u;
            c++, d++
          )
            s(h, d, t[c]);
          return (h.length = d), h;
        };
      },
      7475: function (t, e, n) {
        var i = n(3157),
          r = n(4411),
          s = n(111),
          o = n(5112)("species"),
          a = Array;
        t.exports = function (t) {
          var e;
          return (
            i(t) &&
              ((e = t.constructor),
              ((r(e) && (e === a || i(e.prototype))) ||
                (s(e) && null === (e = e[o]))) &&
                (e = void 0)),
            void 0 === e ? a : e
          );
        };
      },
      5417: function (t, e, n) {
        var i = n(7475);
        t.exports = function (t, e) {
          return new (i(t))(0 === e ? 0 : e);
        };
      },
      3411: function (t, e, n) {
        var i = n(9670),
          r = n(9212);
        t.exports = function (t, e, n, s) {
          try {
            return s ? e(i(n)[0], n[1]) : e(n);
          } catch (e) {
            r(t, "throw", e);
          }
        };
      },
      7072: function (t, e, n) {
        var i = n(5112)("iterator"),
          r = !1;
        try {
          var s = 0,
            o = {
              next: function () {
                return {
                  done: !!s++,
                };
              },
              return: function () {
                r = !0;
              },
            };
          (o[i] = function () {
            return this;
          }),
            Array.from(o, function () {
              throw 2;
            });
        } catch (t) {}
        t.exports = function (t, e) {
          try {
            if (!e && !r) return !1;
          } catch (t) {
            return !1;
          }
          var n = !1;
          try {
            var s = {};
            (s[i] = function () {
              return {
                next: function () {
                  return {
                    done: (n = !0),
                  };
                },
              };
            }),
              t(s);
          } catch (t) {}
          return n;
        };
      },
      4326: function (t, e, n) {
        var i = n(1702),
          r = i({}.toString),
          s = i("".slice);
        t.exports = function (t) {
          return s(r(t), 8, -1);
        };
      },
      648: function (t, e, n) {
        var i = n(1694),
          r = n(614),
          s = n(4326),
          o = n(5112)("toStringTag"),
          a = Object,
          l =
            "Arguments" ===
            s(
              (function () {
                return arguments;
              })()
            );
        t.exports = i
          ? s
          : function (t) {
              var e, n, i;
              return void 0 === t
                ? "Undefined"
                : null === t
                ? "Null"
                : "string" ==
                  typeof (n = (function (t, e) {
                    try {
                      return t[e];
                    } catch (t) {}
                  })((e = a(t)), o))
                ? n
                : l
                ? s(e)
                : "Object" === (i = s(e)) && r(e.callee)
                ? "Arguments"
                : i;
            };
      },
      5631: function (t, e, n) {
        var i = n(30),
          r = n(7045),
          s = n(9190),
          o = n(9974),
          a = n(5787),
          l = n(8554),
          c = n(408),
          u = n(1656),
          h = n(6178),
          d = n(6340),
          p = n(9781),
          f = n(2423).fastKey,
          m = n(9909),
          g = m.set,
          v = m.getterFor;
        t.exports = {
          getConstructor: function (t, e, n, u) {
            var h = t(function (t, r) {
                a(t, d),
                  g(t, {
                    type: e,
                    index: i(null),
                    first: void 0,
                    last: void 0,
                    size: 0,
                  }),
                  p || (t.size = 0),
                  l(r) ||
                    c(r, t[u], {
                      that: t,
                      AS_ENTRIES: n,
                    });
              }),
              d = h.prototype,
              m = v(e),
              _ = function (t, e, n) {
                var i,
                  r,
                  s = m(t),
                  o = y(t, e);
                return (
                  o
                    ? (o.value = n)
                    : ((s.last = o =
                        {
                          index: (r = f(e, !0)),
                          key: e,
                          value: n,
                          previous: (i = s.last),
                          next: void 0,
                          removed: !1,
                        }),
                      s.first || (s.first = o),
                      i && (i.next = o),
                      p ? s.size++ : t.size++,
                      "F" !== r && (s.index[r] = o)),
                  t
                );
              },
              y = function (t, e) {
                var n,
                  i = m(t),
                  r = f(e);
                if ("F" !== r) return i.index[r];
                for (n = i.first; n; n = n.next) if (n.key === e) return n;
              };
            return (
              s(d, {
                clear: function () {
                  for (var t = m(this), e = t.index, n = t.first; n; )
                    (n.removed = !0),
                      n.previous && (n.previous = n.previous.next = void 0),
                      delete e[n.index],
                      (n = n.next);
                  (t.first = t.last = void 0),
                    p ? (t.size = 0) : (this.size = 0);
                },
                delete: function (t) {
                  var e = this,
                    n = m(e),
                    i = y(e, t);
                  if (i) {
                    var r = i.next,
                      s = i.previous;
                    delete n.index[i.index],
                      (i.removed = !0),
                      s && (s.next = r),
                      r && (r.previous = s),
                      n.first === i && (n.first = r),
                      n.last === i && (n.last = s),
                      p ? n.size-- : e.size--;
                  }
                  return !!i;
                },
                forEach: function (t) {
                  for (
                    var e,
                      n = m(this),
                      i = o(t, arguments.length > 1 ? arguments[1] : void 0);
                    (e = e ? e.next : n.first);

                  )
                    for (i(e.value, e.key, this); e && e.removed; )
                      e = e.previous;
                },
                has: function (t) {
                  return !!y(this, t);
                },
              }),
              s(
                d,
                n
                  ? {
                      get: function (t) {
                        var e = y(this, t);
                        return e && e.value;
                      },
                      set: function (t, e) {
                        return _(this, 0 === t ? 0 : t, e);
                      },
                    }
                  : {
                      add: function (t) {
                        return _(this, (t = 0 === t ? 0 : t), t);
                      },
                    }
              ),
              p &&
                r(d, "size", {
                  configurable: !0,
                  get: function () {
                    return m(this).size;
                  },
                }),
              h
            );
          },
          setStrong: function (t, e, n) {
            var i = e + " Iterator",
              r = v(e),
              s = v(i);
            u(
              t,
              e,
              function (t, e) {
                g(this, {
                  type: i,
                  target: t,
                  state: r(t),
                  kind: e,
                  last: void 0,
                });
              },
              function () {
                for (var t = s(this), e = t.kind, n = t.last; n && n.removed; )
                  n = n.previous;
                return t.target && (t.last = n = n ? n.next : t.state.first)
                  ? h(
                      "keys" === e
                        ? n.key
                        : "values" === e
                        ? n.value
                        : [n.key, n.value],
                      !1
                    )
                  : ((t.target = void 0), h(void 0, !0));
              },
              n ? "entries" : "values",
              !n,
              !0
            ),
              d(e);
          },
        };
      },
      9320: function (t, e, n) {
        var i = n(1702),
          r = n(9190),
          s = n(2423).getWeakData,
          o = n(5787),
          a = n(9670),
          l = n(8554),
          c = n(111),
          u = n(408),
          h = n(2092),
          d = n(2597),
          p = n(9909),
          f = p.set,
          m = p.getterFor,
          g = h.find,
          v = h.findIndex,
          _ = i([].splice),
          y = 0,
          x = function (t) {
            return t.frozen || (t.frozen = new b());
          },
          b = function () {
            this.entries = [];
          },
          S = function (t, e) {
            return g(t.entries, function (t) {
              return t[0] === e;
            });
          };
        (b.prototype = {
          get: function (t) {
            var e = S(this, t);
            if (e) return e[1];
          },
          has: function (t) {
            return !!S(this, t);
          },
          set: function (t, e) {
            var n = S(this, t);
            n ? (n[1] = e) : this.entries.push([t, e]);
          },
          delete: function (t) {
            var e = v(this.entries, function (e) {
              return e[0] === t;
            });
            return ~e && _(this.entries, e, 1), !!~e;
          },
        }),
          (t.exports = {
            getConstructor: function (t, e, n, i) {
              var h = t(function (t, r) {
                  o(t, p),
                    f(t, {
                      type: e,
                      id: y++,
                      frozen: void 0,
                    }),
                    l(r) ||
                      u(r, t[i], {
                        that: t,
                        AS_ENTRIES: n,
                      });
                }),
                p = h.prototype,
                g = m(e),
                v = function (t, e, n) {
                  var i = g(t),
                    r = s(a(e), !0);
                  return !0 === r ? x(i).set(e, n) : (r[i.id] = n), t;
                };
              return (
                r(p, {
                  delete: function (t) {
                    var e = g(this);
                    if (!c(t)) return !1;
                    var n = s(t);
                    return !0 === n
                      ? x(e).delete(t)
                      : n && d(n, e.id) && delete n[e.id];
                  },
                  has: function (t) {
                    var e = g(this);
                    if (!c(t)) return !1;
                    var n = s(t);
                    return !0 === n ? x(e).has(t) : n && d(n, e.id);
                  },
                }),
                r(
                  p,
                  n
                    ? {
                        get: function (t) {
                          var e = g(this);
                          if (c(t)) {
                            var n = s(t);
                            return !0 === n
                              ? x(e).get(t)
                              : n
                              ? n[e.id]
                              : void 0;
                          }
                        },
                        set: function (t, e) {
                          return v(this, t, e);
                        },
                      }
                    : {
                        add: function (t) {
                          return v(this, t, !0);
                        },
                      }
                ),
                h
              );
            },
          });
      },
      7710: function (t, e, n) {
        var i = n(2109),
          r = n(7854),
          s = n(1702),
          o = n(4705),
          a = n(8052),
          l = n(2423),
          c = n(408),
          u = n(5787),
          h = n(614),
          d = n(8554),
          p = n(111),
          f = n(7293),
          m = n(7072),
          g = n(8003),
          v = n(9587);
        t.exports = function (t, e, n) {
          var _ = -1 !== t.indexOf("Map"),
            y = -1 !== t.indexOf("Weak"),
            x = _ ? "set" : "add",
            b = r[t],
            S = b && b.prototype,
            E = b,
            T = {},
            M = function (t) {
              var e = s(S[t]);
              a(
                S,
                t,
                "add" === t
                  ? function (t) {
                      return e(this, 0 === t ? 0 : t), this;
                    }
                  : "delete" === t
                  ? function (t) {
                      return !(y && !p(t)) && e(this, 0 === t ? 0 : t);
                    }
                  : "get" === t
                  ? function (t) {
                      return y && !p(t) ? void 0 : e(this, 0 === t ? 0 : t);
                    }
                  : "has" === t
                  ? function (t) {
                      return !(y && !p(t)) && e(this, 0 === t ? 0 : t);
                    }
                  : function (t, n) {
                      return e(this, 0 === t ? 0 : t, n), this;
                    }
              );
            };
          if (
            o(
              t,
              !h(b) ||
                !(
                  y ||
                  (S.forEach &&
                    !f(function () {
                      new b().entries().next();
                    }))
                )
            )
          )
            (E = n.getConstructor(e, t, _, x)), l.enable();
          else if (o(t, !0)) {
            var w = new E(),
              D = w[x](y ? {} : -0, 1) !== w,
              A = f(function () {
                w.has(1);
              }),
              C = m(function (t) {
                new b(t);
              }),
              P =
                !y &&
                f(function () {
                  for (var t = new b(), e = 5; e--; ) t[x](e, e);
                  return !t.has(-0);
                });
            C ||
              (((E = e(function (t, e) {
                u(t, S);
                var n = v(new b(), t, E);
                return (
                  d(e) ||
                    c(e, n[x], {
                      that: n,
                      AS_ENTRIES: _,
                    }),
                  n
                );
              })).prototype = S),
              (S.constructor = E)),
              (A || P) && (M("delete"), M("has"), _ && M("get")),
              (P || D) && M(x),
              y && S.clear && delete S.clear;
          }
          return (
            (T[t] = E),
            i(
              {
                global: !0,
                constructor: !0,
                forced: E !== b,
              },
              T
            ),
            g(E, t),
            y || n.setStrong(E, t, _),
            E
          );
        };
      },
      9920: function (t, e, n) {
        var i = n(2597),
          r = n(3887),
          s = n(1236),
          o = n(3070);
        t.exports = function (t, e, n) {
          for (var a = r(e), l = o.f, c = s.f, u = 0; u < a.length; u++) {
            var h = a[u];
            i(t, h) || (n && i(n, h)) || l(t, h, c(e, h));
          }
        };
      },
      8544: function (t, e, n) {
        var i = n(7293);
        t.exports = !i(function () {
          function t() {}
          return (
            (t.prototype.constructor = null),
            Object.getPrototypeOf(new t()) !== t.prototype
          );
        });
      },
      6178: function (t) {
        t.exports = function (t, e) {
          return {
            value: t,
            done: e,
          };
        };
      },
      8880: function (t, e, n) {
        var i = n(9781),
          r = n(3070),
          s = n(9114);
        t.exports = i
          ? function (t, e, n) {
              return r.f(t, e, s(1, n));
            }
          : function (t, e, n) {
              return (t[e] = n), t;
            };
      },
      9114: function (t) {
        t.exports = function (t, e) {
          return {
            enumerable: !(1 & t),
            configurable: !(2 & t),
            writable: !(4 & t),
            value: e,
          };
        };
      },
      6135: function (t, e, n) {
        var i = n(4948),
          r = n(3070),
          s = n(9114);
        t.exports = function (t, e, n) {
          var o = i(e);
          o in t ? r.f(t, o, s(0, n)) : (t[o] = n);
        };
      },
      7045: function (t, e, n) {
        var i = n(6339),
          r = n(3070);
        t.exports = function (t, e, n) {
          return (
            n.get &&
              i(n.get, e, {
                getter: !0,
              }),
            n.set &&
              i(n.set, e, {
                setter: !0,
              }),
            r.f(t, e, n)
          );
        };
      },
      8052: function (t, e, n) {
        var i = n(614),
          r = n(3070),
          s = n(6339),
          o = n(3072);
        t.exports = function (t, e, n, a) {
          a || (a = {});
          var l = a.enumerable,
            c = void 0 !== a.name ? a.name : e;
          if ((i(n) && s(n, c, a), a.global)) l ? (t[e] = n) : o(e, n);
          else {
            try {
              a.unsafe ? t[e] && (l = !0) : delete t[e];
            } catch (t) {}
            l
              ? (t[e] = n)
              : r.f(t, e, {
                  value: n,
                  enumerable: !1,
                  configurable: !a.nonConfigurable,
                  writable: !a.nonWritable,
                });
          }
          return t;
        };
      },
      9190: function (t, e, n) {
        var i = n(8052);
        t.exports = function (t, e, n) {
          for (var r in e) i(t, r, e[r], n);
          return t;
        };
      },
      3072: function (t, e, n) {
        var i = n(7854),
          r = Object.defineProperty;
        t.exports = function (t, e) {
          try {
            r(i, t, {
              value: e,
              configurable: !0,
              writable: !0,
            });
          } catch (n) {
            i[t] = e;
          }
          return e;
        };
      },
      9781: function (t, e, n) {
        var i = n(7293);
        t.exports = !i(function () {
          return (
            7 !==
            Object.defineProperty({}, 1, {
              get: function () {
                return 7;
              },
            })[1]
          );
        });
      },
      4154: function (t) {
        var e = "object" == typeof document && document.all,
          n = void 0 === e && void 0 !== e;
        t.exports = {
          all: e,
          IS_HTMLDDA: n,
        };
      },
      317: function (t, e, n) {
        var i = n(7854),
          r = n(111),
          s = i.document,
          o = r(s) && r(s.createElement);
        t.exports = function (t) {
          return o ? s.createElement(t) : {};
        };
      },
      8113: function (t) {
        t.exports =
          ("undefined" != typeof navigator && String(navigator.userAgent)) ||
          "";
      },
      7392: function (t, e, n) {
        var i,
          r,
          s = n(7854),
          o = n(8113),
          a = s.process,
          l = s.Deno,
          c = (a && a.versions) || (l && l.version),
          u = c && c.v8;
        u && (r = (i = u.split("."))[0] > 0 && i[0] < 4 ? 1 : +(i[0] + i[1])),
          !r &&
            o &&
            (!(i = o.match(/Edge\/(\d+)/)) || i[1] >= 74) &&
            (i = o.match(/Chrome\/(\d+)/)) &&
            (r = +i[1]),
          (t.exports = r);
      },
      748: function (t) {
        t.exports = [
          "constructor",
          "hasOwnProperty",
          "isPrototypeOf",
          "propertyIsEnumerable",
          "toLocaleString",
          "toString",
          "valueOf",
        ];
      },
      2109: function (t, e, n) {
        var i = n(7854),
          r = n(1236).f,
          s = n(8880),
          o = n(8052),
          a = n(3072),
          l = n(9920),
          c = n(4705);
        t.exports = function (t, e) {
          var n,
            u,
            h,
            d,
            p,
            f = t.target,
            m = t.global,
            g = t.stat;
          if ((n = m ? i : g ? i[f] || a(f, {}) : (i[f] || {}).prototype))
            for (u in e) {
              if (
                ((d = e[u]),
                (h = t.dontCallGetSet ? (p = r(n, u)) && p.value : n[u]),
                !c(m ? u : f + (g ? "." : "#") + u, t.forced) && void 0 !== h)
              ) {
                if (typeof d == typeof h) continue;
                l(d, h);
              }
              (t.sham || (h && h.sham)) && s(d, "sham", !0), o(n, u, d, t);
            }
        };
      },
      7293: function (t) {
        t.exports = function (t) {
          try {
            return !!t();
          } catch (t) {
            return !0;
          }
        };
      },
      6677: function (t, e, n) {
        var i = n(7293);
        t.exports = !i(function () {
          return Object.isExtensible(Object.preventExtensions({}));
        });
      },
      9974: function (t, e, n) {
        var i = n(1470),
          r = n(9662),
          s = n(4374),
          o = i(i.bind);
        t.exports = function (t, e) {
          return (
            r(t),
            void 0 === e
              ? t
              : s
              ? o(t, e)
              : function () {
                  return t.apply(e, arguments);
                }
          );
        };
      },
      4374: function (t, e, n) {
        var i = n(7293);
        t.exports = !i(function () {
          var t = function () {}.bind();
          return "function" != typeof t || t.hasOwnProperty("prototype");
        });
      },
      6916: function (t, e, n) {
        var i = n(4374),
          r = Function.prototype.call;
        t.exports = i
          ? r.bind(r)
          : function () {
              return r.apply(r, arguments);
            };
      },
      6530: function (t, e, n) {
        var i = n(9781),
          r = n(2597),
          s = Function.prototype,
          o = i && Object.getOwnPropertyDescriptor,
          a = r(s, "name"),
          l = a && "something" === function () {}.name,
          c = a && (!i || (i && o(s, "name").configurable));
        t.exports = {
          EXISTS: a,
          PROPER: l,
          CONFIGURABLE: c,
        };
      },
      5668: function (t, e, n) {
        var i = n(1702),
          r = n(9662);
        t.exports = function (t, e, n) {
          try {
            return i(r(Object.getOwnPropertyDescriptor(t, e)[n]));
          } catch (t) {}
        };
      },
      1470: function (t, e, n) {
        var i = n(4326),
          r = n(1702);
        t.exports = function (t) {
          if ("Function" === i(t)) return r(t);
        };
      },
      1702: function (t, e, n) {
        var i = n(4374),
          r = Function.prototype,
          s = r.call,
          o = i && r.bind.bind(s, s);
        t.exports = i
          ? o
          : function (t) {
              return function () {
                return s.apply(t, arguments);
              };
            };
      },
      5005: function (t, e, n) {
        var i = n(7854),
          r = n(614);
        t.exports = function (t, e) {
          return arguments.length < 2
            ? ((n = i[t]), r(n) ? n : void 0)
            : i[t] && i[t][e];
          var n;
        };
      },
      1246: function (t, e, n) {
        var i = n(648),
          r = n(8173),
          s = n(8554),
          o = n(7497),
          a = n(5112)("iterator");
        t.exports = function (t) {
          if (!s(t)) return r(t, a) || r(t, "@@iterator") || o[i(t)];
        };
      },
      4121: function (t, e, n) {
        var i = n(6916),
          r = n(9662),
          s = n(9670),
          o = n(6330),
          a = n(1246),
          l = TypeError;
        t.exports = function (t, e) {
          var n = arguments.length < 2 ? a(t) : e;
          if (r(n)) return s(i(n, t));
          throw new l(o(t) + " is not iterable");
        };
      },
      8173: function (t, e, n) {
        var i = n(9662),
          r = n(8554);
        t.exports = function (t, e) {
          var n = t[e];
          return r(n) ? void 0 : i(n);
        };
      },
      7854: function (t, e, n) {
        var i = function (t) {
          return t && t.Math === Math && t;
        };
        t.exports =
          i("object" == typeof globalThis && globalThis) ||
          i("object" == typeof window && window) ||
          i("object" == typeof self && self) ||
          i("object" == typeof n.g && n.g) ||
          (function () {
            return this;
          })() ||
          this ||
          Function("return this")();
      },
      2597: function (t, e, n) {
        var i = n(1702),
          r = n(7908),
          s = i({}.hasOwnProperty);
        t.exports =
          Object.hasOwn ||
          function (t, e) {
            return s(r(t), e);
          };
      },
      3501: function (t) {
        t.exports = {};
      },
      490: function (t, e, n) {
        var i = n(5005);
        t.exports = i("document", "documentElement");
      },
      4664: function (t, e, n) {
        var i = n(9781),
          r = n(7293),
          s = n(317);
        t.exports =
          !i &&
          !r(function () {
            return (
              7 !==
              Object.defineProperty(s("div"), "a", {
                get: function () {
                  return 7;
                },
              }).a
            );
          });
      },
      8361: function (t, e, n) {
        var i = n(1702),
          r = n(7293),
          s = n(4326),
          o = Object,
          a = i("".split);
        t.exports = r(function () {
          return !o("z").propertyIsEnumerable(0);
        })
          ? function (t) {
              return "String" === s(t) ? a(t, "") : o(t);
            }
          : o;
      },
      9587: function (t, e, n) {
        var i = n(614),
          r = n(111),
          s = n(7674);
        t.exports = function (t, e, n) {
          var o, a;
          return (
            s &&
              i((o = e.constructor)) &&
              o !== n &&
              r((a = o.prototype)) &&
              a !== n.prototype &&
              s(t, a),
            t
          );
        };
      },
      2788: function (t, e, n) {
        var i = n(1702),
          r = n(614),
          s = n(5465),
          o = i(Function.toString);
        r(s.inspectSource) ||
          (s.inspectSource = function (t) {
            return o(t);
          }),
          (t.exports = s.inspectSource);
      },
      2423: function (t, e, n) {
        var i = n(2109),
          r = n(1702),
          s = n(3501),
          o = n(111),
          a = n(2597),
          l = n(3070).f,
          c = n(8006),
          u = n(1156),
          h = n(2050),
          d = n(9711),
          p = n(6677),
          f = !1,
          m = d("meta"),
          g = 0,
          v = function (t) {
            l(t, m, {
              value: {
                objectID: "O" + g++,
                weakData: {},
              },
            });
          },
          _ = (t.exports = {
            enable: function () {
              (_.enable = function () {}), (f = !0);
              var t = c.f,
                e = r([].splice),
                n = {};
              (n[m] = 1),
                t(n).length &&
                  ((c.f = function (n) {
                    for (var i = t(n), r = 0, s = i.length; r < s; r++)
                      if (i[r] === m) {
                        e(i, r, 1);
                        break;
                      }
                    return i;
                  }),
                  i(
                    {
                      target: "Object",
                      stat: !0,
                      forced: !0,
                    },
                    {
                      getOwnPropertyNames: u.f,
                    }
                  ));
            },
            fastKey: function (t, e) {
              if (!o(t))
                return "symbol" == typeof t
                  ? t
                  : ("string" == typeof t ? "S" : "P") + t;
              if (!a(t, m)) {
                if (!h(t)) return "F";
                if (!e) return "E";
                v(t);
              }
              return t[m].objectID;
            },
            getWeakData: function (t, e) {
              if (!a(t, m)) {
                if (!h(t)) return !0;
                if (!e) return !1;
                v(t);
              }
              return t[m].weakData;
            },
            onFreeze: function (t) {
              return p && f && h(t) && !a(t, m) && v(t), t;
            },
          });
        s[m] = !0;
      },
      9909: function (t, e, n) {
        var i,
          r,
          s,
          o = n(4811),
          a = n(7854),
          l = n(111),
          c = n(8880),
          u = n(2597),
          h = n(5465),
          d = n(6200),
          p = n(3501),
          f = "Object already initialized",
          m = a.TypeError,
          g = a.WeakMap;
        if (o || h.state) {
          var v = h.state || (h.state = new g());
          (v.get = v.get),
            (v.has = v.has),
            (v.set = v.set),
            (i = function (t, e) {
              if (v.has(t)) throw new m(f);
              return (e.facade = t), v.set(t, e), e;
            }),
            (r = function (t) {
              return v.get(t) || {};
            }),
            (s = function (t) {
              return v.has(t);
            });
        } else {
          var _ = d("state");
          (p[_] = !0),
            (i = function (t, e) {
              if (u(t, _)) throw new m(f);
              return (e.facade = t), c(t, _, e), e;
            }),
            (r = function (t) {
              return u(t, _) ? t[_] : {};
            }),
            (s = function (t) {
              return u(t, _);
            });
        }
        t.exports = {
          set: i,
          get: r,
          has: s,
          enforce: function (t) {
            return s(t) ? r(t) : i(t, {});
          },
          getterFor: function (t) {
            return function (e) {
              var n;
              if (!l(e) || (n = r(e)).type !== t)
                throw new m("Incompatible receiver, " + t + " required");
              return n;
            };
          },
        };
      },
      7659: function (t, e, n) {
        var i = n(5112),
          r = n(7497),
          s = i("iterator"),
          o = Array.prototype;
        t.exports = function (t) {
          return void 0 !== t && (r.Array === t || o[s] === t);
        };
      },
      3157: function (t, e, n) {
        var i = n(4326);
        t.exports =
          Array.isArray ||
          function (t) {
            return "Array" === i(t);
          };
      },
      614: function (t, e, n) {
        var i = n(4154),
          r = i.all;
        t.exports = i.IS_HTMLDDA
          ? function (t) {
              return "function" == typeof t || t === r;
            }
          : function (t) {
              return "function" == typeof t;
            };
      },
      4411: function (t, e, n) {
        var i = n(1702),
          r = n(7293),
          s = n(614),
          o = n(648),
          a = n(5005),
          l = n(2788),
          c = function () {},
          u = [],
          h = a("Reflect", "construct"),
          d = /^\s*(?:class|function)\b/,
          p = i(d.exec),
          f = !d.test(c),
          m = function (t) {
            if (!s(t)) return !1;
            try {
              return h(c, u, t), !0;
            } catch (t) {
              return !1;
            }
          },
          g = function (t) {
            if (!s(t)) return !1;
            switch (o(t)) {
              case "AsyncFunction":
              case "GeneratorFunction":
              case "AsyncGeneratorFunction":
                return !1;
            }
            try {
              return f || !!p(d, l(t));
            } catch (t) {
              return !0;
            }
          };
        (g.sham = !0),
          (t.exports =
            !h ||
            r(function () {
              var t;
              return (
                m(m.call) ||
                !m(Object) ||
                !m(function () {
                  t = !0;
                }) ||
                t
              );
            })
              ? g
              : m);
      },
      4705: function (t, e, n) {
        var i = n(7293),
          r = n(614),
          s = /#|\.prototype\./,
          o = function (t, e) {
            var n = l[a(t)];
            return n === u || (n !== c && (r(e) ? i(e) : !!e));
          },
          a = (o.normalize = function (t) {
            return String(t).replace(s, ".").toLowerCase();
          }),
          l = (o.data = {}),
          c = (o.NATIVE = "N"),
          u = (o.POLYFILL = "P");
        t.exports = o;
      },
      8554: function (t) {
        t.exports = function (t) {
          return null == t;
        };
      },
      111: function (t, e, n) {
        var i = n(614),
          r = n(4154),
          s = r.all;
        t.exports = r.IS_HTMLDDA
          ? function (t) {
              return "object" == typeof t ? null !== t : i(t) || t === s;
            }
          : function (t) {
              return "object" == typeof t ? null !== t : i(t);
            };
      },
      1913: function (t) {
        t.exports = !1;
      },
      2190: function (t, e, n) {
        var i = n(5005),
          r = n(614),
          s = n(7976),
          o = n(3307),
          a = Object;
        t.exports = o
          ? function (t) {
              return "symbol" == typeof t;
            }
          : function (t) {
              var e = i("Symbol");
              return r(e) && s(e.prototype, a(t));
            };
      },
      408: function (t, e, n) {
        var i = n(9974),
          r = n(6916),
          s = n(9670),
          o = n(6330),
          a = n(7659),
          l = n(6244),
          c = n(7976),
          u = n(4121),
          h = n(1246),
          d = n(9212),
          p = TypeError,
          f = function (t, e) {
            (this.stopped = t), (this.result = e);
          },
          m = f.prototype;
        t.exports = function (t, e, n) {
          var g,
            v,
            _,
            y,
            x,
            b,
            S,
            E = n && n.that,
            T = !(!n || !n.AS_ENTRIES),
            M = !(!n || !n.IS_RECORD),
            w = !(!n || !n.IS_ITERATOR),
            D = !(!n || !n.INTERRUPTED),
            A = i(e, E),
            C = function (t) {
              return g && d(g, "normal", t), new f(!0, t);
            },
            P = function (t) {
              return T
                ? (s(t), D ? A(t[0], t[1], C) : A(t[0], t[1]))
                : D
                ? A(t, C)
                : A(t);
            };
          if (M) g = t.iterator;
          else if (w) g = t;
          else {
            if (!(v = h(t))) throw new p(o(t) + " is not iterable");
            if (a(v)) {
              for (_ = 0, y = l(t); y > _; _++)
                if ((x = P(t[_])) && c(m, x)) return x;
              return new f(!1);
            }
            g = u(t, v);
          }
          for (b = M ? t.next : g.next; !(S = r(b, g)).done; ) {
            try {
              x = P(S.value);
            } catch (t) {
              d(g, "throw", t);
            }
            if ("object" == typeof x && x && c(m, x)) return x;
          }
          return new f(!1);
        };
      },
      9212: function (t, e, n) {
        var i = n(6916),
          r = n(9670),
          s = n(8173);
        t.exports = function (t, e, n) {
          var o, a;
          r(t);
          try {
            if (!(o = s(t, "return"))) {
              if ("throw" === e) throw n;
              return n;
            }
            o = i(o, t);
          } catch (t) {
            (a = !0), (o = t);
          }
          if ("throw" === e) throw n;
          if (a) throw o;
          return r(o), n;
        };
      },
      3061: function (t, e, n) {
        var i = n(3383).IteratorPrototype,
          r = n(30),
          s = n(9114),
          o = n(8003),
          a = n(7497),
          l = function () {
            return this;
          };
        t.exports = function (t, e, n, c) {
          var u = e + " Iterator";
          return (
            (t.prototype = r(i, {
              next: s(+!c, n),
            })),
            o(t, u, !1, !0),
            (a[u] = l),
            t
          );
        };
      },
      1656: function (t, e, n) {
        var i = n(2109),
          r = n(6916),
          s = n(1913),
          o = n(6530),
          a = n(614),
          l = n(3061),
          c = n(9518),
          u = n(7674),
          h = n(8003),
          d = n(8880),
          p = n(8052),
          f = n(5112),
          m = n(7497),
          g = n(3383),
          v = o.PROPER,
          _ = o.CONFIGURABLE,
          y = g.IteratorPrototype,
          x = g.BUGGY_SAFARI_ITERATORS,
          b = f("iterator"),
          S = "keys",
          E = "values",
          T = "entries",
          M = function () {
            return this;
          };
        t.exports = function (t, e, n, o, f, g, w) {
          l(n, e, o);
          var D,
            A,
            C,
            P = function (t) {
              if (t === f && F) return F;
              if (!x && t && t in O) return O[t];
              switch (t) {
                case S:
                case E:
                case T:
                  return function () {
                    return new n(this, t);
                  };
              }
              return function () {
                return new n(this);
              };
            },
            R = e + " Iterator",
            L = !1,
            O = t.prototype,
            I = O[b] || O["@@iterator"] || (f && O[f]),
            F = (!x && I) || P(f),
            N = ("Array" === e && O.entries) || I;
          if (
            (N &&
              (D = c(N.call(new t()))) !== Object.prototype &&
              D.next &&
              (s || c(D) === y || (u ? u(D, y) : a(D[b]) || p(D, b, M)),
              h(D, R, !0, !0),
              s && (m[R] = M)),
            v &&
              f === E &&
              I &&
              I.name !== E &&
              (!s && _
                ? d(O, "name", E)
                : ((L = !0),
                  (F = function () {
                    return r(I, this);
                  }))),
            f)
          )
            if (
              ((A = {
                values: P(E),
                keys: g ? F : P(S),
                entries: P(T),
              }),
              w)
            )
              for (C in A) (x || L || !(C in O)) && p(O, C, A[C]);
            else
              i(
                {
                  target: e,
                  proto: !0,
                  forced: x || L,
                },
                A
              );
          return (
            (s && !w) ||
              O[b] === F ||
              p(O, b, F, {
                name: f,
              }),
            (m[e] = F),
            A
          );
        };
      },
      3383: function (t, e, n) {
        var i,
          r,
          s,
          o = n(7293),
          a = n(614),
          l = n(111),
          c = n(30),
          u = n(9518),
          h = n(8052),
          d = n(5112),
          p = n(1913),
          f = d("iterator"),
          m = !1;
        [].keys &&
          ("next" in (s = [].keys())
            ? (r = u(u(s))) !== Object.prototype && (i = r)
            : (m = !0)),
          !l(i) ||
          o(function () {
            var t = {};
            return i[f].call(t) !== t;
          })
            ? (i = {})
            : p && (i = c(i)),
          a(i[f]) ||
            h(i, f, function () {
              return this;
            }),
          (t.exports = {
            IteratorPrototype: i,
            BUGGY_SAFARI_ITERATORS: m,
          });
      },
      7497: function (t) {
        t.exports = {};
      },
      6244: function (t, e, n) {
        var i = n(7466);
        t.exports = function (t) {
          return i(t.length);
        };
      },
      6339: function (t, e, n) {
        var i = n(1702),
          r = n(7293),
          s = n(614),
          o = n(2597),
          a = n(9781),
          l = n(6530).CONFIGURABLE,
          c = n(2788),
          u = n(9909),
          h = u.enforce,
          d = u.get,
          p = String,
          f = Object.defineProperty,
          m = i("".slice),
          g = i("".replace),
          v = i([].join),
          _ =
            a &&
            !r(function () {
              return (
                8 !==
                f(function () {}, "length", {
                  value: 8,
                }).length
              );
            }),
          y = String(String).split("String"),
          x = (t.exports = function (t, e, n) {
            "Symbol(" === m(p(e), 0, 7) &&
              (e = "[" + g(p(e), /^Symbol\(([^)]*)\)/, "$1") + "]"),
              n && n.getter && (e = "get " + e),
              n && n.setter && (e = "set " + e),
              (!o(t, "name") || (l && t.name !== e)) &&
                (a
                  ? f(t, "name", {
                      value: e,
                      configurable: !0,
                    })
                  : (t.name = e)),
              _ &&
                n &&
                o(n, "arity") &&
                t.length !== n.arity &&
                f(t, "length", {
                  value: n.arity,
                });
            try {
              n && o(n, "constructor") && n.constructor
                ? a &&
                  f(t, "prototype", {
                    writable: !1,
                  })
                : t.prototype && (t.prototype = void 0);
            } catch (t) {}
            var i = h(t);
            return (
              o(i, "source") ||
                (i.source = v(y, "string" == typeof e ? e : "")),
              t
            );
          });
        Function.prototype.toString = x(function () {
          return (s(this) && d(this).source) || c(this);
        }, "toString");
      },
      4758: function (t) {
        var e = Math.ceil,
          n = Math.floor;
        t.exports =
          Math.trunc ||
          function (t) {
            var i = +t;
            return (i > 0 ? n : e)(i);
          };
      },
      1574: function (t, e, n) {
        var i = n(9781),
          r = n(1702),
          s = n(6916),
          o = n(7293),
          a = n(1956),
          l = n(5181),
          c = n(5296),
          u = n(7908),
          h = n(8361),
          d = Object.assign,
          p = Object.defineProperty,
          f = r([].concat);
        t.exports =
          !d ||
          o(function () {
            if (
              i &&
              1 !==
                d(
                  {
                    b: 1,
                  },
                  d(
                    p({}, "a", {
                      enumerable: !0,
                      get: function () {
                        p(this, "b", {
                          value: 3,
                          enumerable: !1,
                        });
                      },
                    }),
                    {
                      b: 2,
                    }
                  )
                ).b
            )
              return !0;
            var t = {},
              e = {},
              n = Symbol("assign detection"),
              r = "abcdefghijklmnopqrst";
            return (
              (t[n] = 7),
              r.split("").forEach(function (t) {
                e[t] = t;
              }),
              7 !== d({}, t)[n] || a(d({}, e)).join("") !== r
            );
          })
            ? function (t, e) {
                for (
                  var n = u(t), r = arguments.length, o = 1, d = l.f, p = c.f;
                  r > o;

                )
                  for (
                    var m,
                      g = h(arguments[o++]),
                      v = d ? f(a(g), d(g)) : a(g),
                      _ = v.length,
                      y = 0;
                    _ > y;

                  )
                    (m = v[y++]), (i && !s(p, g, m)) || (n[m] = g[m]);
                return n;
              }
            : d;
      },
      30: function (t, e, n) {
        var i,
          r = n(9670),
          s = n(6048),
          o = n(748),
          a = n(3501),
          l = n(490),
          c = n(317),
          u = n(6200),
          h = "prototype",
          d = "script",
          p = u("IE_PROTO"),
          f = function () {},
          m = function (t) {
            return "<" + d + ">" + t + "</" + d + ">";
          },
          g = function (t) {
            t.write(m("")), t.close();
            var e = t.parentWindow.Object;
            return (t = null), e;
          },
          v = function () {
            try {
              i = new ActiveXObject("htmlfile");
            } catch (t) {}
            var t, e, n;
            v =
              "undefined" != typeof document
                ? document.domain && i
                  ? g(i)
                  : ((e = c("iframe")),
                    (n = "java" + d + ":"),
                    (e.style.display = "none"),
                    l.appendChild(e),
                    (e.src = String(n)),
                    (t = e.contentWindow.document).open(),
                    t.write(m("document.F=Object")),
                    t.close(),
                    t.F)
                : g(i);
            for (var r = o.length; r--; ) delete v[h][o[r]];
            return v();
          };
        (a[p] = !0),
          (t.exports =
            Object.create ||
            function (t, e) {
              var n;
              return (
                null !== t
                  ? ((f[h] = r(t)), (n = new f()), (f[h] = null), (n[p] = t))
                  : (n = v()),
                void 0 === e ? n : s.f(n, e)
              );
            });
      },
      6048: function (t, e, n) {
        var i = n(9781),
          r = n(3353),
          s = n(3070),
          o = n(9670),
          a = n(5656),
          l = n(1956);
        e.f =
          i && !r
            ? Object.defineProperties
            : function (t, e) {
                o(t);
                for (var n, i = a(e), r = l(e), c = r.length, u = 0; c > u; )
                  s.f(t, (n = r[u++]), i[n]);
                return t;
              };
      },
      3070: function (t, e, n) {
        var i = n(9781),
          r = n(4664),
          s = n(3353),
          o = n(9670),
          a = n(4948),
          l = TypeError,
          c = Object.defineProperty,
          u = Object.getOwnPropertyDescriptor,
          h = "enumerable",
          d = "configurable",
          p = "writable";
        e.f = i
          ? s
            ? function (t, e, n) {
                if (
                  (o(t),
                  (e = a(e)),
                  o(n),
                  "function" == typeof t &&
                    "prototype" === e &&
                    "value" in n &&
                    p in n &&
                    !n[p])
                ) {
                  var i = u(t, e);
                  i &&
                    i[p] &&
                    ((t[e] = n.value),
                    (n = {
                      configurable: d in n ? n[d] : i[d],
                      enumerable: h in n ? n[h] : i[h],
                      writable: !1,
                    }));
                }
                return c(t, e, n);
              }
            : c
          : function (t, e, n) {
              if ((o(t), (e = a(e)), o(n), r))
                try {
                  return c(t, e, n);
                } catch (t) {}
              if ("get" in n || "set" in n)
                throw new l("Accessors not supported");
              return "value" in n && (t[e] = n.value), t;
            };
      },
      1236: function (t, e, n) {
        var i = n(9781),
          r = n(6916),
          s = n(5296),
          o = n(9114),
          a = n(5656),
          l = n(4948),
          c = n(2597),
          u = n(4664),
          h = Object.getOwnPropertyDescriptor;
        e.f = i
          ? h
          : function (t, e) {
              if (((t = a(t)), (e = l(e)), u))
                try {
                  return h(t, e);
                } catch (t) {}
              if (c(t, e)) return o(!r(s.f, t, e), t[e]);
            };
      },
      1156: function (t, e, n) {
        var i = n(4326),
          r = n(5656),
          s = n(8006).f,
          o = n(1589),
          a =
            "object" == typeof window && window && Object.getOwnPropertyNames
              ? Object.getOwnPropertyNames(window)
              : [];
        t.exports.f = function (t) {
          return a && "Window" === i(t)
            ? (function (t) {
                try {
                  return s(t);
                } catch (t) {
                  return o(a);
                }
              })(t)
            : s(r(t));
        };
      },
      8006: function (t, e, n) {
        var i = n(6324),
          r = n(748).concat("length", "prototype");
        e.f =
          Object.getOwnPropertyNames ||
          function (t) {
            return i(t, r);
          };
      },
      5181: function (t, e) {
        e.f = Object.getOwnPropertySymbols;
      },
      9518: function (t, e, n) {
        var i = n(2597),
          r = n(614),
          s = n(7908),
          o = n(6200),
          a = n(8544),
          l = o("IE_PROTO"),
          c = Object,
          u = c.prototype;
        t.exports = a
          ? c.getPrototypeOf
          : function (t) {
              var e = s(t);
              if (i(e, l)) return e[l];
              var n = e.constructor;
              return r(n) && e instanceof n
                ? n.prototype
                : e instanceof c
                ? u
                : null;
            };
      },
      2050: function (t, e, n) {
        var i = n(7293),
          r = n(111),
          s = n(4326),
          o = n(7556),
          a = Object.isExtensible,
          l = i(function () {
            a(1);
          });
        t.exports =
          l || o
            ? function (t) {
                return !!r(t) && (!o || "ArrayBuffer" !== s(t)) && (!a || a(t));
              }
            : a;
      },
      7976: function (t, e, n) {
        var i = n(1702);
        t.exports = i({}.isPrototypeOf);
      },
      6324: function (t, e, n) {
        var i = n(1702),
          r = n(2597),
          s = n(5656),
          o = n(1318).indexOf,
          a = n(3501),
          l = i([].push);
        t.exports = function (t, e) {
          var n,
            i = s(t),
            c = 0,
            u = [];
          for (n in i) !r(a, n) && r(i, n) && l(u, n);
          for (; e.length > c; ) r(i, (n = e[c++])) && (~o(u, n) || l(u, n));
          return u;
        };
      },
      1956: function (t, e, n) {
        var i = n(6324),
          r = n(748);
        t.exports =
          Object.keys ||
          function (t) {
            return i(t, r);
          };
      },
      5296: function (t, e) {
        var n = {}.propertyIsEnumerable,
          i = Object.getOwnPropertyDescriptor,
          r =
            i &&
            !n.call(
              {
                1: 2,
              },
              1
            );
        e.f = r
          ? function (t) {
              var e = i(this, t);
              return !!e && e.enumerable;
            }
          : n;
      },
      7674: function (t, e, n) {
        var i = n(5668),
          r = n(9670),
          s = n(6077);
        t.exports =
          Object.setPrototypeOf ||
          ("__proto__" in {}
            ? (function () {
                var t,
                  e = !1,
                  n = {};
                try {
                  (t = i(Object.prototype, "__proto__", "set"))(n, []),
                    (e = n instanceof Array);
                } catch (t) {}
                return function (n, i) {
                  return r(n), s(i), e ? t(n, i) : (n.__proto__ = i), n;
                };
              })()
            : void 0);
      },
      288: function (t, e, n) {
        var i = n(1694),
          r = n(648);
        t.exports = i
          ? {}.toString
          : function () {
              return "[object " + r(this) + "]";
            };
      },
      2140: function (t, e, n) {
        var i = n(6916),
          r = n(614),
          s = n(111),
          o = TypeError;
        t.exports = function (t, e) {
          var n, a;
          if ("string" === e && r((n = t.toString)) && !s((a = i(n, t))))
            return a;
          if (r((n = t.valueOf)) && !s((a = i(n, t)))) return a;
          if ("string" !== e && r((n = t.toString)) && !s((a = i(n, t))))
            return a;
          throw new o("Can't convert object to primitive value");
        };
      },
      3887: function (t, e, n) {
        var i = n(5005),
          r = n(1702),
          s = n(8006),
          o = n(5181),
          a = n(9670),
          l = r([].concat);
        t.exports =
          i("Reflect", "ownKeys") ||
          function (t) {
            var e = s.f(a(t)),
              n = o.f;
            return n ? l(e, n(t)) : e;
          };
      },
      857: function (t, e, n) {
        var i = n(7854);
        t.exports = i;
      },
      4488: function (t, e, n) {
        var i = n(8554),
          r = TypeError;
        t.exports = function (t) {
          if (i(t)) throw new r("Can't call method on " + t);
          return t;
        };
      },
      6340: function (t, e, n) {
        var i = n(5005),
          r = n(7045),
          s = n(5112),
          o = n(9781),
          a = s("species");
        t.exports = function (t) {
          var e = i(t);
          o &&
            e &&
            !e[a] &&
            r(e, a, {
              configurable: !0,
              get: function () {
                return this;
              },
            });
        };
      },
      8003: function (t, e, n) {
        var i = n(3070).f,
          r = n(2597),
          s = n(5112)("toStringTag");
        t.exports = function (t, e, n) {
          t && !n && (t = t.prototype),
            t &&
              !r(t, s) &&
              i(t, s, {
                configurable: !0,
                value: e,
              });
        };
      },
      6200: function (t, e, n) {
        var i = n(2309),
          r = n(9711),
          s = i("keys");
        t.exports = function (t) {
          return s[t] || (s[t] = r(t));
        };
      },
      5465: function (t, e, n) {
        var i = n(7854),
          r = n(3072),
          s = "__core-js_shared__",
          o = i[s] || r(s, {});
        t.exports = o;
      },
      2309: function (t, e, n) {
        var i = n(1913),
          r = n(5465);
        (t.exports = function (t, e) {
          return r[t] || (r[t] = void 0 !== e ? e : {});
        })("versions", []).push({
          version: "3.33.0",
          mode: i ? "pure" : "global",
          copyright: "© 2014-2023 Denis Pushkarev (zloirock.ru)",
          license: "https://github.com/zloirock/core-js/blob/v3.33.0/LICENSE",
          source: "https://github.com/zloirock/core-js",
        });
      },
      8710: function (t, e, n) {
        var i = n(1702),
          r = n(9303),
          s = n(1340),
          o = n(4488),
          a = i("".charAt),
          l = i("".charCodeAt),
          c = i("".slice),
          u = function (t) {
            return function (e, n) {
              var i,
                u,
                h = s(o(e)),
                d = r(n),
                p = h.length;
              return d < 0 || d >= p
                ? t
                  ? ""
                  : void 0
                : (i = l(h, d)) < 55296 ||
                  i > 56319 ||
                  d + 1 === p ||
                  (u = l(h, d + 1)) < 56320 ||
                  u > 57343
                ? t
                  ? a(h, d)
                  : i
                : t
                ? c(h, d, d + 2)
                : u - 56320 + ((i - 55296) << 10) + 65536;
            };
          };
        t.exports = {
          codeAt: u(!1),
          charAt: u(!0),
        };
      },
      6293: function (t, e, n) {
        var i = n(7392),
          r = n(7293),
          s = n(7854).String;
        t.exports =
          !!Object.getOwnPropertySymbols &&
          !r(function () {
            var t = Symbol("symbol detection");
            return (
              !s(t) ||
              !(Object(t) instanceof Symbol) ||
              (!Symbol.sham && i && i < 41)
            );
          });
      },
      1400: function (t, e, n) {
        var i = n(9303),
          r = Math.max,
          s = Math.min;
        t.exports = function (t, e) {
          var n = i(t);
          return n < 0 ? r(n + e, 0) : s(n, e);
        };
      },
      5656: function (t, e, n) {
        var i = n(8361),
          r = n(4488);
        t.exports = function (t) {
          return i(r(t));
        };
      },
      9303: function (t, e, n) {
        var i = n(4758);
        t.exports = function (t) {
          var e = +t;
          return e != e || 0 === e ? 0 : i(e);
        };
      },
      7466: function (t, e, n) {
        var i = n(9303),
          r = Math.min;
        t.exports = function (t) {
          return t > 0 ? r(i(t), 9007199254740991) : 0;
        };
      },
      7908: function (t, e, n) {
        var i = n(4488),
          r = Object;
        t.exports = function (t) {
          return r(i(t));
        };
      },
      7593: function (t, e, n) {
        var i = n(6916),
          r = n(111),
          s = n(2190),
          o = n(8173),
          a = n(2140),
          l = n(5112),
          c = TypeError,
          u = l("toPrimitive");
        t.exports = function (t, e) {
          if (!r(t) || s(t)) return t;
          var n,
            l = o(t, u);
          if (l) {
            if (
              (void 0 === e && (e = "default"), (n = i(l, t, e)), !r(n) || s(n))
            )
              return n;
            throw new c("Can't convert object to primitive value");
          }
          return void 0 === e && (e = "number"), a(t, e);
        };
      },
      4948: function (t, e, n) {
        var i = n(7593),
          r = n(2190);
        t.exports = function (t) {
          var e = i(t, "string");
          return r(e) ? e : e + "";
        };
      },
      1694: function (t, e, n) {
        var i = {};
        (i[n(5112)("toStringTag")] = "z"),
          (t.exports = "[object z]" === String(i));
      },
      1340: function (t, e, n) {
        var i = n(648),
          r = String;
        t.exports = function (t) {
          if ("Symbol" === i(t))
            throw new TypeError("Cannot convert a Symbol value to a string");
          return r(t);
        };
      },
      6330: function (t) {
        var e = String;
        t.exports = function (t) {
          try {
            return e(t);
          } catch (t) {
            return "Object";
          }
        };
      },
      9711: function (t, e, n) {
        var i = n(1702),
          r = 0,
          s = Math.random(),
          o = i((1).toString);
        t.exports = function (t) {
          return "Symbol(" + (void 0 === t ? "" : t) + ")_" + o(++r + s, 36);
        };
      },
      3307: function (t, e, n) {
        var i = n(6293);
        t.exports = i && !Symbol.sham && "symbol" == typeof Symbol.iterator;
      },
      3353: function (t, e, n) {
        var i = n(9781),
          r = n(7293);
        t.exports =
          i &&
          r(function () {
            return (
              42 !==
              Object.defineProperty(function () {}, "prototype", {
                value: 42,
                writable: !1,
              }).prototype
            );
          });
      },
      4811: function (t, e, n) {
        var i = n(7854),
          r = n(614),
          s = i.WeakMap;
        t.exports = r(s) && /native code/.test(String(s));
      },
      5112: function (t, e, n) {
        var i = n(7854),
          r = n(2309),
          s = n(2597),
          o = n(9711),
          a = n(6293),
          l = n(3307),
          c = i.Symbol,
          u = r("wks"),
          h = l ? c.for || c : (c && c.withoutSetter) || o;
        t.exports = function (t) {
          return (
            s(u, t) || (u[t] = a && s(c, t) ? c[t] : h("Symbol." + t)), u[t]
          );
        };
      },
      1038: function (t, e, n) {
        var i = n(2109),
          r = n(8457);
        i(
          {
            target: "Array",
            stat: !0,
            forced: !n(7072)(function (t) {
              Array.from(t);
            }),
          },
          {
            from: r,
          }
        );
      },
      6992: function (t, e, n) {
        var i = n(5656),
          r = n(1223),
          s = n(7497),
          o = n(9909),
          a = n(3070).f,
          l = n(1656),
          c = n(6178),
          u = n(1913),
          h = n(9781),
          d = "Array Iterator",
          p = o.set,
          f = o.getterFor(d);
        t.exports = l(
          Array,
          "Array",
          function (t, e) {
            p(this, {
              type: d,
              target: i(t),
              index: 0,
              kind: e,
            });
          },
          function () {
            var t = f(this),
              e = t.target,
              n = t.kind,
              i = t.index++;
            if (!e || i >= e.length) return (t.target = void 0), c(void 0, !0);
            switch (n) {
              case "keys":
                return c(i, !1);
              case "values":
                return c(e[i], !1);
            }
            return c([i, e[i]], !1);
          },
          "values"
        );
        var m = (s.Arguments = s.Array);
        if (
          (r("keys"), r("values"), r("entries"), !u && h && "values" !== m.name)
        )
          try {
            a(m, "name", {
              value: "values",
            });
          } catch (t) {}
      },
      9098: function (t, e, n) {
        n(7710)(
          "Map",
          function (t) {
            return function () {
              return t(this, arguments.length ? arguments[0] : void 0);
            };
          },
          n(5631)
        );
      },
      1532: function (t, e, n) {
        n(9098);
      },
      9601: function (t, e, n) {
        var i = n(2109),
          r = n(1574);
        i(
          {
            target: "Object",
            stat: !0,
            arity: 2,
            forced: Object.assign !== r,
          },
          {
            assign: r,
          }
        );
      },
      1539: function (t, e, n) {
        var i = n(1694),
          r = n(8052),
          s = n(288);
        i ||
          r(Object.prototype, "toString", s, {
            unsafe: !0,
          });
      },
      7227: function (t, e, n) {
        n(7710)(
          "Set",
          function (t) {
            return function () {
              return t(this, arguments.length ? arguments[0] : void 0);
            };
          },
          n(5631)
        );
      },
      189: function (t, e, n) {
        n(7227);
      },
      8783: function (t, e, n) {
        var i = n(8710).charAt,
          r = n(1340),
          s = n(9909),
          o = n(1656),
          a = n(6178),
          l = "String Iterator",
          c = s.set,
          u = s.getterFor(l);
        o(
          String,
          "String",
          function (t) {
            c(this, {
              type: l,
              string: r(t),
              index: 0,
            });
          },
          function () {
            var t,
              e = u(this),
              n = e.string,
              r = e.index;
            return r >= n.length
              ? a(void 0, !0)
              : ((t = i(n, r)), (e.index += t.length), a(t, !1));
          }
        );
      },
      1202: function (t, e, n) {
        var i,
          r = n(6677),
          s = n(7854),
          o = n(1702),
          a = n(9190),
          l = n(2423),
          c = n(7710),
          u = n(9320),
          h = n(111),
          d = n(9909).enforce,
          p = n(7293),
          f = n(4811),
          m = Object,
          g = Array.isArray,
          v = m.isExtensible,
          _ = m.isFrozen,
          y = m.isSealed,
          x = m.freeze,
          b = m.seal,
          S = {},
          E = {},
          T = !s.ActiveXObject && "ActiveXObject" in s,
          M = function (t) {
            return function () {
              return t(this, arguments.length ? arguments[0] : void 0);
            };
          },
          w = c("WeakMap", M, u),
          D = w.prototype,
          A = o(D.set);
        if (f)
          if (T) {
            (i = u.getConstructor(M, "WeakMap", !0)), l.enable();
            var C = o(D.delete),
              P = o(D.has),
              R = o(D.get);
            a(D, {
              delete: function (t) {
                if (h(t) && !v(t)) {
                  var e = d(this);
                  return (
                    e.frozen || (e.frozen = new i()),
                    C(this, t) || e.frozen.delete(t)
                  );
                }
                return C(this, t);
              },
              has: function (t) {
                if (h(t) && !v(t)) {
                  var e = d(this);
                  return (
                    e.frozen || (e.frozen = new i()),
                    P(this, t) || e.frozen.has(t)
                  );
                }
                return P(this, t);
              },
              get: function (t) {
                if (h(t) && !v(t)) {
                  var e = d(this);
                  return (
                    e.frozen || (e.frozen = new i()),
                    P(this, t) ? R(this, t) : e.frozen.get(t)
                  );
                }
                return R(this, t);
              },
              set: function (t, e) {
                if (h(t) && !v(t)) {
                  var n = d(this);
                  n.frozen || (n.frozen = new i()),
                    P(this, t) ? A(this, t, e) : n.frozen.set(t, e);
                } else A(this, t, e);
                return this;
              },
            });
          } else
            r &&
              p(function () {
                var t = x([]);
                return A(new w(), t, 1), !_(t);
              }) &&
              a(D, {
                set: function (t, e) {
                  var n;
                  return (
                    g(t) && (_(t) ? (n = S) : y(t) && (n = E)),
                    A(this, t, e),
                    n === S && x(t),
                    n === E && b(t),
                    this
                  );
                },
              });
      },
      4129: function (t, e, n) {
        n(1202);
      },
    },
    e = {};
  function n(i) {
    var r = e[i];
    if (void 0 !== r) return r.exports;
    var s = (e[i] = {
      exports: {},
    });
    return t[i].call(s.exports, s, s.exports, n), s.exports;
  }
  (n.d = function (t, e) {
    for (var i in e)
      n.o(e, i) &&
        !n.o(t, i) &&
        Object.defineProperty(t, i, {
          enumerable: !0,
          get: e[i],
        });
  }),
    (n.g = (function () {
      if ("object" == typeof globalThis) return globalThis;
      try {
        return this || new Function("return this")();
      } catch (t) {
        if ("object" == typeof window) return window;
      }
    })()),
    (n.o = function (t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }),
    (n.r = function (t) {
      "undefined" != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(t, Symbol.toStringTag, {
          value: "Module",
        }),
        Object.defineProperty(t, "__esModule", {
          value: !0,
        });
    }),
    (function () {
      var t = {};
      function e(t, e) {
        (t.prototype = Object.create(e.prototype)),
          (t.prototype.constructor = t),
          i(t, e);
      }
      function i(t, e) {
        return (
          (i = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          i(t, e)
        );
      }
      n.r(t),
        n.d(t, {
          keyboardHandler: function () {
            return ol;
          },
          mouseHandler: function () {
            return al;
          },
          resizeHandler: function () {
            return ll;
          },
          selectHandler: function () {
            return cl;
          },
          touchHandler: function () {
            return ul;
          },
          wheelHandler: function () {
            return hl;
          },
        });
      var r = (function () {
          function t() {
            this._events = {};
          }
          var e = t.prototype;
          return (
            (e.on = function (t, e, n) {
              void 0 === n && (n = {}),
                this._events[t] || (this._events[t] = []),
                this._events[t].push({
                  callback: e,
                  options: n,
                });
            }),
            (e.off = function (t, e) {
              this._events[t] = e
                ? this._events[t].filter(function (t) {
                    return t.callback !== e;
                  })
                : [];
            }),
            (e.trigger = function (t) {
              var e = arguments,
                n = this;
              this._events[t] &&
                this._events[t].forEach(function (i) {
                  var r;
                  (r = i.callback).call.apply(
                    r,
                    [n].concat([].slice.call(e, 1))
                  ),
                    i.options.once && n.off(t, i.callback);
                });
            }),
            t
          );
        })(),
        s = (function (t) {
          function n(e) {
            var n;
            return (
              ((n = t.call(this) || this).options = Object.assign(
                {},
                {
                  init: !0,
                  define: null,
                  waitFullLoad: !0,
                },
                e
              )),
              (n.store = new Map()),
              (n.registry = new Map()),
              n.options.define &&
                (n.defineAll(n.options.define), n.options.init && n.init()),
              n
            );
          }
          e(n, t);
          var i = n.prototype;
          return (
            (i.init = function () {
              try {
                var t = this,
                  e = (function () {
                    if (
                      "interactive" === document.readyState ||
                      "complete" === document.readyState
                    )
                      return Promise.resolve(t.start()).then(function () {});
                    document.addEventListener(
                      "DOMContentLoaded",
                      function () {
                        return t.start();
                      },
                      {
                        once: !0,
                      }
                    );
                  })();
                return Promise.resolve(
                  e && e.then ? e.then(function () {}) : void 0
                );
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (i.start = function () {
              try {
                var t = function () {
                    return Promise.resolve(e.executeAll("init")).then(
                      function () {
                        return Promise.resolve(e.executeAll("enter")).then(
                          function () {
                            return Promise.resolve(
                              e.executeAll("complete")
                            ).then(function () {});
                          }
                        );
                      }
                    );
                  },
                  e = this;
                e.registry.forEach(function (t, n) {
                  t.assign
                    ? e.queryAll(t.assign).forEach(function (t) {
                        e.attach(n, t, null, !1);
                      })
                    : e.attach(n, null, null, !1);
                });
                var n = (function () {
                  if (e.options.waitFullLoad)
                    return Promise.resolve(e.waitFullLoad()).then(
                      function () {}
                    );
                })();
                return Promise.resolve(n && n.then ? n.then(t) : t());
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (i.refresh = function (t, e, n) {
              void 0 === t && (t = !0),
                void 0 === e && (e = !0),
                void 0 === n && (n = !0);
              try {
                var i = this,
                  r = [];
                return (
                  i.registry.forEach(function (s, o) {
                    var a = i.store.get(o);
                    a &&
                      a.forEach(function (a, l) {
                        s.assign
                          ? n &&
                            a.el &&
                            !a.el.isConnected &&
                            r.push(i.detach(o, l, e))
                          : t && r.push(i.executeInstance(a, "refresh"));
                      }),
                      s.assign &&
                        i.queryAll(s.assign).forEach(function (e) {
                          var n =
                            a &&
                            a.filter(function (t) {
                              return t.el && e.isSameNode(t.el);
                            })[0];
                          n
                            ? t && r.push(i.executeInstance(n, "refresh"))
                            : r.push(i.attach(o, e));
                        });
                  }),
                  t && i.trigger("refresh"),
                  Promise.all(r)
                );
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (i.executeAll = function (t) {
              try {
                var e = this,
                  n = [];
                return (
                  e.trigger(t),
                  e.store.forEach(function (i) {
                    i.forEach(function (i) {
                      return n.push(e.executeInstance(i, t));
                    });
                  }),
                  Promise.all(n)
                );
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (i.executeInstance = function (t, e) {
              void 0 === e && (e = "init");
              try {
                var n = "on" + e.charAt(0).toUpperCase() + e.slice(1);
                return t[n]
                  ? Promise.resolve((t._executors[e] = t[n]()))
                  : Promise.resolve();
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (i.wait = function (t, e, n) {
              void 0 === e && (e = "init"), void 0 === n && (n = 0);
              try {
                return Promise.resolve(this.waitInstance(this.get(t, n), e));
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (i.waitAll = function (t, e) {
              void 0 === e && (e = "init");
              try {
                var n = this,
                  i = [];
                return (
                  n.store.forEach(function (t) {
                    t.forEach(function (t) {
                      return i.push(n.waitInstance(t, e));
                    });
                  }),
                  Promise.all(i)
                );
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (i.waitInstance = function (t, e) {
              void 0 === e && (e = "init");
              try {
                return Promise.resolve(t._executors[e]);
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (i.waitFullLoad = function () {
              try {
                return Promise.resolve(
                  new Promise(function (t) {
                    "complete" === document.readyState
                      ? t()
                      : window.addEventListener("load", function () {
                          return t();
                        });
                  })
                );
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (i.attach = function (t, e, n, i) {
              void 0 === i && (i = !0);
              try {
                var r = this,
                  s = n || r.registry.get(t).options,
                  o = new (0, r.registry.get(t).component)(r, e, s);
                r.store.has(t) || r.store.set(t, []),
                  r.store.get(t).push(o),
                  (o._namespace = t);
                var a = (function () {
                  if (i)
                    return Promise.resolve(r.executeInstance(o, "init")).then(
                      function () {}
                    );
                })();
                return Promise.resolve(
                  a && a.then
                    ? a.then(function () {
                        return o;
                      })
                    : o
                );
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (i.detach = function (t, e, n) {
              void 0 === e && (e = 0), void 0 === n && (n = !0);
              try {
                var i = this,
                  r = i.store.get(t).splice(e, 1)[0],
                  s = (function () {
                    if (n)
                      return Promise.resolve(
                        i.executeInstance(r, "destroy")
                      ).then(function () {});
                  })();
                return Promise.resolve(
                  s && s.then
                    ? s.then(function () {
                        return r;
                      })
                    : r
                );
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (i.define = function (t, e, n, i) {
              this.registry.set(t, {
                assign: n,
                component: e,
                options: i,
              });
            }),
            (i.defineAll = function (t) {
              var e = this;
              t.forEach(function (t) {
                e.define(t.namespace, t.component, t.assign, t.options);
              });
            }),
            (i.get = function (t, e) {
              void 0 === e && (e = 0);
              var n = this.store.get(t);
              return n ? n[e] : null;
            }),
            (i.getAll = function (t) {
              return this.store.get(t);
            }),
            (i.find = function (t, e, n) {
              void 0 === n && (n = 0);
              var i = this.findAll(t, e);
              return i ? i[n] : null;
            }),
            (i.findAll = function (t, e) {
              var n = e ? [this.store.get(e) || []] : this.store,
                i = [];
              return (
                n.forEach(function (e) {
                  i.push.apply(
                    i,
                    e.filter(function (e) {
                      return (
                        e.el &&
                        ("string" == typeof t ? e.el.matches(t) : e.el === t)
                      );
                    })
                  );
                }),
                i
              );
            }),
            (i.query = function (t) {
              return "string" == typeof t
                ? document.querySelector(t)
                : "object" == typeof t
                ? t
                : null;
            }),
            (i.queryAll = function (t) {
              return "string" == typeof t
                ? Array.from(document.querySelectorAll(t))
                : "object" == typeof t
                ? t
                : [];
            }),
            n
          );
        })(r),
        o = (function (t) {
          function n(e, n, i) {
            var r;
            return (
              ((r = t.call(this) || this).app = e),
              (r.el = n),
              (r.options = i),
              (r._namespace = null),
              (r._executors = {}),
              r
            );
          }
          e(n, t);
          var i = n.prototype;
          return (
            (i.onInit = function () {
              return Promise.resolve();
            }),
            (i.onRefresh = function () {
              return Promise.resolve();
            }),
            (i.onEnter = function () {
              return Promise.resolve();
            }),
            (i.onComplete = function () {
              return Promise.resolve();
            }),
            (i.onLeave = function () {
              return Promise.resolve();
            }),
            (i.onDestroy = function () {
              return Promise.resolve();
            }),
            (i.onLoading = function () {
              return Promise.resolve();
            }),
            (i.onLoaded = function () {
              return Promise.resolve();
            }),
            n
          );
        })(r),
        a = (function (t) {
          function n() {
            var e;
            return (
              ((e = t.apply(this, arguments) || this).options = Object.assign(
                {},
                {
                  bindLinks: !0,
                  bindHistory: !0,
                  checkLinkUrlRegExp:
                    /(\?.*)?\/(?:|[^.]+(?:\.(?:htm|html|php)|))(?:\?.*|)$/,
                  cleanUrlRegExp: /#.*/,
                  checkResponseStatus: !0,
                  history: "push",
                  preventSame: !1,
                  preventRunning: !1,
                  parserType: "text/html",
                  scrollRestoration: "manual",
                  updateSelectors: ["title", "meta", "#view-main"],
                  extendNodes: !1,
                  removeNodes: !0,
                  detachNodes: !0,
                  resetScroll: !0,
                  fireLeave: !0,
                  fireLoading: !0,
                  fireLoaded: !0,
                  fireRefresh: !0,
                  fireEnter: !0,
                  fireComplete: !0,
                  fireDestroy: !0,
                  fetch: {},
                },
                e.options
              )),
              (e.event = {}),
              (e.parser = new DOMParser()),
              (e.running = !1),
              e.options.scrollRestoration &&
                (window.history.scrollRestoration =
                  e.options.scrollRestoration),
              e.options.bindLinks && e.bindLinks(),
              e.options.bindHistory && e.bindHistory(),
              e
            );
          }
          e(n, t);
          var i = n.prototype;
          return (
            (i.bindLinks = function () {
              var t = this;
              document.addEventListener("click", function (e) {
                if (!(e.ctrlKey || e.shiftKey || e.altKey || e.metaKey))
                  for (var n = e.target; n && n !== document; n = n.parentNode)
                    if (t.checkLink(n)) {
                      e.preventDefault(), t.goTo(n.href);
                      break;
                    }
              });
            }),
            (i.checkLink = function (t) {
              if (
                "A" !== t.tagName ||
                !t.href ||
                t.host !== window.location.host
              )
                return !1;
              if (t.getAttribute("target") || t.getAttribute("download"))
                return !1;
              if (this.options.checkLinkUrlRegExp) {
                var e = t.href.match(this.options.checkLinkUrlRegExp);
                if (!e || e[1]) return !1;
              }
              return !0;
            }),
            (i.bindHistory = function () {
              var t = this;
              (this.event.popstate = function () {
                return t.goTo(window.location.pathname, {
                  history: !1,
                });
              }),
                window.addEventListener("popstate", this.event.popstate);
            }),
            (i.pushHistory = function (t, e) {
              void 0 === e && (e = "push"),
                window.history["push" === e ? "pushState" : "replaceState"](
                  {},
                  "",
                  t
                );
            }),
            (i.replaceNodesBySelector = function (t, e, n, i) {
              void 0 === n && (n = !0), void 0 === i && (i = !1);
              var r = document.querySelectorAll(t),
                s = e.querySelectorAll(t);
              r.forEach(function (t, e) {
                s[e]
                  ? i
                    ? t.append.apply(t, s[e].childNodes)
                    : t.replaceWith(s[e])
                  : n && t.remove();
              });
            }),
            (i.goTo = function (t, e) {
              try {
                var n = function () {
                    function t() {
                      return Promise.resolve(i.executeRequest()).then(
                        function () {
                          function t() {
                            return Promise.resolve(
                              i.app.refresh(
                                i.reqOptions.fireRefresh,
                                i.reqOptions.fireDestroy,
                                i.reqOptions.detachNodes
                              )
                            ).then(function () {
                              function t() {
                                function t() {
                                  i.running = !1;
                                }
                                var e = (function () {
                                  if (i.reqOptions.fireComplete)
                                    return Promise.resolve(
                                      i.app.executeAll("complete")
                                    ).then(function () {});
                                })();
                                return e && e.then ? e.then(t) : t();
                              }
                              var e = (function () {
                                if (i.reqOptions.fireEnter)
                                  return Promise.resolve(
                                    i.app.executeAll("enter")
                                  ).then(function () {});
                              })();
                              return e && e.then ? e.then(t) : t();
                            });
                          }
                          var e = (function () {
                            if (i.reqOptions.fireLoaded)
                              return Promise.resolve(
                                i.app.executeAll("loaded")
                              ).then(function () {});
                          })();
                          return e && e.then ? e.then(t) : t();
                        }
                      );
                    }
                    var e = (function () {
                      if (i.reqOptions.fireLoading)
                        return Promise.resolve(
                          i.app.executeAll("loading")
                        ).then(function () {});
                    })();
                    return e && e.then ? e.then(t) : t();
                  },
                  i = this;
                if (
                  ((i.reqOptions = Object.assign({}, i.options, e)),
                  (i.reqOptions.url = t),
                  (i.reqOptions.urlClean = i.reqOptions.url.replace(
                    i.reqOptions.cleanUrlRegExp,
                    ""
                  )),
                  (i.reqOptions.prevUrl = window.location.href),
                  (i.reqOptions.prevUrlClean = i.reqOptions.prevUrl.replace(
                    i.reqOptions.cleanUrlRegExp,
                    ""
                  )),
                  i.reqOptions.preventSame &&
                    i.reqOptions.urlClean === i.reqOptions.prevUrlClean)
                )
                  return Promise.resolve(!1);
                if (i.reqOptions.preventRunning && i.running)
                  return Promise.resolve(!1);
                (i.running = !0),
                  i.reqOptions.history &&
                    i.pushHistory(i.reqOptions.url, i.reqOptions.history);
                var r = (function () {
                  if (i.reqOptions.fireLeave)
                    return Promise.resolve(i.app.executeAll("leave")).then(
                      function () {}
                    );
                })();
                return Promise.resolve(r && r.then ? r.then(n) : n());
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (i.executeRequest = function () {
              try {
                var t = this;
                return Promise.resolve(
                  fetch(t.reqOptions.url, t.reqOptions.fetch)
                ).then(function (e) {
                  if (
                    ((t.req = e), !t.reqOptions.checkResponseStatus || t.req.ok)
                  )
                    return Promise.resolve(t.req.text()).then(function (e) {
                      (t.reqData = e),
                        (t.reqDocument = t.parser.parseFromString(
                          t.reqData,
                          t.reqOptions.parserType
                        )),
                        t.reqOptions.updateSelectors &&
                          t.reqOptions.updateSelectors.forEach(function (e) {
                            t.replaceNodesBySelector(
                              e,
                              t.reqDocument,
                              t.reqOptions.removeNodes,
                              t.reqOptions.extendNodes
                            );
                          }),
                        t.reqOptions.resetScroll && window.scrollTo(0, 0);
                    });
                  window.location.assign(t.reqOptions.url);
                });
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            n
          );
        })(o);
      function l(t) {
        if (void 0 === t)
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          );
        return t;
      }
      function c(t, e) {
        (t.prototype = Object.create(e.prototype)),
          (t.prototype.constructor = t),
          (t.__proto__ = e);
      }
      var u,
        h,
        d,
        p,
        f,
        m,
        g,
        v,
        _,
        y,
        x,
        b,
        S,
        E,
        T = {
          autoSleep: 120,
          force3D: "auto",
          nullTargetWarn: 1,
          units: {
            lineHeight: "",
          },
        },
        M = {
          duration: 0.5,
          overwrite: !1,
          delay: 0,
        },
        w = 1e8,
        D = 1e-8,
        A = 2 * Math.PI,
        C = A / 4,
        P = 0,
        R = Math.sqrt,
        L = Math.cos,
        O = Math.sin,
        I = function (t) {
          return "string" == typeof t;
        },
        F = function (t) {
          return "function" == typeof t;
        },
        N = function (t) {
          return "number" == typeof t;
        },
        U = function (t) {
          return void 0 === t;
        },
        k = function (t) {
          return "object" == typeof t;
        },
        z = function (t) {
          return !1 !== t;
        },
        B = function () {
          return "undefined" != typeof window;
        },
        H = function (t) {
          return F(t) || I(t);
        },
        V =
          ("function" == typeof ArrayBuffer && ArrayBuffer.isView) ||
          function () {},
        G = Array.isArray,
        W = /(?:-?\.?\d|\.)+/gi,
        j = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
        X = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
        q = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
        Y = /[+-]=-?[.\d]+/,
        K = /[^,'"\[\]\s]+/gi,
        Z = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
        $ = {},
        J = {},
        Q = function (t) {
          return (J = At(t, $)) && Cn;
        },
        tt = function (t, e) {
          return console.warn(
            "Invalid property",
            t,
            "set to",
            e,
            "Missing plugin? gsap.registerPlugin()"
          );
        },
        et = function (t, e) {
          return !e && console.warn(t);
        },
        nt = function (t, e) {
          return (t && ($[t] = e) && J && (J[t] = e)) || $;
        },
        it = function () {
          return 0;
        },
        rt = {
          suppressEvents: !0,
          isStart: !0,
          kill: !1,
        },
        st = {
          suppressEvents: !0,
          kill: !1,
        },
        ot = {
          suppressEvents: !0,
        },
        at = {},
        lt = [],
        ct = {},
        ut = {},
        ht = {},
        dt = 30,
        pt = [],
        ft = "",
        mt = function (t) {
          var e,
            n,
            i = t[0];
          if ((k(i) || F(i) || (t = [t]), !(e = (i._gsap || {}).harness))) {
            for (n = pt.length; n-- && !pt[n].targetTest(i); );
            e = pt[n];
          }
          for (n = t.length; n--; )
            (t[n] && (t[n]._gsap || (t[n]._gsap = new Ve(t[n], e)))) ||
              t.splice(n, 1);
          return t;
        },
        gt = function (t) {
          return t._gsap || mt(se(t))[0]._gsap;
        },
        vt = function (t, e, n) {
          return (n = t[e]) && F(n)
            ? t[e]()
            : (U(n) && t.getAttribute && t.getAttribute(e)) || n;
        },
        _t = function (t, e) {
          return (t = t.split(",")).forEach(e) || t;
        },
        yt = function (t) {
          return Math.round(1e5 * t) / 1e5 || 0;
        },
        xt = function (t) {
          return Math.round(1e7 * t) / 1e7 || 0;
        },
        bt = function (t, e) {
          var n = e.charAt(0),
            i = parseFloat(e.substr(2));
          return (
            (t = parseFloat(t)),
            "+" === n ? t + i : "-" === n ? t - i : "*" === n ? t * i : t / i
          );
        },
        St = function (t, e) {
          for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n; );
          return i < n;
        },
        Et = function () {
          var t,
            e,
            n = lt.length,
            i = lt.slice(0);
          for (ct = {}, lt.length = 0, t = 0; t < n; t++)
            (e = i[t]) &&
              e._lazy &&
              (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0);
        },
        Tt = function (t, e, n, i) {
          lt.length && !h && Et(),
            t.render(e, n, i || (h && e < 0 && (t._initted || t._startAt))),
            lt.length && !h && Et();
        },
        Mt = function (t) {
          var e = parseFloat(t);
          return (e || 0 === e) && (t + "").match(K).length < 2
            ? e
            : I(t)
            ? t.trim()
            : t;
        },
        wt = function (t) {
          return t;
        },
        Dt = function (t, e) {
          for (var n in e) n in t || (t[n] = e[n]);
          return t;
        },
        At = function (t, e) {
          for (var n in e) t[n] = e[n];
          return t;
        },
        Ct = function t(e, n) {
          for (var i in n)
            "__proto__" !== i &&
              "constructor" !== i &&
              "prototype" !== i &&
              (e[i] = k(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i]);
          return e;
        },
        Pt = function (t, e) {
          var n,
            i = {};
          for (n in t) n in e || (i[n] = t[n]);
          return i;
        },
        Rt = function (t) {
          var e,
            n = t.parent || p,
            i = t.keyframes
              ? ((e = G(t.keyframes)),
                function (t, n) {
                  for (var i in n)
                    i in t ||
                      ("duration" === i && e) ||
                      "ease" === i ||
                      (t[i] = n[i]);
                })
              : Dt;
          if (z(t.inherit))
            for (; n; ) i(t, n.vars.defaults), (n = n.parent || n._dp);
          return t;
        },
        Lt = function (t, e, n, i, r) {
          void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
          var s,
            o = t[i];
          if (r) for (s = e[r]; o && o[r] > s; ) o = o._prev;
          return (
            o
              ? ((e._next = o._next), (o._next = e))
              : ((e._next = t[n]), (t[n] = e)),
            e._next ? (e._next._prev = e) : (t[i] = e),
            (e._prev = o),
            (e.parent = e._dp = t),
            e
          );
        },
        Ot = function (t, e, n, i) {
          void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
          var r = e._prev,
            s = e._next;
          r ? (r._next = s) : t[n] === e && (t[n] = s),
            s ? (s._prev = r) : t[i] === e && (t[i] = r),
            (e._next = e._prev = e.parent = null);
        },
        It = function (t, e) {
          t.parent &&
            (!e || t.parent.autoRemoveChildren) &&
            t.parent.remove &&
            t.parent.remove(t),
            (t._act = 0);
        },
        Ft = function (t, e) {
          if (t && (!e || e._end > t._dur || e._start < 0))
            for (var n = t; n; ) (n._dirty = 1), (n = n.parent);
          return t;
        },
        Nt = function (t, e, n, i) {
          return (
            t._startAt &&
            (h
              ? t._startAt.revert(st)
              : (t.vars.immediateRender && !t.vars.autoRevert) ||
                t._startAt.render(e, !0, i))
          );
        },
        Ut = function t(e) {
          return !e || (e._ts && t(e.parent));
        },
        kt = function (t) {
          return t._repeat
            ? zt(t._tTime, (t = t.duration() + t._rDelay)) * t
            : 0;
        },
        zt = function (t, e) {
          var n = Math.floor((t /= e));
          return t && n === t ? n - 1 : n;
        },
        Bt = function (t, e) {
          return (
            (t - e._start) * e._ts +
            (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
          );
        },
        Ht = function (t) {
          return (t._end = xt(
            t._start + (t._tDur / Math.abs(t._ts || t._rts || D) || 0)
          ));
        },
        Vt = function (t, e) {
          var n = t._dp;
          return (
            n &&
              n.smoothChildTiming &&
              t._ts &&
              ((t._start = xt(
                n._time -
                  (t._ts > 0
                    ? e / t._ts
                    : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)
              )),
              Ht(t),
              n._dirty || Ft(n, t)),
            t
          );
        },
        Gt = function (t, e) {
          var n;
          if (
            ((e._time ||
              (!e._dur && e._initted) ||
              (e._start < t._time && (e._dur || !e.add))) &&
              ((n = Bt(t.rawTime(), e)),
              (!e._dur || ee(0, e.totalDuration(), n) - e._tTime > D) &&
                e.render(n, !0)),
            Ft(t, e)._dp && t._initted && t._time >= t._dur && t._ts)
          ) {
            if (t._dur < t.duration())
              for (n = t; n._dp; )
                n.rawTime() >= 0 && n.totalTime(n._tTime), (n = n._dp);
            t._zTime = -1e-8;
          }
        },
        Wt = function (t, e, n, i) {
          return (
            e.parent && It(e),
            (e._start = xt(
              (N(n) ? n : n || t !== p ? Jt(t, n, e) : t._time) + e._delay
            )),
            (e._end = xt(
              e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)
            )),
            Lt(t, e, "_first", "_last", t._sort ? "_start" : 0),
            Yt(e) || (t._recent = e),
            i || Gt(t, e),
            t._ts < 0 && Vt(t, t._tTime),
            t
          );
        },
        jt = function (t, e) {
          return (
            ($.ScrollTrigger || tt("scrollTrigger", e)) &&
            $.ScrollTrigger.create(e, t)
          );
        },
        Xt = function (t, e, n, i, r) {
          return (
            Ze(t, e, r),
            t._initted
              ? !n &&
                t._pt &&
                !h &&
                ((t._dur && !1 !== t.vars.lazy) || (!t._dur && t.vars.lazy)) &&
                _ !== Ce.frame
                ? (lt.push(t), (t._lazy = [r, i]), 1)
                : void 0
              : 1
          );
        },
        qt = function t(e) {
          var n = e.parent;
          return (
            n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || t(n))
          );
        },
        Yt = function (t) {
          var e = t.data;
          return "isFromStart" === e || "isStart" === e;
        },
        Kt = function (t, e, n, i) {
          var r = t._repeat,
            s = xt(e) || 0,
            o = t._tTime / t._tDur;
          return (
            o && !i && (t._time *= s / t._dur),
            (t._dur = s),
            (t._tDur = r
              ? r < 0
                ? 1e10
                : xt(s * (r + 1) + t._rDelay * r)
              : s),
            o > 0 && !i && Vt(t, (t._tTime = t._tDur * o)),
            t.parent && Ht(t),
            n || Ft(t.parent, t),
            t
          );
        },
        Zt = function (t) {
          return t instanceof We ? Ft(t) : Kt(t, t._dur);
        },
        $t = {
          _start: 0,
          endTime: it,
          totalDuration: it,
        },
        Jt = function t(e, n, i) {
          var r,
            s,
            o,
            a = e.labels,
            l = e._recent || $t,
            c = e.duration() >= w ? l.endTime(!1) : e._dur;
          return I(n) && (isNaN(n) || n in a)
            ? ((s = n.charAt(0)),
              (o = "%" === n.substr(-1)),
              (r = n.indexOf("=")),
              "<" === s || ">" === s
                ? (r >= 0 && (n = n.replace(/=/, "")),
                  ("<" === s ? l._start : l.endTime(l._repeat >= 0)) +
                    (parseFloat(n.substr(1)) || 0) *
                      (o ? (r < 0 ? l : i).totalDuration() / 100 : 1))
                : r < 0
                ? (n in a || (a[n] = c), a[n])
                : ((s = parseFloat(n.charAt(r - 1) + n.substr(r + 1))),
                  o && i && (s = (s / 100) * (G(i) ? i[0] : i).totalDuration()),
                  r > 1 ? t(e, n.substr(0, r - 1), i) + s : c + s))
            : null == n
            ? c
            : +n;
        },
        Qt = function (t, e, n) {
          var i,
            r,
            s = N(e[1]),
            o = (s ? 2 : 1) + (t < 2 ? 0 : 1),
            a = e[o];
          if ((s && (a.duration = e[1]), (a.parent = n), t)) {
            for (i = a, r = n; r && !("immediateRender" in i); )
              (i = r.vars.defaults || {}), (r = z(r.vars.inherit) && r.parent);
            (a.immediateRender = z(i.immediateRender)),
              t < 2 ? (a.runBackwards = 1) : (a.startAt = e[o - 1]);
          }
          return new en(e[0], a, e[o + 1]);
        },
        te = function (t, e) {
          return t || 0 === t ? e(t) : e;
        },
        ee = function (t, e, n) {
          return n < t ? t : n > e ? e : n;
        },
        ne = function (t, e) {
          return I(t) && (e = Z.exec(t)) ? e[1] : "";
        },
        ie = [].slice,
        re = function (t, e) {
          return (
            t &&
            k(t) &&
            "length" in t &&
            ((!e && !t.length) || (t.length - 1 in t && k(t[0]))) &&
            !t.nodeType &&
            t !== f
          );
        },
        se = function (t, e, n) {
          return d && !e && d.selector
            ? d.selector(t)
            : !I(t) || n || (!m && Pe())
            ? G(t)
              ? (function (t, e, n) {
                  return (
                    void 0 === n && (n = []),
                    t.forEach(function (t) {
                      var i;
                      return (I(t) && !e) || re(t, 1)
                        ? (i = n).push.apply(i, se(t))
                        : n.push(t);
                    }) || n
                  );
                })(t, n)
              : re(t)
              ? ie.call(t, 0)
              : t
              ? [t]
              : []
            : ie.call((e || g).querySelectorAll(t), 0);
        },
        oe = function (t) {
          return (
            (t = se(t)[0] || et("Invalid scope") || {}),
            function (e) {
              var n = t.current || t.nativeElement || t;
              return se(
                e,
                n.querySelectorAll
                  ? n
                  : n === t
                  ? et("Invalid scope") || g.createElement("div")
                  : t
              );
            }
          );
        },
        ae = function (t) {
          return t.sort(function () {
            return 0.5 - Math.random();
          });
        },
        le = function (t) {
          if (F(t)) return t;
          var e = k(t)
              ? t
              : {
                  each: t,
                },
            n = Ue(e.ease),
            i = e.from || 0,
            r = parseFloat(e.base) || 0,
            s = {},
            o = i > 0 && i < 1,
            a = isNaN(i) || o,
            l = e.axis,
            c = i,
            u = i;
          return (
            I(i)
              ? (c = u =
                  {
                    center: 0.5,
                    edges: 0.5,
                    end: 1,
                  }[i] || 0)
              : !o && a && ((c = i[0]), (u = i[1])),
            function (t, o, h) {
              var d,
                p,
                f,
                m,
                g,
                v,
                _,
                y,
                x,
                b = (h || e).length,
                S = s[b];
              if (!S) {
                if (!(x = "auto" === e.grid ? 0 : (e.grid || [1, w])[1])) {
                  for (
                    _ = -w;
                    _ < (_ = h[x++].getBoundingClientRect().left) && x < b;

                  );
                  x--;
                }
                for (
                  S = s[b] = [],
                    d = a ? Math.min(x, b) * c - 0.5 : i % x,
                    p = x === w ? 0 : a ? (b * u) / x - 0.5 : (i / x) | 0,
                    _ = 0,
                    y = w,
                    v = 0;
                  v < b;
                  v++
                )
                  (f = (v % x) - d),
                    (m = p - ((v / x) | 0)),
                    (S[v] = g =
                      l ? Math.abs("y" === l ? m : f) : R(f * f + m * m)),
                    g > _ && (_ = g),
                    g < y && (y = g);
                "random" === i && ae(S),
                  (S.max = _ - y),
                  (S.min = y),
                  (S.v = b =
                    (parseFloat(e.amount) ||
                      parseFloat(e.each) *
                        (x > b
                          ? b - 1
                          : l
                          ? "y" === l
                            ? b / x
                            : x
                          : Math.max(x, b / x)) ||
                      0) * ("edges" === i ? -1 : 1)),
                  (S.b = b < 0 ? r - b : r),
                  (S.u = ne(e.amount || e.each) || 0),
                  (n = n && b < 0 ? Fe(n) : n);
              }
              return (
                (b = (S[t] - S.min) / S.max || 0),
                xt(S.b + (n ? n(b) : b) * S.v) + S.u
              );
            }
          );
        },
        ce = function (t) {
          var e = Math.pow(10, ((t + "").split(".")[1] || "").length);
          return function (n) {
            var i = xt(Math.round(parseFloat(n) / t) * t * e);
            return (i - (i % 1)) / e + (N(n) ? 0 : ne(n));
          };
        },
        ue = function (t, e) {
          var n,
            i,
            r = G(t);
          return (
            !r &&
              k(t) &&
              ((n = r = t.radius || w),
              t.values
                ? ((t = se(t.values)), (i = !N(t[0])) && (n *= n))
                : (t = ce(t.increment))),
            te(
              e,
              r
                ? F(t)
                  ? function (e) {
                      return (i = t(e)), Math.abs(i - e) <= n ? i : e;
                    }
                  : function (e) {
                      for (
                        var r,
                          s,
                          o = parseFloat(i ? e.x : e),
                          a = parseFloat(i ? e.y : 0),
                          l = w,
                          c = 0,
                          u = t.length;
                        u--;

                      )
                        (r = i
                          ? (r = t[u].x - o) * r + (s = t[u].y - a) * s
                          : Math.abs(t[u] - o)) < l && ((l = r), (c = u));
                      return (
                        (c = !n || l <= n ? t[c] : e),
                        i || c === e || N(e) ? c : c + ne(e)
                      );
                    }
                : ce(t)
            )
          );
        },
        he = function (t, e, n, i) {
          return te(G(t) ? !e : !0 === n ? !!(n = 0) : !i, function () {
            return G(t)
              ? t[~~(Math.random() * t.length)]
              : (n = n || 1e-5) &&
                  (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) &&
                  Math.floor(
                    Math.round(
                      (t - n / 2 + Math.random() * (e - t + 0.99 * n)) / n
                    ) *
                      n *
                      i
                  ) / i;
          });
        },
        de = function (t, e, n) {
          return te(n, function (n) {
            return t[~~e(n)];
          });
        },
        pe = function (t) {
          for (var e, n, i, r, s = 0, o = ""; ~(e = t.indexOf("random(", s)); )
            (i = t.indexOf(")", e)),
              (r = "[" === t.charAt(e + 7)),
              (n = t.substr(e + 7, i - e - 7).match(r ? K : W)),
              (o +=
                t.substr(s, e - s) +
                he(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5)),
              (s = i + 1);
          return o + t.substr(s, t.length - s);
        },
        fe = function (t, e, n, i, r) {
          var s = e - t,
            o = i - n;
          return te(r, function (e) {
            return n + (((e - t) / s) * o || 0);
          });
        },
        me = function (t, e, n) {
          var i,
            r,
            s,
            o = t.labels,
            a = w;
          for (i in o)
            (r = o[i] - e) < 0 == !!n &&
              r &&
              a > (r = Math.abs(r)) &&
              ((s = i), (a = r));
          return s;
        },
        ge = function (t, e, n) {
          var i,
            r,
            s,
            o = t.vars,
            a = o[e],
            l = d,
            c = t._ctx;
          if (a)
            return (
              (i = o[e + "Params"]),
              (r = o.callbackScope || t),
              n && lt.length && Et(),
              c && (d = c),
              (s = i ? a.apply(r, i) : a.call(r)),
              (d = l),
              s
            );
        },
        ve = function (t) {
          return (
            It(t),
            t.scrollTrigger && t.scrollTrigger.kill(!!h),
            t.progress() < 1 && ge(t, "onInterrupt"),
            t
          );
        },
        _e = [],
        ye = function (t) {
          if (B() && t) {
            var e = (t = (!t.name && t.default) || t).name,
              n = F(t),
              i =
                e && !n && t.init
                  ? function () {
                      this._props = [];
                    }
                  : t,
              r = {
                init: it,
                render: hn,
                add: Ye,
                kill: pn,
                modifier: dn,
                rawVars: 0,
              },
              s = {
                targetTest: 0,
                get: 0,
                getSetter: an,
                aliases: {},
                register: 0,
              };
            if ((Pe(), t !== i)) {
              if (ut[e]) return;
              Dt(i, Dt(Pt(t, r), s)),
                At(i.prototype, At(r, Pt(t, s))),
                (ut[(i.prop = e)] = i),
                t.targetTest && (pt.push(i), (at[e] = 1)),
                (e =
                  ("css" === e
                    ? "CSS"
                    : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin");
            }
            nt(e, i), t.register && t.register(Cn, i, gn);
          } else t && _e.push(t);
        },
        xe = 255,
        be = {
          aqua: [0, xe, xe],
          lime: [0, xe, 0],
          silver: [192, 192, 192],
          black: [0, 0, 0],
          maroon: [128, 0, 0],
          teal: [0, 128, 128],
          blue: [0, 0, xe],
          navy: [0, 0, 128],
          white: [xe, xe, xe],
          olive: [128, 128, 0],
          yellow: [xe, xe, 0],
          orange: [xe, 165, 0],
          gray: [128, 128, 128],
          purple: [128, 0, 128],
          green: [0, 128, 0],
          red: [xe, 0, 0],
          pink: [xe, 192, 203],
          cyan: [0, xe, xe],
          transparent: [xe, xe, xe, 0],
        },
        Se = function (t, e, n) {
          return (
            ((6 * (t += t < 0 ? 1 : t > 1 ? -1 : 0) < 1
              ? e + (n - e) * t * 6
              : t < 0.5
              ? n
              : 3 * t < 2
              ? e + (n - e) * (2 / 3 - t) * 6
              : e) *
              xe +
              0.5) |
            0
          );
        },
        Ee = function (t, e, n) {
          var i,
            r,
            s,
            o,
            a,
            l,
            c,
            u,
            h,
            d,
            p = t ? (N(t) ? [t >> 16, (t >> 8) & xe, t & xe] : 0) : be.black;
          if (!p) {
            if (
              ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), be[t])
            )
              p = be[t];
            else if ("#" === t.charAt(0)) {
              if (
                (t.length < 6 &&
                  ((i = t.charAt(1)),
                  (r = t.charAt(2)),
                  (s = t.charAt(3)),
                  (t =
                    "#" +
                    i +
                    i +
                    r +
                    r +
                    s +
                    s +
                    (5 === t.length ? t.charAt(4) + t.charAt(4) : ""))),
                9 === t.length)
              )
                return [
                  (p = parseInt(t.substr(1, 6), 16)) >> 16,
                  (p >> 8) & xe,
                  p & xe,
                  parseInt(t.substr(7), 16) / 255,
                ];
              p = [
                (t = parseInt(t.substr(1), 16)) >> 16,
                (t >> 8) & xe,
                t & xe,
              ];
            } else if ("hsl" === t.substr(0, 3))
              if (((p = d = t.match(W)), e)) {
                if (~t.indexOf("="))
                  return (p = t.match(j)), n && p.length < 4 && (p[3] = 1), p;
              } else
                (o = (+p[0] % 360) / 360),
                  (a = +p[1] / 100),
                  (i =
                    2 * (l = +p[2] / 100) -
                    (r = l <= 0.5 ? l * (a + 1) : l + a - l * a)),
                  p.length > 3 && (p[3] *= 1),
                  (p[0] = Se(o + 1 / 3, i, r)),
                  (p[1] = Se(o, i, r)),
                  (p[2] = Se(o - 1 / 3, i, r));
            else p = t.match(W) || be.transparent;
            p = p.map(Number);
          }
          return (
            e &&
              !d &&
              ((i = p[0] / xe),
              (r = p[1] / xe),
              (s = p[2] / xe),
              (l = ((c = Math.max(i, r, s)) + (u = Math.min(i, r, s))) / 2),
              c === u
                ? (o = a = 0)
                : ((h = c - u),
                  (a = l > 0.5 ? h / (2 - c - u) : h / (c + u)),
                  (o =
                    c === i
                      ? (r - s) / h + (r < s ? 6 : 0)
                      : c === r
                      ? (s - i) / h + 2
                      : (i - r) / h + 4),
                  (o *= 60)),
              (p[0] = ~~(o + 0.5)),
              (p[1] = ~~(100 * a + 0.5)),
              (p[2] = ~~(100 * l + 0.5))),
            n && p.length < 4 && (p[3] = 1),
            p
          );
        },
        Te = function (t) {
          var e = [],
            n = [],
            i = -1;
          return (
            t.split(we).forEach(function (t) {
              var r = t.match(X) || [];
              e.push.apply(e, r), n.push((i += r.length + 1));
            }),
            (e.c = n),
            e
          );
        },
        Me = function (t, e, n) {
          var i,
            r,
            s,
            o,
            a = "",
            l = (t + a).match(we),
            c = e ? "hsla(" : "rgba(",
            u = 0;
          if (!l) return t;
          if (
            ((l = l.map(function (t) {
              return (
                (t = Ee(t, e, 1)) &&
                c +
                  (e
                    ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3]
                    : t.join(",")) +
                  ")"
              );
            })),
            n && ((s = Te(t)), (i = n.c).join(a) !== s.c.join(a)))
          )
            for (o = (r = t.replace(we, "1").split(X)).length - 1; u < o; u++)
              a +=
                r[u] +
                (~i.indexOf(u)
                  ? l.shift() || c + "0,0,0,0)"
                  : (s.length ? s : l.length ? l : n).shift());
          if (!r)
            for (o = (r = t.split(we)).length - 1; u < o; u++) a += r[u] + l[u];
          return a + r[o];
        },
        we = (function () {
          var t,
            e =
              "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
          for (t in be) e += "|" + t + "\\b";
          return new RegExp(e + ")", "gi");
        })(),
        De = /hsl[a]?\(/,
        Ae = function (t) {
          var e,
            n = t.join(" ");
          if (((we.lastIndex = 0), we.test(n)))
            return (
              (e = De.test(n)),
              (t[1] = Me(t[1], e)),
              (t[0] = Me(t[0], e, Te(t[1]))),
              !0
            );
        },
        Ce = (function () {
          var t,
            e,
            n,
            i,
            r,
            s,
            o = Date.now,
            a = 500,
            l = 33,
            c = o(),
            u = c,
            h = 1e3 / 240,
            d = h,
            p = [],
            _ = function n(f) {
              var m,
                g,
                v,
                _,
                y = o() - u,
                x = !0 === f;
              if (
                (y > a && (c += y - l),
                ((m = (v = (u += y) - c) - d) > 0 || x) &&
                  ((_ = ++i.frame),
                  (r = v - 1e3 * i.time),
                  (i.time = v /= 1e3),
                  (d += m + (m >= h ? 4 : h - m)),
                  (g = 1)),
                x || (t = e(n)),
                g)
              )
                for (s = 0; s < p.length; s++) p[s](v, r, _, f);
            };
          return (
            (i = {
              time: 0,
              frame: 0,
              tick: function () {
                _(!0);
              },
              deltaRatio: function (t) {
                return r / (1e3 / (t || 60));
              },
              wake: function () {
                v &&
                  (!m &&
                    B() &&
                    ((f = m = window),
                    (g = f.document || {}),
                    ($.gsap = Cn),
                    (f.gsapVersions || (f.gsapVersions = [])).push(Cn.version),
                    Q(J || f.GreenSockGlobals || (!f.gsap && f) || {}),
                    (n = f.requestAnimationFrame),
                    _e.forEach(ye)),
                  t && i.sleep(),
                  (e =
                    n ||
                    function (t) {
                      return setTimeout(t, (d - 1e3 * i.time + 1) | 0);
                    }),
                  (x = 1),
                  _(2));
              },
              sleep: function () {
                (n ? f.cancelAnimationFrame : clearTimeout)(t),
                  (x = 0),
                  (e = it);
              },
              lagSmoothing: function (t, e) {
                (a = t || 1 / 0), (l = Math.min(e || 33, a));
              },
              fps: function (t) {
                (h = 1e3 / (t || 240)), (d = 1e3 * i.time + h);
              },
              add: function (t, e, n) {
                var r = e
                  ? function (e, n, s, o) {
                      t(e, n, s, o), i.remove(r);
                    }
                  : t;
                return i.remove(t), p[n ? "unshift" : "push"](r), Pe(), r;
              },
              remove: function (t, e) {
                ~(e = p.indexOf(t)) && p.splice(e, 1) && s >= e && s--;
              },
              _listeners: p,
            }),
            i
          );
        })(),
        Pe = function () {
          return !x && Ce.wake();
        },
        Re = {},
        Le = /^[\d.\-M][\d.\-,\s]/,
        Oe = /["']/g,
        Ie = function (t) {
          for (
            var e,
              n,
              i,
              r = {},
              s = t.substr(1, t.length - 3).split(":"),
              o = s[0],
              a = 1,
              l = s.length;
            a < l;
            a++
          )
            (n = s[a]),
              (e = a !== l - 1 ? n.lastIndexOf(",") : n.length),
              (i = n.substr(0, e)),
              (r[o] = isNaN(i) ? i.replace(Oe, "").trim() : +i),
              (o = n.substr(e + 1).trim());
          return r;
        },
        Fe = function (t) {
          return function (e) {
            return 1 - t(1 - e);
          };
        },
        Ne = function t(e, n) {
          for (var i, r = e._first; r; )
            r instanceof We
              ? t(r, n)
              : !r.vars.yoyoEase ||
                (r._yoyo && r._repeat) ||
                r._yoyo === n ||
                (r.timeline
                  ? t(r.timeline, n)
                  : ((i = r._ease),
                    (r._ease = r._yEase),
                    (r._yEase = i),
                    (r._yoyo = n))),
              (r = r._next);
        },
        Ue = function (t, e) {
          return (
            (t &&
              (F(t)
                ? t
                : Re[t] ||
                  (function (t) {
                    var e,
                      n,
                      i,
                      r,
                      s = (t + "").split("("),
                      o = Re[s[0]];
                    return o && s.length > 1 && o.config
                      ? o.config.apply(
                          null,
                          ~t.indexOf("{")
                            ? [Ie(s[1])]
                            : ((e = t),
                              (n = e.indexOf("(") + 1),
                              (i = e.indexOf(")")),
                              (r = e.indexOf("(", n)),
                              e.substring(
                                n,
                                ~r && r < i ? e.indexOf(")", i + 1) : i
                              ))
                                .split(",")
                                .map(Mt)
                        )
                      : Re._CE && Le.test(t)
                      ? Re._CE("", t)
                      : o;
                  })(t))) ||
            e
          );
        },
        ke = function (t, e, n, i) {
          void 0 === n &&
            (n = function (t) {
              return 1 - e(1 - t);
            }),
            void 0 === i &&
              (i = function (t) {
                return t < 0.5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2;
              });
          var r,
            s = {
              easeIn: e,
              easeOut: n,
              easeInOut: i,
            };
          return (
            _t(t, function (t) {
              for (var e in ((Re[t] = $[t] = s),
              (Re[(r = t.toLowerCase())] = n),
              s))
                Re[
                  r +
                    ("easeIn" === e
                      ? ".in"
                      : "easeOut" === e
                      ? ".out"
                      : ".inOut")
                ] = Re[t + "." + e] = s[e];
            }),
            s
          );
        },
        ze = function (t) {
          return function (e) {
            return e < 0.5
              ? (1 - t(1 - 2 * e)) / 2
              : 0.5 + t(2 * (e - 0.5)) / 2;
          };
        },
        Be = function t(e, n, i) {
          var r = n >= 1 ? n : 1,
            s = (i || (e ? 0.3 : 0.45)) / (n < 1 ? n : 1),
            o = (s / A) * (Math.asin(1 / r) || 0),
            a = function (t) {
              return 1 === t
                ? 1
                : r * Math.pow(2, -10 * t) * O((t - o) * s) + 1;
            },
            l =
              "out" === e
                ? a
                : "in" === e
                ? function (t) {
                    return 1 - a(1 - t);
                  }
                : ze(a);
          return (
            (s = A / s),
            (l.config = function (n, i) {
              return t(e, n, i);
            }),
            l
          );
        },
        He = function t(e, n) {
          void 0 === n && (n = 1.70158);
          var i = function (t) {
              return t ? --t * t * ((n + 1) * t + n) + 1 : 0;
            },
            r =
              "out" === e
                ? i
                : "in" === e
                ? function (t) {
                    return 1 - i(1 - t);
                  }
                : ze(i);
          return (
            (r.config = function (n) {
              return t(e, n);
            }),
            r
          );
        };
      _t("Linear,Quad,Cubic,Quart,Quint,Strong", function (t, e) {
        var n = e < 5 ? e + 1 : e;
        ke(
          t + ",Power" + (n - 1),
          e
            ? function (t) {
                return Math.pow(t, n);
              }
            : function (t) {
                return t;
              },
          function (t) {
            return 1 - Math.pow(1 - t, n);
          },
          function (t) {
            return t < 0.5
              ? Math.pow(2 * t, n) / 2
              : 1 - Math.pow(2 * (1 - t), n) / 2;
          }
        );
      }),
        (Re.Linear.easeNone = Re.none = Re.Linear.easeIn),
        ke("Elastic", Be("in"), Be("out"), Be()),
        (b = 7.5625),
        (S = 2.75),
        ke(
          "Bounce",
          function (t) {
            return 1 - E(1 - t);
          },
          (E = function (t) {
            return t < 0.36363636363636365
              ? b * t * t
              : t < 0.7272727272727273
              ? b * Math.pow(t - 1.5 / S, 2) + 0.75
              : t < 0.9090909090909092
              ? b * (t -= 2.25 / S) * t + 0.9375
              : b * Math.pow(t - 2.625 / S, 2) + 0.984375;
          })
        ),
        ke("Expo", function (t) {
          return t ? Math.pow(2, 10 * (t - 1)) : 0;
        }),
        ke("Circ", function (t) {
          return -(R(1 - t * t) - 1);
        }),
        ke("Sine", function (t) {
          return 1 === t ? 1 : 1 - L(t * C);
        }),
        ke("Back", He("in"), He("out"), He()),
        (Re.SteppedEase =
          Re.steps =
          $.SteppedEase =
            {
              config: function (t, e) {
                void 0 === t && (t = 1);
                var n = 1 / t,
                  i = t + (e ? 0 : 1),
                  r = e ? 1 : 0;
                return function (t) {
                  return (((i * ee(0, 0.99999999, t)) | 0) + r) * n;
                };
              },
            }),
        (M.ease = Re["quad.out"]),
        _t(
          "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
          function (t) {
            return (ft += t + "," + t + "Params,");
          }
        );
      var Ve = function (t, e) {
          (this.id = P++),
            (t._gsap = this),
            (this.target = t),
            (this.harness = e),
            (this.get = e ? e.get : vt),
            (this.set = e ? e.getSetter : an);
        },
        Ge = (function () {
          function t(t) {
            (this.vars = t),
              (this._delay = +t.delay || 0),
              (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) &&
                ((this._rDelay = t.repeatDelay || 0),
                (this._yoyo = !!t.yoyo || !!t.yoyoEase)),
              (this._ts = 1),
              Kt(this, +t.duration, 1, 1),
              (this.data = t.data),
              d && ((this._ctx = d), d.data.push(this)),
              x || Ce.wake();
          }
          var e = t.prototype;
          return (
            (e.delay = function (t) {
              return t || 0 === t
                ? (this.parent &&
                    this.parent.smoothChildTiming &&
                    this.startTime(this._start + t - this._delay),
                  (this._delay = t),
                  this)
                : this._delay;
            }),
            (e.duration = function (t) {
              return arguments.length
                ? this.totalDuration(
                    this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t
                  )
                : this.totalDuration() && this._dur;
            }),
            (e.totalDuration = function (t) {
              return arguments.length
                ? ((this._dirty = 0),
                  Kt(
                    this,
                    this._repeat < 0
                      ? t
                      : (t - this._repeat * this._rDelay) / (this._repeat + 1)
                  ))
                : this._tDur;
            }),
            (e.totalTime = function (t, e) {
              if ((Pe(), !arguments.length)) return this._tTime;
              var n = this._dp;
              if (n && n.smoothChildTiming && this._ts) {
                for (
                  Vt(this, t), !n._dp || n.parent || Gt(n, this);
                  n && n.parent;

                )
                  n.parent._time !==
                    n._start +
                      (n._ts >= 0
                        ? n._tTime / n._ts
                        : (n.totalDuration() - n._tTime) / -n._ts) &&
                    n.totalTime(n._tTime, !0),
                    (n = n.parent);
                !this.parent &&
                  this._dp.autoRemoveChildren &&
                  ((this._ts > 0 && t < this._tDur) ||
                    (this._ts < 0 && t > 0) ||
                    (!this._tDur && !t)) &&
                  Wt(this._dp, this, this._start - this._delay);
              }
              return (
                (this._tTime !== t ||
                  (!this._dur && !e) ||
                  (this._initted && Math.abs(this._zTime) === D) ||
                  (!t && !this._initted && (this.add || this._ptLookup))) &&
                  (this._ts || (this._pTime = t), Tt(this, t, e)),
                this
              );
            }),
            (e.time = function (t, e) {
              return arguments.length
                ? this.totalTime(
                    Math.min(this.totalDuration(), t + kt(this)) %
                      (this._dur + this._rDelay) || (t ? this._dur : 0),
                    e
                  )
                : this._time;
            }),
            (e.totalProgress = function (t, e) {
              return arguments.length
                ? this.totalTime(this.totalDuration() * t, e)
                : this.totalDuration()
                ? Math.min(1, this._tTime / this._tDur)
                : this.ratio;
            }),
            (e.progress = function (t, e) {
              return arguments.length
                ? this.totalTime(
                    this.duration() *
                      (!this._yoyo || 1 & this.iteration() ? t : 1 - t) +
                      kt(this),
                    e
                  )
                : this.duration()
                ? Math.min(1, this._time / this._dur)
                : this.ratio;
            }),
            (e.iteration = function (t, e) {
              var n = this.duration() + this._rDelay;
              return arguments.length
                ? this.totalTime(this._time + (t - 1) * n, e)
                : this._repeat
                ? zt(this._tTime, n) + 1
                : 1;
            }),
            (e.timeScale = function (t) {
              if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
              if (this._rts === t) return this;
              var e =
                this.parent && this._ts
                  ? Bt(this.parent._time, this)
                  : this._tTime;
              return (
                (this._rts = +t || 0),
                (this._ts = this._ps || -1e-8 === t ? 0 : this._rts),
                this.totalTime(ee(-Math.abs(this._delay), this._tDur, e), !0),
                Ht(this),
                (function (t) {
                  for (var e = t.parent; e && e.parent; )
                    (e._dirty = 1), e.totalDuration(), (e = e.parent);
                  return t;
                })(this)
              );
            }),
            (e.paused = function (t) {
              return arguments.length
                ? (this._ps !== t &&
                    ((this._ps = t),
                    t
                      ? ((this._pTime =
                          this._tTime ||
                          Math.max(-this._delay, this.rawTime())),
                        (this._ts = this._act = 0))
                      : (Pe(),
                        (this._ts = this._rts),
                        this.totalTime(
                          this.parent && !this.parent.smoothChildTiming
                            ? this.rawTime()
                            : this._tTime || this._pTime,
                          1 === this.progress() &&
                            Math.abs(this._zTime) !== D &&
                            (this._tTime -= D)
                        ))),
                  this)
                : this._ps;
            }),
            (e.startTime = function (t) {
              if (arguments.length) {
                this._start = t;
                var e = this.parent || this._dp;
                return (
                  e &&
                    (e._sort || !this.parent) &&
                    Wt(e, this, t - this._delay),
                  this
                );
              }
              return this._start;
            }),
            (e.endTime = function (t) {
              return (
                this._start +
                (z(t) ? this.totalDuration() : this.duration()) /
                  Math.abs(this._ts || 1)
              );
            }),
            (e.rawTime = function (t) {
              var e = this.parent || this._dp;
              return e
                ? t &&
                  (!this._ts ||
                    (this._repeat && this._time && this.totalProgress() < 1))
                  ? this._tTime % (this._dur + this._rDelay)
                  : this._ts
                  ? Bt(e.rawTime(t), this)
                  : this._tTime
                : this._tTime;
            }),
            (e.revert = function (t) {
              void 0 === t && (t = ot);
              var e = h;
              return (
                (h = t),
                (this._initted || this._startAt) &&
                  (this.timeline && this.timeline.revert(t),
                  this.totalTime(-0.01, t.suppressEvents)),
                "nested" !== this.data && !1 !== t.kill && this.kill(),
                (h = e),
                this
              );
            }),
            (e.globalTime = function (t) {
              for (var e = this, n = arguments.length ? t : e.rawTime(); e; )
                (n = e._start + n / (e._ts || 1)), (e = e._dp);
              return !this.parent && this._sat
                ? this._sat.vars.immediateRender
                  ? -1 / 0
                  : this._sat.globalTime(t)
                : n;
            }),
            (e.repeat = function (t) {
              return arguments.length
                ? ((this._repeat = t === 1 / 0 ? -2 : t), Zt(this))
                : -2 === this._repeat
                ? 1 / 0
                : this._repeat;
            }),
            (e.repeatDelay = function (t) {
              if (arguments.length) {
                var e = this._time;
                return (this._rDelay = t), Zt(this), e ? this.time(e) : this;
              }
              return this._rDelay;
            }),
            (e.yoyo = function (t) {
              return arguments.length ? ((this._yoyo = t), this) : this._yoyo;
            }),
            (e.seek = function (t, e) {
              return this.totalTime(Jt(this, t), z(e));
            }),
            (e.restart = function (t, e) {
              return this.play().totalTime(t ? -this._delay : 0, z(e));
            }),
            (e.play = function (t, e) {
              return null != t && this.seek(t, e), this.reversed(!1).paused(!1);
            }),
            (e.reverse = function (t, e) {
              return (
                null != t && this.seek(t || this.totalDuration(), e),
                this.reversed(!0).paused(!1)
              );
            }),
            (e.pause = function (t, e) {
              return null != t && this.seek(t, e), this.paused(!0);
            }),
            (e.resume = function () {
              return this.paused(!1);
            }),
            (e.reversed = function (t) {
              return arguments.length
                ? (!!t !== this.reversed() &&
                    this.timeScale(-this._rts || (t ? -1e-8 : 0)),
                  this)
                : this._rts < 0;
            }),
            (e.invalidate = function () {
              return (
                (this._initted = this._act = 0), (this._zTime = -1e-8), this
              );
            }),
            (e.isActive = function () {
              var t,
                e = this.parent || this._dp,
                n = this._start;
              return !(
                e &&
                !(
                  this._ts &&
                  this._initted &&
                  e.isActive() &&
                  (t = e.rawTime(!0)) >= n &&
                  t < this.endTime(!0) - D
                )
              );
            }),
            (e.eventCallback = function (t, e, n) {
              var i = this.vars;
              return arguments.length > 1
                ? (e
                    ? ((i[t] = e),
                      n && (i[t + "Params"] = n),
                      "onUpdate" === t && (this._onUpdate = e))
                    : delete i[t],
                  this)
                : i[t];
            }),
            (e.then = function (t) {
              var e = this;
              return new Promise(function (n) {
                var i = F(t) ? t : wt,
                  r = function () {
                    var t = e.then;
                    (e.then = null),
                      F(i) && (i = i(e)) && (i.then || i === e) && (e.then = t),
                      n(i),
                      (e.then = t);
                  };
                (e._initted && 1 === e.totalProgress() && e._ts >= 0) ||
                (!e._tTime && e._ts < 0)
                  ? r()
                  : (e._prom = r);
              });
            }),
            (e.kill = function () {
              ve(this);
            }),
            t
          );
        })();
      Dt(Ge.prototype, {
        _time: 0,
        _start: 0,
        _end: 0,
        _tTime: 0,
        _tDur: 0,
        _dirty: 0,
        _repeat: 0,
        _yoyo: !1,
        parent: null,
        _initted: !1,
        _rDelay: 0,
        _ts: 1,
        _dp: 0,
        ratio: 0,
        _zTime: -1e-8,
        _prom: 0,
        _ps: !1,
        _rts: 1,
      });
      var We = (function (t) {
        function e(e, n) {
          var i;
          return (
            void 0 === e && (e = {}),
            ((i = t.call(this, e) || this).labels = {}),
            (i.smoothChildTiming = !!e.smoothChildTiming),
            (i.autoRemoveChildren = !!e.autoRemoveChildren),
            (i._sort = z(e.sortChildren)),
            p && Wt(e.parent || p, l(i), n),
            e.reversed && i.reverse(),
            e.paused && i.paused(!0),
            e.scrollTrigger && jt(l(i), e.scrollTrigger),
            i
          );
        }
        c(e, t);
        var n = e.prototype;
        return (
          (n.to = function (t, e, n) {
            return Qt(0, arguments, this), this;
          }),
          (n.from = function (t, e, n) {
            return Qt(1, arguments, this), this;
          }),
          (n.fromTo = function (t, e, n, i) {
            return Qt(2, arguments, this), this;
          }),
          (n.set = function (t, e, n) {
            return (
              (e.duration = 0),
              (e.parent = this),
              Rt(e).repeatDelay || (e.repeat = 0),
              (e.immediateRender = !!e.immediateRender),
              new en(t, e, Jt(this, n), 1),
              this
            );
          }),
          (n.call = function (t, e, n) {
            return Wt(this, en.delayedCall(0, t, e), n);
          }),
          (n.staggerTo = function (t, e, n, i, r, s, o) {
            return (
              (n.duration = e),
              (n.stagger = n.stagger || i),
              (n.onComplete = s),
              (n.onCompleteParams = o),
              (n.parent = this),
              new en(t, n, Jt(this, r)),
              this
            );
          }),
          (n.staggerFrom = function (t, e, n, i, r, s, o) {
            return (
              (n.runBackwards = 1),
              (Rt(n).immediateRender = z(n.immediateRender)),
              this.staggerTo(t, e, n, i, r, s, o)
            );
          }),
          (n.staggerFromTo = function (t, e, n, i, r, s, o, a) {
            return (
              (i.startAt = n),
              (Rt(i).immediateRender = z(i.immediateRender)),
              this.staggerTo(t, e, i, r, s, o, a)
            );
          }),
          (n.render = function (t, e, n) {
            var i,
              r,
              s,
              o,
              a,
              l,
              c,
              u,
              d,
              f,
              m,
              g,
              v = this._time,
              _ = this._dirty ? this.totalDuration() : this._tDur,
              y = this._dur,
              x = t <= 0 ? 0 : xt(t),
              b = this._zTime < 0 != t < 0 && (this._initted || !y);
            if (
              (this !== p && x > _ && t >= 0 && (x = _),
              x !== this._tTime || n || b)
            ) {
              if (
                (v !== this._time &&
                  y &&
                  ((x += this._time - v), (t += this._time - v)),
                (i = x),
                (d = this._start),
                (l = !(u = this._ts)),
                b && (y || (v = this._zTime), (t || !e) && (this._zTime = t)),
                this._repeat)
              ) {
                if (
                  ((m = this._yoyo),
                  (a = y + this._rDelay),
                  this._repeat < -1 && t < 0)
                )
                  return this.totalTime(100 * a + t, e, n);
                if (
                  ((i = xt(x % a)),
                  x === _
                    ? ((o = this._repeat), (i = y))
                    : ((o = ~~(x / a)) && o === x / a && ((i = y), o--),
                      i > y && (i = y)),
                  (f = zt(this._tTime, a)),
                  !v &&
                    this._tTime &&
                    f !== o &&
                    this._tTime - f * a - this._dur <= 0 &&
                    (f = o),
                  m && 1 & o && ((i = y - i), (g = 1)),
                  o !== f && !this._lock)
                ) {
                  var S = m && 1 & f,
                    E = S === (m && 1 & o);
                  if (
                    (o < f && (S = !S),
                    (v = S ? 0 : x % y ? y : x),
                    (this._lock = 1),
                    (this.render(v || (g ? 0 : xt(o * a)), e, !y)._lock = 0),
                    (this._tTime = x),
                    !e && this.parent && ge(this, "onRepeat"),
                    this.vars.repeatRefresh &&
                      !g &&
                      (this.invalidate()._lock = 1),
                    (v && v !== this._time) ||
                      l !== !this._ts ||
                      (this.vars.onRepeat && !this.parent && !this._act))
                  )
                    return this;
                  if (
                    ((y = this._dur),
                    (_ = this._tDur),
                    E &&
                      ((this._lock = 2),
                      (v = S ? y : -1e-4),
                      this.render(v, !0),
                      this.vars.repeatRefresh && !g && this.invalidate()),
                    (this._lock = 0),
                    !this._ts && !l)
                  )
                    return this;
                  Ne(this, g);
                }
              }
              if (
                (this._hasPause &&
                  !this._forcing &&
                  this._lock < 2 &&
                  ((c = (function (t, e, n) {
                    var i;
                    if (n > e)
                      for (i = t._first; i && i._start <= n; ) {
                        if ("isPause" === i.data && i._start > e) return i;
                        i = i._next;
                      }
                    else
                      for (i = t._last; i && i._start >= n; ) {
                        if ("isPause" === i.data && i._start < e) return i;
                        i = i._prev;
                      }
                  })(this, xt(v), xt(i))),
                  c && (x -= i - (i = c._start))),
                (this._tTime = x),
                (this._time = i),
                (this._act = !u),
                this._initted ||
                  ((this._onUpdate = this.vars.onUpdate),
                  (this._initted = 1),
                  (this._zTime = t),
                  (v = 0)),
                !v && i && !e && !o && (ge(this, "onStart"), this._tTime !== x))
              )
                return this;
              if (i >= v && t >= 0)
                for (r = this._first; r; ) {
                  if (
                    ((s = r._next),
                    (r._act || i >= r._start) && r._ts && c !== r)
                  ) {
                    if (r.parent !== this) return this.render(t, e, n);
                    if (
                      (r.render(
                        r._ts > 0
                          ? (i - r._start) * r._ts
                          : (r._dirty ? r.totalDuration() : r._tDur) +
                              (i - r._start) * r._ts,
                        e,
                        n
                      ),
                      i !== this._time || (!this._ts && !l))
                    ) {
                      (c = 0), s && (x += this._zTime = -1e-8);
                      break;
                    }
                  }
                  r = s;
                }
              else {
                r = this._last;
                for (var T = t < 0 ? t : i; r; ) {
                  if (
                    ((s = r._prev), (r._act || T <= r._end) && r._ts && c !== r)
                  ) {
                    if (r.parent !== this) return this.render(t, e, n);
                    if (
                      (r.render(
                        r._ts > 0
                          ? (T - r._start) * r._ts
                          : (r._dirty ? r.totalDuration() : r._tDur) +
                              (T - r._start) * r._ts,
                        e,
                        n || (h && (r._initted || r._startAt))
                      ),
                      i !== this._time || (!this._ts && !l))
                    ) {
                      (c = 0), s && (x += this._zTime = T ? -1e-8 : D);
                      break;
                    }
                  }
                  r = s;
                }
              }
              if (
                c &&
                !e &&
                (this.pause(),
                (c.render(i >= v ? 0 : -1e-8)._zTime = i >= v ? 1 : -1),
                this._ts)
              )
                return (this._start = d), Ht(this), this.render(t, e, n);
              this._onUpdate && !e && ge(this, "onUpdate", !0),
                ((x === _ && this._tTime >= this.totalDuration()) ||
                  (!x && v)) &&
                  ((d !== this._start && Math.abs(u) === Math.abs(this._ts)) ||
                    this._lock ||
                    ((t || !y) &&
                      ((x === _ && this._ts > 0) || (!x && this._ts < 0)) &&
                      It(this, 1),
                    e ||
                      (t < 0 && !v) ||
                      (!x && !v && _) ||
                      (ge(
                        this,
                        x === _ && t >= 0 ? "onComplete" : "onReverseComplete",
                        !0
                      ),
                      this._prom &&
                        !(x < _ && this.timeScale() > 0) &&
                        this._prom())));
            }
            return this;
          }),
          (n.add = function (t, e) {
            var n = this;
            if ((N(e) || (e = Jt(this, e, t)), !(t instanceof Ge))) {
              if (G(t))
                return (
                  t.forEach(function (t) {
                    return n.add(t, e);
                  }),
                  this
                );
              if (I(t)) return this.addLabel(t, e);
              if (!F(t)) return this;
              t = en.delayedCall(0, t);
            }
            return this !== t ? Wt(this, t, e) : this;
          }),
          (n.getChildren = function (t, e, n, i) {
            void 0 === t && (t = !0),
              void 0 === e && (e = !0),
              void 0 === n && (n = !0),
              void 0 === i && (i = -w);
            for (var r = [], s = this._first; s; )
              s._start >= i &&
                (s instanceof en
                  ? e && r.push(s)
                  : (n && r.push(s),
                    t && r.push.apply(r, s.getChildren(!0, e, n)))),
                (s = s._next);
            return r;
          }),
          (n.getById = function (t) {
            for (var e = this.getChildren(1, 1, 1), n = e.length; n--; )
              if (e[n].vars.id === t) return e[n];
          }),
          (n.remove = function (t) {
            return I(t)
              ? this.removeLabel(t)
              : F(t)
              ? this.killTweensOf(t)
              : (Ot(this, t),
                t === this._recent && (this._recent = this._last),
                Ft(this));
          }),
          (n.totalTime = function (e, n) {
            return arguments.length
              ? ((this._forcing = 1),
                !this._dp &&
                  this._ts &&
                  (this._start = xt(
                    Ce.time -
                      (this._ts > 0
                        ? e / this._ts
                        : (this.totalDuration() - e) / -this._ts)
                  )),
                t.prototype.totalTime.call(this, e, n),
                (this._forcing = 0),
                this)
              : this._tTime;
          }),
          (n.addLabel = function (t, e) {
            return (this.labels[t] = Jt(this, e)), this;
          }),
          (n.removeLabel = function (t) {
            return delete this.labels[t], this;
          }),
          (n.addPause = function (t, e, n) {
            var i = en.delayedCall(0, e || it, n);
            return (
              (i.data = "isPause"),
              (this._hasPause = 1),
              Wt(this, i, Jt(this, t))
            );
          }),
          (n.removePause = function (t) {
            var e = this._first;
            for (t = Jt(this, t); e; )
              e._start === t && "isPause" === e.data && It(e), (e = e._next);
          }),
          (n.killTweensOf = function (t, e, n) {
            for (var i = this.getTweensOf(t, n), r = i.length; r--; )
              je !== i[r] && i[r].kill(t, e);
            return this;
          }),
          (n.getTweensOf = function (t, e) {
            for (var n, i = [], r = se(t), s = this._first, o = N(e); s; )
              s instanceof en
                ? St(s._targets, r) &&
                  (o
                    ? (!je || (s._initted && s._ts)) &&
                      s.globalTime(0) <= e &&
                      s.globalTime(s.totalDuration()) > e
                    : !e || s.isActive()) &&
                  i.push(s)
                : (n = s.getTweensOf(r, e)).length && i.push.apply(i, n),
                (s = s._next);
            return i;
          }),
          (n.tweenTo = function (t, e) {
            e = e || {};
            var n,
              i = this,
              r = Jt(i, t),
              s = e,
              o = s.startAt,
              a = s.onStart,
              l = s.onStartParams,
              c = s.immediateRender,
              u = en.to(
                i,
                Dt(
                  {
                    ease: e.ease || "none",
                    lazy: !1,
                    immediateRender: !1,
                    time: r,
                    overwrite: "auto",
                    duration:
                      e.duration ||
                      Math.abs(
                        (r - (o && "time" in o ? o.time : i._time)) /
                          i.timeScale()
                      ) ||
                      D,
                    onStart: function () {
                      if ((i.pause(), !n)) {
                        var t =
                          e.duration ||
                          Math.abs(
                            (r - (o && "time" in o ? o.time : i._time)) /
                              i.timeScale()
                          );
                        u._dur !== t && Kt(u, t, 0, 1).render(u._time, !0, !0),
                          (n = 1);
                      }
                      a && a.apply(u, l || []);
                    },
                  },
                  e
                )
              );
            return c ? u.render(0) : u;
          }),
          (n.tweenFromTo = function (t, e, n) {
            return this.tweenTo(
              e,
              Dt(
                {
                  startAt: {
                    time: Jt(this, t),
                  },
                },
                n
              )
            );
          }),
          (n.recent = function () {
            return this._recent;
          }),
          (n.nextLabel = function (t) {
            return void 0 === t && (t = this._time), me(this, Jt(this, t));
          }),
          (n.previousLabel = function (t) {
            return void 0 === t && (t = this._time), me(this, Jt(this, t), 1);
          }),
          (n.currentLabel = function (t) {
            return arguments.length
              ? this.seek(t, !0)
              : this.previousLabel(this._time + D);
          }),
          (n.shiftChildren = function (t, e, n) {
            void 0 === n && (n = 0);
            for (var i, r = this._first, s = this.labels; r; )
              r._start >= n && ((r._start += t), (r._end += t)), (r = r._next);
            if (e) for (i in s) s[i] >= n && (s[i] += t);
            return Ft(this);
          }),
          (n.invalidate = function (e) {
            var n = this._first;
            for (this._lock = 0; n; ) n.invalidate(e), (n = n._next);
            return t.prototype.invalidate.call(this, e);
          }),
          (n.clear = function (t) {
            void 0 === t && (t = !0);
            for (var e, n = this._first; n; )
              (e = n._next), this.remove(n), (n = e);
            return (
              this._dp && (this._time = this._tTime = this._pTime = 0),
              t && (this.labels = {}),
              Ft(this)
            );
          }),
          (n.totalDuration = function (t) {
            var e,
              n,
              i,
              r = 0,
              s = this,
              o = s._last,
              a = w;
            if (arguments.length)
              return s.timeScale(
                (s._repeat < 0 ? s.duration() : s.totalDuration()) /
                  (s.reversed() ? -t : t)
              );
            if (s._dirty) {
              for (i = s.parent; o; )
                (e = o._prev),
                  o._dirty && o.totalDuration(),
                  (n = o._start) > a && s._sort && o._ts && !s._lock
                    ? ((s._lock = 1), (Wt(s, o, n - o._delay, 1)._lock = 0))
                    : (a = n),
                  n < 0 &&
                    o._ts &&
                    ((r -= n),
                    ((!i && !s._dp) || (i && i.smoothChildTiming)) &&
                      ((s._start += n / s._ts),
                      (s._time -= n),
                      (s._tTime -= n)),
                    s.shiftChildren(-n, !1, -Infinity),
                    (a = 0)),
                  o._end > r && o._ts && (r = o._end),
                  (o = e);
              Kt(s, s === p && s._time > r ? s._time : r, 1, 1), (s._dirty = 0);
            }
            return s._tDur;
          }),
          (e.updateRoot = function (t) {
            if ((p._ts && (Tt(p, Bt(t, p)), (_ = Ce.frame)), Ce.frame >= dt)) {
              dt += T.autoSleep || 120;
              var e = p._first;
              if ((!e || !e._ts) && T.autoSleep && Ce._listeners.length < 2) {
                for (; e && !e._ts; ) e = e._next;
                e || Ce.sleep();
              }
            }
          }),
          e
        );
      })(Ge);
      Dt(We.prototype, {
        _lock: 0,
        _hasPause: 0,
        _forcing: 0,
      });
      var je,
        Xe,
        qe = function (t, e, n, i, r, s, o) {
          var a,
            l,
            c,
            u,
            h,
            d,
            p,
            f,
            m = new gn(this._pt, t, e, 0, 1, un, null, r),
            g = 0,
            v = 0;
          for (
            m.b = n,
              m.e = i,
              n += "",
              (p = ~(i += "").indexOf("random(")) && (i = pe(i)),
              s && (s((f = [n, i]), t, e), (n = f[0]), (i = f[1])),
              l = n.match(q) || [];
            (a = q.exec(i));

          )
            (u = a[0]),
              (h = i.substring(g, a.index)),
              c ? (c = (c + 1) % 5) : "rgba(" === h.substr(-5) && (c = 1),
              u !== l[v++] &&
                ((d = parseFloat(l[v - 1]) || 0),
                (m._pt = {
                  _next: m._pt,
                  p: h || 1 === v ? h : ",",
                  s: d,
                  c: "=" === u.charAt(1) ? bt(d, u) - d : parseFloat(u) - d,
                  m: c && c < 4 ? Math.round : 0,
                }),
                (g = q.lastIndex));
          return (
            (m.c = g < i.length ? i.substring(g, i.length) : ""),
            (m.fp = o),
            (Y.test(i) || p) && (m.e = 0),
            (this._pt = m),
            m
          );
        },
        Ye = function (t, e, n, i, r, s, o, a, l, c) {
          F(i) && (i = i(r || 0, t, s));
          var u,
            h = t[e],
            d =
              "get" !== n
                ? n
                : F(h)
                ? l
                  ? t[
                      e.indexOf("set") || !F(t["get" + e.substr(3)])
                        ? e
                        : "get" + e.substr(3)
                    ](l)
                  : t[e]()
                : h,
            p = F(h) ? (l ? sn : rn) : nn;
          if (
            (I(i) &&
              (~i.indexOf("random(") && (i = pe(i)),
              "=" === i.charAt(1) &&
                ((u = bt(d, i) + (ne(d) || 0)) || 0 === u) &&
                (i = u)),
            !c || d !== i || Xe)
          )
            return isNaN(d * i) || "" === i
              ? (!h && !(e in t) && tt(e, i),
                qe.call(this, t, e, d, i, p, a || T.stringFilter, l))
              : ((u = new gn(
                  this._pt,
                  t,
                  e,
                  +d || 0,
                  i - (d || 0),
                  "boolean" == typeof h ? cn : ln,
                  0,
                  p
                )),
                l && (u.fp = l),
                o && u.modifier(o, this, t),
                (this._pt = u));
        },
        Ke = function (t, e, n, i, r, s) {
          var o, a, l, c;
          if (
            ut[t] &&
            !1 !==
              (o = new ut[t]()).init(
                r,
                o.rawVars
                  ? e[t]
                  : (function (t, e, n, i, r) {
                      if (
                        (F(t) && (t = Je(t, r, e, n, i)),
                        !k(t) || (t.style && t.nodeType) || G(t) || V(t))
                      )
                        return I(t) ? Je(t, r, e, n, i) : t;
                      var s,
                        o = {};
                      for (s in t) o[s] = Je(t[s], r, e, n, i);
                      return o;
                    })(e[t], i, r, s, n),
                n,
                i,
                s
              ) &&
            ((n._pt = a =
              new gn(n._pt, r, t, 0, 1, o.render, o, 0, o.priority)),
            n !== y)
          )
            for (
              l = n._ptLookup[n._targets.indexOf(r)], c = o._props.length;
              c--;

            )
              l[o._props[c]] = a;
          return o;
        },
        Ze = function t(e, n, i) {
          var r,
            s,
            o,
            a,
            l,
            c,
            d,
            f,
            m,
            g,
            v,
            _,
            y,
            x = e.vars,
            b = x.ease,
            S = x.startAt,
            E = x.immediateRender,
            T = x.lazy,
            A = x.onUpdate,
            C = x.onUpdateParams,
            P = x.callbackScope,
            R = x.runBackwards,
            L = x.yoyoEase,
            O = x.keyframes,
            I = x.autoRevert,
            F = e._dur,
            N = e._startAt,
            U = e._targets,
            k = e.parent,
            B = k && "nested" === k.data ? k.vars.targets : U,
            H = "auto" === e._overwrite && !u,
            V = e.timeline;
          if (
            (V && (!O || !b) && (b = "none"),
            (e._ease = Ue(b, M.ease)),
            (e._yEase = L ? Fe(Ue(!0 === L ? b : L, M.ease)) : 0),
            L &&
              e._yoyo &&
              !e._repeat &&
              ((L = e._yEase), (e._yEase = e._ease), (e._ease = L)),
            (e._from = !V && !!x.runBackwards),
            !V || (O && !x.stagger))
          ) {
            if (
              ((_ = (f = U[0] ? gt(U[0]).harness : 0) && x[f.prop]),
              (r = Pt(x, at)),
              N &&
                (N._zTime < 0 && N.progress(1),
                n < 0 && R && E && !I
                  ? N.render(-1, !0)
                  : N.revert(R && F ? st : rt),
                (N._lazy = 0)),
              S)
            ) {
              if (
                (It(
                  (e._startAt = en.set(
                    U,
                    Dt(
                      {
                        data: "isStart",
                        overwrite: !1,
                        parent: k,
                        immediateRender: !0,
                        lazy: !N && z(T),
                        startAt: null,
                        delay: 0,
                        onUpdate: A,
                        onUpdateParams: C,
                        callbackScope: P,
                        stagger: 0,
                      },
                      S
                    )
                  ))
                ),
                (e._startAt._dp = 0),
                (e._startAt._sat = e),
                n < 0 && (h || (!E && !I)) && e._startAt.revert(st),
                E && F && n <= 0 && i <= 0)
              )
                return void (n && (e._zTime = n));
            } else if (R && F && !N)
              if (
                (n && (E = !1),
                (o = Dt(
                  {
                    overwrite: !1,
                    data: "isFromStart",
                    lazy: E && !N && z(T),
                    immediateRender: E,
                    stagger: 0,
                    parent: k,
                  },
                  r
                )),
                _ && (o[f.prop] = _),
                It((e._startAt = en.set(U, o))),
                (e._startAt._dp = 0),
                (e._startAt._sat = e),
                n < 0 &&
                  (h ? e._startAt.revert(st) : e._startAt.render(-1, !0)),
                (e._zTime = n),
                E)
              ) {
                if (!n) return;
              } else t(e._startAt, D, D);
            for (
              e._pt = e._ptCache = 0, T = (F && z(T)) || (T && !F), s = 0;
              s < U.length;
              s++
            ) {
              if (
                ((d = (l = U[s])._gsap || mt(U)[s]._gsap),
                (e._ptLookup[s] = g = {}),
                ct[d.id] && lt.length && Et(),
                (v = B === U ? s : B.indexOf(l)),
                f &&
                  !1 !== (m = new f()).init(l, _ || r, e, v, B) &&
                  ((e._pt = a =
                    new gn(e._pt, l, m.name, 0, 1, m.render, m, 0, m.priority)),
                  m._props.forEach(function (t) {
                    g[t] = a;
                  }),
                  m.priority && (c = 1)),
                !f || _)
              )
                for (o in r)
                  ut[o] && (m = Ke(o, r, e, v, l, B))
                    ? m.priority && (c = 1)
                    : (g[o] = a =
                        Ye.call(e, l, o, "get", r[o], v, B, 0, x.stringFilter));
              e._op && e._op[s] && e.kill(l, e._op[s]),
                H &&
                  e._pt &&
                  ((je = e),
                  p.killTweensOf(l, g, e.globalTime(n)),
                  (y = !e.parent),
                  (je = 0)),
                e._pt && T && (ct[d.id] = 1);
            }
            c && mn(e), e._onInit && e._onInit(e);
          }
          (e._onUpdate = A),
            (e._initted = (!e._op || e._pt) && !y),
            O && n <= 0 && V.render(w, !0, !0);
        },
        $e = function (t, e, n, i) {
          var r,
            s,
            o = e.ease || i || "power1.inOut";
          if (G(e))
            (s = n[t] || (n[t] = [])),
              e.forEach(function (t, n) {
                return s.push({
                  t: (n / (e.length - 1)) * 100,
                  v: t,
                  e: o,
                });
              });
          else
            for (r in e)
              (s = n[r] || (n[r] = [])),
                "ease" === r ||
                  s.push({
                    t: parseFloat(t),
                    v: e[r],
                    e: o,
                  });
        },
        Je = function (t, e, n, i, r) {
          return F(t)
            ? t.call(e, n, i, r)
            : I(t) && ~t.indexOf("random(")
            ? pe(t)
            : t;
        },
        Qe = ft + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
        tn = {};
      _t(Qe + ",id,stagger,delay,duration,paused,scrollTrigger", function (t) {
        return (tn[t] = 1);
      });
      var en = (function (t) {
        function e(e, n, i, r) {
          var s;
          "number" == typeof n && ((i.duration = n), (n = i), (i = null));
          var o,
            a,
            c,
            h,
            d,
            f,
            m,
            g,
            v = (s = t.call(this, r ? n : Rt(n)) || this).vars,
            _ = v.duration,
            y = v.delay,
            x = v.immediateRender,
            b = v.stagger,
            S = v.overwrite,
            E = v.keyframes,
            M = v.defaults,
            w = v.scrollTrigger,
            D = v.yoyoEase,
            A = n.parent || p,
            C = (G(e) || V(e) ? N(e[0]) : "length" in n) ? [e] : se(e);
          if (
            ((s._targets = C.length
              ? mt(C)
              : et(
                  "GSAP target " + e + " not found. https://greensock.com",
                  !T.nullTargetWarn
                ) || []),
            (s._ptLookup = []),
            (s._overwrite = S),
            E || b || H(_) || H(y))
          ) {
            if (
              ((n = s.vars),
              (o = s.timeline =
                new We({
                  data: "nested",
                  defaults: M || {},
                  targets: A && "nested" === A.data ? A.vars.targets : C,
                })).kill(),
              (o.parent = o._dp = l(s)),
              (o._start = 0),
              b || H(_) || H(y))
            ) {
              if (((h = C.length), (m = b && le(b)), k(b)))
                for (d in b) ~Qe.indexOf(d) && (g || (g = {}), (g[d] = b[d]));
              for (a = 0; a < h; a++)
                ((c = Pt(n, tn)).stagger = 0),
                  D && (c.yoyoEase = D),
                  g && At(c, g),
                  (f = C[a]),
                  (c.duration = +Je(_, l(s), a, f, C)),
                  (c.delay = (+Je(y, l(s), a, f, C) || 0) - s._delay),
                  !b &&
                    1 === h &&
                    c.delay &&
                    ((s._delay = y = c.delay), (s._start += y), (c.delay = 0)),
                  o.to(f, c, m ? m(a, f, C) : 0),
                  (o._ease = Re.none);
              o.duration() ? (_ = y = 0) : (s.timeline = 0);
            } else if (E) {
              Rt(
                Dt(o.vars.defaults, {
                  ease: "none",
                })
              ),
                (o._ease = Ue(E.ease || n.ease || "none"));
              var P,
                R,
                L,
                O = 0;
              if (G(E))
                E.forEach(function (t) {
                  return o.to(C, t, ">");
                }),
                  o.duration();
              else {
                for (d in ((c = {}), E))
                  "ease" === d ||
                    "easeEach" === d ||
                    $e(d, E[d], c, E.easeEach);
                for (d in c)
                  for (
                    P = c[d].sort(function (t, e) {
                      return t.t - e.t;
                    }),
                      O = 0,
                      a = 0;
                    a < P.length;
                    a++
                  )
                    ((L = {
                      ease: (R = P[a]).e,
                      duration: ((R.t - (a ? P[a - 1].t : 0)) / 100) * _,
                    })[d] = R.v),
                      o.to(C, L, O),
                      (O += L.duration);
                o.duration() < _ &&
                  o.to(
                    {},
                    {
                      duration: _ - o.duration(),
                    }
                  );
              }
            }
            _ || s.duration((_ = o.duration()));
          } else s.timeline = 0;
          return (
            !0 !== S || u || ((je = l(s)), p.killTweensOf(C), (je = 0)),
            Wt(A, l(s), i),
            n.reversed && s.reverse(),
            n.paused && s.paused(!0),
            (x ||
              (!_ &&
                !E &&
                s._start === xt(A._time) &&
                z(x) &&
                Ut(l(s)) &&
                "nested" !== A.data)) &&
              ((s._tTime = -1e-8), s.render(Math.max(0, -y) || 0)),
            w && jt(l(s), w),
            s
          );
        }
        c(e, t);
        var n = e.prototype;
        return (
          (n.render = function (t, e, n) {
            var i,
              r,
              s,
              o,
              a,
              l,
              c,
              u,
              d,
              p = this._time,
              f = this._tDur,
              m = this._dur,
              g = t < 0,
              v = t > f - D && !g ? f : t < D ? 0 : t;
            if (m) {
              if (
                v !== this._tTime ||
                !t ||
                n ||
                (!this._initted && this._tTime) ||
                (this._startAt && this._zTime < 0 !== g)
              ) {
                if (((i = v), (u = this.timeline), this._repeat)) {
                  if (((o = m + this._rDelay), this._repeat < -1 && g))
                    return this.totalTime(100 * o + t, e, n);
                  if (
                    ((i = xt(v % o)),
                    v === f
                      ? ((s = this._repeat), (i = m))
                      : ((s = ~~(v / o)) && s === v / o && ((i = m), s--),
                        i > m && (i = m)),
                    (l = this._yoyo && 1 & s) &&
                      ((d = this._yEase), (i = m - i)),
                    (a = zt(this._tTime, o)),
                    i === p && !n && this._initted)
                  )
                    return (this._tTime = v), this;
                  s !== a &&
                    (u && this._yEase && Ne(u, l),
                    !this.vars.repeatRefresh ||
                      l ||
                      this._lock ||
                      ((this._lock = n = 1),
                      (this.render(xt(o * s), !0).invalidate()._lock = 0)));
                }
                if (!this._initted) {
                  if (Xt(this, g ? t : i, n, e, v))
                    return (this._tTime = 0), this;
                  if (p !== this._time) return this;
                  if (m !== this._dur) return this.render(t, e, n);
                }
                if (
                  ((this._tTime = v),
                  (this._time = i),
                  !this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
                  (this.ratio = c = (d || this._ease)(i / m)),
                  this._from && (this.ratio = c = 1 - c),
                  i &&
                    !p &&
                    !e &&
                    !s &&
                    (ge(this, "onStart"), this._tTime !== v))
                )
                  return this;
                for (r = this._pt; r; ) r.r(c, r.d), (r = r._next);
                (u &&
                  u.render(
                    t < 0
                      ? t
                      : !i && l
                      ? -1e-8
                      : u._dur * u._ease(i / this._dur),
                    e,
                    n
                  )) ||
                  (this._startAt && (this._zTime = t)),
                  this._onUpdate &&
                    !e &&
                    (g && Nt(this, t, 0, n), ge(this, "onUpdate")),
                  this._repeat &&
                    s !== a &&
                    this.vars.onRepeat &&
                    !e &&
                    this.parent &&
                    ge(this, "onRepeat"),
                  (v !== this._tDur && v) ||
                    this._tTime !== v ||
                    (g && !this._onUpdate && Nt(this, t, 0, !0),
                    (t || !m) &&
                      ((v === this._tDur && this._ts > 0) ||
                        (!v && this._ts < 0)) &&
                      It(this, 1),
                    e ||
                      (g && !p) ||
                      !(v || p || l) ||
                      (ge(
                        this,
                        v === f ? "onComplete" : "onReverseComplete",
                        !0
                      ),
                      this._prom &&
                        !(v < f && this.timeScale() > 0) &&
                        this._prom()));
              }
            } else
              !(function (t, e, n, i) {
                var r,
                  s,
                  o,
                  a = t.ratio,
                  l =
                    e < 0 ||
                    (!e &&
                      ((!t._start && qt(t) && (t._initted || !Yt(t))) ||
                        ((t._ts < 0 || t._dp._ts < 0) && !Yt(t))))
                      ? 0
                      : 1,
                  c = t._rDelay,
                  u = 0;
                if (
                  (c &&
                    t._repeat &&
                    ((u = ee(0, t._tDur, e)),
                    (s = zt(u, c)),
                    t._yoyo && 1 & s && (l = 1 - l),
                    s !== zt(t._tTime, c) &&
                      ((a = 1 - l),
                      t.vars.repeatRefresh && t._initted && t.invalidate())),
                  l !== a || h || i || t._zTime === D || (!e && t._zTime))
                ) {
                  if (!t._initted && Xt(t, e, i, n, u)) return;
                  for (
                    o = t._zTime,
                      t._zTime = e || (n ? D : 0),
                      n || (n = e && !o),
                      t.ratio = l,
                      t._from && (l = 1 - l),
                      t._time = 0,
                      t._tTime = u,
                      r = t._pt;
                    r;

                  )
                    r.r(l, r.d), (r = r._next);
                  e < 0 && Nt(t, e, 0, !0),
                    t._onUpdate && !n && ge(t, "onUpdate"),
                    u && t._repeat && !n && t.parent && ge(t, "onRepeat"),
                    (e >= t._tDur || e < 0) &&
                      t.ratio === l &&
                      (l && It(t, 1),
                      n ||
                        h ||
                        (ge(t, l ? "onComplete" : "onReverseComplete", !0),
                        t._prom && t._prom()));
                } else t._zTime || (t._zTime = e);
              })(this, t, e, n);
            return this;
          }),
          (n.targets = function () {
            return this._targets;
          }),
          (n.invalidate = function (e) {
            return (
              (!e || !this.vars.runBackwards) && (this._startAt = 0),
              (this._pt =
                this._op =
                this._onUpdate =
                this._lazy =
                this.ratio =
                  0),
              (this._ptLookup = []),
              this.timeline && this.timeline.invalidate(e),
              t.prototype.invalidate.call(this, e)
            );
          }),
          (n.resetTo = function (t, e, n, i) {
            x || Ce.wake(), this._ts || this.play();
            var r = Math.min(
              this._dur,
              (this._dp._time - this._start) * this._ts
            );
            return (
              this._initted || Ze(this, r),
              (function (t, e, n, i, r, s, o) {
                var a,
                  l,
                  c,
                  u,
                  h = ((t._pt && t._ptCache) || (t._ptCache = {}))[e];
                if (!h)
                  for (
                    h = t._ptCache[e] = [],
                      c = t._ptLookup,
                      u = t._targets.length;
                    u--;

                  ) {
                    if ((a = c[u][e]) && a.d && a.d._pt)
                      for (a = a.d._pt; a && a.p !== e && a.fp !== e; )
                        a = a._next;
                    if (!a)
                      return (
                        (Xe = 1), (t.vars[e] = "+=0"), Ze(t, o), (Xe = 0), 1
                      );
                    h.push(a);
                  }
                for (u = h.length; u--; )
                  ((a = (l = h[u])._pt || l).s =
                    (!i && 0 !== i) || r ? a.s + (i || 0) + s * a.c : i),
                    (a.c = n - a.s),
                    l.e && (l.e = yt(n) + ne(l.e)),
                    l.b && (l.b = a.s + ne(l.b));
              })(this, t, e, n, i, this._ease(r / this._dur), r)
                ? this.resetTo(t, e, n, i)
                : (Vt(this, 0),
                  this.parent ||
                    Lt(
                      this._dp,
                      this,
                      "_first",
                      "_last",
                      this._dp._sort ? "_start" : 0
                    ),
                  this.render(0))
            );
          }),
          (n.kill = function (t, e) {
            if ((void 0 === e && (e = "all"), !(t || (e && "all" !== e))))
              return (this._lazy = this._pt = 0), this.parent ? ve(this) : this;
            if (this.timeline) {
              var n = this.timeline.totalDuration();
              return (
                this.timeline.killTweensOf(t, e, je && !0 !== je.vars.overwrite)
                  ._first || ve(this),
                this.parent &&
                  n !== this.timeline.totalDuration() &&
                  Kt(this, (this._dur * this.timeline._tDur) / n, 0, 1),
                this
              );
            }
            var i,
              r,
              s,
              o,
              a,
              l,
              c,
              u = this._targets,
              h = t ? se(t) : u,
              d = this._ptLookup,
              p = this._pt;
            if (
              (!e || "all" === e) &&
              (function (t, e) {
                for (
                  var n = t.length, i = n === e.length;
                  i && n-- && t[n] === e[n];

                );
                return n < 0;
              })(u, h)
            )
              return "all" === e && (this._pt = 0), ve(this);
            for (
              i = this._op = this._op || [],
                "all" !== e &&
                  (I(e) &&
                    ((a = {}),
                    _t(e, function (t) {
                      return (a[t] = 1);
                    }),
                    (e = a)),
                  (e = (function (t, e) {
                    var n,
                      i,
                      r,
                      s,
                      o = t[0] ? gt(t[0]).harness : 0,
                      a = o && o.aliases;
                    if (!a) return e;
                    for (i in ((n = At({}, e)), a))
                      if ((i in n))
                        for (r = (s = a[i].split(",")).length; r--; )
                          n[s[r]] = n[i];
                    return n;
                  })(u, e))),
                c = u.length;
              c--;

            )
              if (~h.indexOf(u[c]))
                for (a in ((r = d[c]),
                "all" === e
                  ? ((i[c] = e), (o = r), (s = {}))
                  : ((s = i[c] = i[c] || {}), (o = e)),
                o))
                  (l = r && r[a]) &&
                    (("kill" in l.d && !0 !== l.d.kill(a)) ||
                      Ot(this, l, "_pt"),
                    delete r[a]),
                    "all" !== s && (s[a] = 1);
            return this._initted && !this._pt && p && ve(this), this;
          }),
          (e.to = function (t, n) {
            return new e(t, n, arguments[2]);
          }),
          (e.from = function (t, e) {
            return Qt(1, arguments);
          }),
          (e.delayedCall = function (t, n, i, r) {
            return new e(n, 0, {
              immediateRender: !1,
              lazy: !1,
              overwrite: !1,
              delay: t,
              onComplete: n,
              onReverseComplete: n,
              onCompleteParams: i,
              onReverseCompleteParams: i,
              callbackScope: r,
            });
          }),
          (e.fromTo = function (t, e, n) {
            return Qt(2, arguments);
          }),
          (e.set = function (t, n) {
            return (
              (n.duration = 0), n.repeatDelay || (n.repeat = 0), new e(t, n)
            );
          }),
          (e.killTweensOf = function (t, e, n) {
            return p.killTweensOf(t, e, n);
          }),
          e
        );
      })(Ge);
      Dt(en.prototype, {
        _targets: [],
        _lazy: 0,
        _startAt: 0,
        _op: 0,
        _onInit: 0,
      }),
        _t("staggerTo,staggerFrom,staggerFromTo", function (t) {
          en[t] = function () {
            var e = new We(),
              n = ie.call(arguments, 0);
            return (
              n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n)
            );
          };
        });
      var nn = function (t, e, n) {
          return (t[e] = n);
        },
        rn = function (t, e, n) {
          return t[e](n);
        },
        sn = function (t, e, n, i) {
          return t[e](i.fp, n);
        },
        on = function (t, e, n) {
          return t.setAttribute(e, n);
        },
        an = function (t, e) {
          return F(t[e]) ? rn : U(t[e]) && t.setAttribute ? on : nn;
        },
        ln = function (t, e) {
          return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e);
        },
        cn = function (t, e) {
          return e.set(e.t, e.p, !!(e.s + e.c * t), e);
        },
        un = function (t, e) {
          var n = e._pt,
            i = "";
          if (!t && e.b) i = e.b;
          else if (1 === t && e.e) i = e.e;
          else {
            for (; n; )
              (i =
                n.p +
                (n.m
                  ? n.m(n.s + n.c * t)
                  : Math.round(1e4 * (n.s + n.c * t)) / 1e4) +
                i),
                (n = n._next);
            i += e.c;
          }
          e.set(e.t, e.p, i, e);
        },
        hn = function (t, e) {
          for (var n = e._pt; n; ) n.r(t, n.d), (n = n._next);
        },
        dn = function (t, e, n, i) {
          for (var r, s = this._pt; s; )
            (r = s._next), s.p === i && s.modifier(t, e, n), (s = r);
        },
        pn = function (t) {
          for (var e, n, i = this._pt; i; )
            (n = i._next),
              (i.p === t && !i.op) || i.op === t
                ? Ot(this, i, "_pt")
                : i.dep || (e = 1),
              (i = n);
          return !e;
        },
        fn = function (t, e, n, i) {
          i.mSet(t, e, i.m.call(i.tween, n, i.mt), i);
        },
        mn = function (t) {
          for (var e, n, i, r, s = t._pt; s; ) {
            for (e = s._next, n = i; n && n.pr > s.pr; ) n = n._next;
            (s._prev = n ? n._prev : r) ? (s._prev._next = s) : (i = s),
              (s._next = n) ? (n._prev = s) : (r = s),
              (s = e);
          }
          t._pt = i;
        },
        gn = (function () {
          function t(t, e, n, i, r, s, o, a, l) {
            (this.t = e),
              (this.s = i),
              (this.c = r),
              (this.p = n),
              (this.r = s || ln),
              (this.d = o || this),
              (this.set = a || nn),
              (this.pr = l || 0),
              (this._next = t),
              t && (t._prev = this);
          }
          return (
            (t.prototype.modifier = function (t, e, n) {
              (this.mSet = this.mSet || this.set),
                (this.set = fn),
                (this.m = t),
                (this.mt = n),
                (this.tween = e);
            }),
            t
          );
        })();
      _t(
        ft +
          "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
        function (t) {
          return (at[t] = 1);
        }
      ),
        ($.TweenMax = $.TweenLite = en),
        ($.TimelineLite = $.TimelineMax = We),
        (p = new We({
          sortChildren: !1,
          defaults: M,
          autoRemoveChildren: !0,
          id: "root",
          smoothChildTiming: !0,
        })),
        (T.stringFilter = Ae);
      var vn = [],
        _n = {},
        yn = [],
        xn = 0,
        bn = 0,
        Sn = function (t) {
          return (_n[t] || yn).map(function (t) {
            return t();
          });
        },
        En = function () {
          var t = Date.now(),
            e = [];
          t - xn > 2 &&
            (Sn("matchMediaInit"),
            vn.forEach(function (t) {
              var n,
                i,
                r,
                s,
                o = t.queries,
                a = t.conditions;
              for (i in o)
                (n = f.matchMedia(o[i]).matches) && (r = 1),
                  n !== a[i] && ((a[i] = n), (s = 1));
              s && (t.revert(), r && e.push(t));
            }),
            Sn("matchMediaRevert"),
            e.forEach(function (t) {
              return t.onMatch(t);
            }),
            (xn = t),
            Sn("matchMedia"));
        },
        Tn = (function () {
          function t(t, e) {
            (this.selector = e && oe(e)),
              (this.data = []),
              (this._r = []),
              (this.isReverted = !1),
              (this.id = bn++),
              t && this.add(t);
          }
          var e = t.prototype;
          return (
            (e.add = function (t, e, n) {
              F(t) && ((n = e), (e = t), (t = F));
              var i = this,
                r = function () {
                  var t,
                    r = d,
                    s = i.selector;
                  return (
                    r && r !== i && r.data.push(i),
                    n && (i.selector = oe(n)),
                    (d = i),
                    (t = e.apply(i, arguments)),
                    F(t) && i._r.push(t),
                    (d = r),
                    (i.selector = s),
                    (i.isReverted = !1),
                    t
                  );
                };
              return (i.last = r), t === F ? r(i) : t ? (i[t] = r) : r;
            }),
            (e.ignore = function (t) {
              var e = d;
              (d = null), t(this), (d = e);
            }),
            (e.getTweens = function () {
              var e = [];
              return (
                this.data.forEach(function (n) {
                  return n instanceof t
                    ? e.push.apply(e, n.getTweens())
                    : n instanceof en &&
                        !(n.parent && "nested" === n.parent.data) &&
                        e.push(n);
                }),
                e
              );
            }),
            (e.clear = function () {
              this._r.length = this.data.length = 0;
            }),
            (e.kill = function (t, e) {
              var n = this;
              if (t) {
                var i = this.getTweens();
                this.data.forEach(function (t) {
                  "isFlip" === t.data &&
                    (t.revert(),
                    t.getChildren(!0, !0, !1).forEach(function (t) {
                      return i.splice(i.indexOf(t), 1);
                    }));
                }),
                  i
                    .map(function (t) {
                      return {
                        g: t.globalTime(0),
                        t: t,
                      };
                    })
                    .sort(function (t, e) {
                      return e.g - t.g || -1 / 0;
                    })
                    .forEach(function (e) {
                      return e.t.revert(t);
                    }),
                  this.data.forEach(function (e) {
                    return !(e instanceof en) && e.revert && e.revert(t);
                  }),
                  this._r.forEach(function (e) {
                    return e(t, n);
                  }),
                  (this.isReverted = !0);
              } else
                this.data.forEach(function (t) {
                  return t.kill && t.kill();
                });
              if ((this.clear(), e))
                for (var r = vn.length; r--; )
                  vn[r].id === this.id && vn.splice(r, 1);
            }),
            (e.revert = function (t) {
              this.kill(t || {});
            }),
            t
          );
        })(),
        Mn = (function () {
          function t(t) {
            (this.contexts = []), (this.scope = t);
          }
          var e = t.prototype;
          return (
            (e.add = function (t, e, n) {
              k(t) ||
                (t = {
                  matches: t,
                });
              var i,
                r,
                s,
                o = new Tn(0, n || this.scope),
                a = (o.conditions = {});
              for (r in (d && !o.selector && (o.selector = d.selector),
              this.contexts.push(o),
              (e = o.add("onMatch", e)),
              (o.queries = t),
              t))
                "all" === r
                  ? (s = 1)
                  : (i = f.matchMedia(t[r])) &&
                    (vn.indexOf(o) < 0 && vn.push(o),
                    (a[r] = i.matches) && (s = 1),
                    i.addListener
                      ? i.addListener(En)
                      : i.addEventListener("change", En));
              return s && e(o), this;
            }),
            (e.revert = function (t) {
              this.kill(t || {});
            }),
            (e.kill = function (t) {
              this.contexts.forEach(function (e) {
                return e.kill(t, !0);
              });
            }),
            t
          );
        })(),
        wn = {
          registerPlugin: function () {
            for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
              e[n] = arguments[n];
            e.forEach(function (t) {
              return ye(t);
            });
          },
          timeline: function (t) {
            return new We(t);
          },
          getTweensOf: function (t, e) {
            return p.getTweensOf(t, e);
          },
          getProperty: function (t, e, n, i) {
            I(t) && (t = se(t)[0]);
            var r = gt(t || {}).get,
              s = n ? wt : Mt;
            return (
              "native" === n && (n = ""),
              t
                ? e
                  ? s(((ut[e] && ut[e].get) || r)(t, e, n, i))
                  : function (e, n, i) {
                      return s(((ut[e] && ut[e].get) || r)(t, e, n, i));
                    }
                : t
            );
          },
          quickSetter: function (t, e, n) {
            if ((t = se(t)).length > 1) {
              var i = t.map(function (t) {
                  return Cn.quickSetter(t, e, n);
                }),
                r = i.length;
              return function (t) {
                for (var e = r; e--; ) i[e](t);
              };
            }
            t = t[0] || {};
            var s = ut[e],
              o = gt(t),
              a = (o.harness && (o.harness.aliases || {})[e]) || e,
              l = s
                ? function (e) {
                    var i = new s();
                    (y._pt = 0),
                      i.init(t, n ? e + n : e, y, 0, [t]),
                      i.render(1, i),
                      y._pt && hn(1, y);
                  }
                : o.set(t, a);
            return s
              ? l
              : function (e) {
                  return l(t, a, n ? e + n : e, o, 1);
                };
          },
          quickTo: function (t, e, n) {
            var i,
              r = Cn.to(
                t,
                At((((i = {})[e] = "+=0.1"), (i.paused = !0), i), n || {})
              ),
              s = function (t, n, i) {
                return r.resetTo(e, t, n, i);
              };
            return (s.tween = r), s;
          },
          isTweening: function (t) {
            return p.getTweensOf(t, !0).length > 0;
          },
          defaults: function (t) {
            return t && t.ease && (t.ease = Ue(t.ease, M.ease)), Ct(M, t || {});
          },
          config: function (t) {
            return Ct(T, t || {});
          },
          registerEffect: function (t) {
            var e = t.name,
              n = t.effect,
              i = t.plugins,
              r = t.defaults,
              s = t.extendTimeline;
            (i || "").split(",").forEach(function (t) {
              return (
                t &&
                !ut[t] &&
                !$[t] &&
                et(e + " effect requires " + t + " plugin.")
              );
            }),
              (ht[e] = function (t, e, i) {
                return n(se(t), Dt(e || {}, r), i);
              }),
              s &&
                (We.prototype[e] = function (t, n, i) {
                  return this.add(ht[e](t, k(n) ? n : (i = n) && {}, this), i);
                });
          },
          registerEase: function (t, e) {
            Re[t] = Ue(e);
          },
          parseEase: function (t, e) {
            return arguments.length ? Ue(t, e) : Re;
          },
          getById: function (t) {
            return p.getById(t);
          },
          exportRoot: function (t, e) {
            void 0 === t && (t = {});
            var n,
              i,
              r = new We(t);
            for (
              r.smoothChildTiming = z(t.smoothChildTiming),
                p.remove(r),
                r._dp = 0,
                r._time = r._tTime = p._time,
                n = p._first;
              n;

            )
              (i = n._next),
                (!e &&
                  !n._dur &&
                  n instanceof en &&
                  n.vars.onComplete === n._targets[0]) ||
                  Wt(r, n, n._start - n._delay),
                (n = i);
            return Wt(p, r, 0), r;
          },
          context: function (t, e) {
            return t ? new Tn(t, e) : d;
          },
          matchMedia: function (t) {
            return new Mn(t);
          },
          matchMediaRefresh: function () {
            return (
              vn.forEach(function (t) {
                var e,
                  n,
                  i = t.conditions;
                for (n in i) i[n] && ((i[n] = !1), (e = 1));
                e && t.revert();
              }) || En()
            );
          },
          addEventListener: function (t, e) {
            var n = _n[t] || (_n[t] = []);
            ~n.indexOf(e) || n.push(e);
          },
          removeEventListener: function (t, e) {
            var n = _n[t],
              i = n && n.indexOf(e);
            i >= 0 && n.splice(i, 1);
          },
          utils: {
            wrap: function t(e, n, i) {
              var r = n - e;
              return G(e)
                ? de(e, t(0, e.length), n)
                : te(i, function (t) {
                    return ((r + ((t - e) % r)) % r) + e;
                  });
            },
            wrapYoyo: function t(e, n, i) {
              var r = n - e,
                s = 2 * r;
              return G(e)
                ? de(e, t(0, e.length - 1), n)
                : te(i, function (t) {
                    return (
                      e + ((t = (s + ((t - e) % s)) % s || 0) > r ? s - t : t)
                    );
                  });
            },
            distribute: le,
            random: he,
            snap: ue,
            normalize: function (t, e, n) {
              return fe(t, e, 0, 1, n);
            },
            getUnit: ne,
            clamp: function (t, e, n) {
              return te(n, function (n) {
                return ee(t, e, n);
              });
            },
            splitColor: Ee,
            toArray: se,
            selector: oe,
            mapRange: fe,
            pipe: function () {
              for (
                var t = arguments.length, e = new Array(t), n = 0;
                n < t;
                n++
              )
                e[n] = arguments[n];
              return function (t) {
                return e.reduce(function (t, e) {
                  return e(t);
                }, t);
              };
            },
            unitize: function (t, e) {
              return function (n) {
                return t(parseFloat(n)) + (e || ne(n));
              };
            },
            interpolate: function t(e, n, i, r) {
              var s = isNaN(e + n)
                ? 0
                : function (t) {
                    return (1 - t) * e + t * n;
                  };
              if (!s) {
                var o,
                  a,
                  l,
                  c,
                  u,
                  h = I(e),
                  d = {};
                if ((!0 === i && (r = 1) && (i = null), h))
                  (e = {
                    p: e,
                  }),
                    (n = {
                      p: n,
                    });
                else if (G(e) && !G(n)) {
                  for (l = [], c = e.length, u = c - 2, a = 1; a < c; a++)
                    l.push(t(e[a - 1], e[a]));
                  c--,
                    (s = function (t) {
                      t *= c;
                      var e = Math.min(u, ~~t);
                      return l[e](t - e);
                    }),
                    (i = n);
                } else r || (e = At(G(e) ? [] : {}, e));
                if (!l) {
                  for (o in n) Ye.call(d, e, o, "get", n[o]);
                  s = function (t) {
                    return hn(t, d) || (h ? e.p : e);
                  };
                }
              }
              return te(i, s);
            },
            shuffle: ae,
          },
          install: Q,
          effects: ht,
          ticker: Ce,
          updateRoot: We.updateRoot,
          plugins: ut,
          globalTimeline: p,
          core: {
            PropTween: gn,
            globals: nt,
            Tween: en,
            Timeline: We,
            Animation: Ge,
            getCache: gt,
            _removeLinkedListItem: Ot,
            reverting: function () {
              return h;
            },
            context: function (t) {
              return t && d && (d.data.push(t), (t._ctx = d)), d;
            },
            suppressOverwrites: function (t) {
              return (u = t);
            },
          },
        };
      _t("to,from,fromTo,delayedCall,set,killTweensOf", function (t) {
        return (wn[t] = en[t]);
      }),
        Ce.add(We.updateRoot),
        (y = wn.to(
          {},
          {
            duration: 0,
          }
        ));
      var Dn = function (t, e) {
          for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e; )
            n = n._next;
          return n;
        },
        An = function (t, e) {
          return {
            name: t,
            rawVars: 1,
            init: function (t, n, i) {
              i._onInit = function (t) {
                var i, r;
                if (
                  (I(n) &&
                    ((i = {}),
                    _t(n, function (t) {
                      return (i[t] = 1);
                    }),
                    (n = i)),
                  e)
                ) {
                  for (r in ((i = {}), n)) i[r] = e(n[r]);
                  n = i;
                }
                !(function (t, e) {
                  var n,
                    i,
                    r,
                    s = t._targets;
                  for (n in e)
                    for (i = s.length; i--; )
                      (r = t._ptLookup[i][n]) &&
                        (r = r.d) &&
                        (r._pt && (r = Dn(r, n)),
                        r && r.modifier && r.modifier(e[n], t, s[i], n));
                })(t, n);
              };
            },
          };
        },
        Cn =
          wn.registerPlugin(
            {
              name: "attr",
              init: function (t, e, n, i, r) {
                var s, o, a;
                for (s in ((this.tween = n), e))
                  (a = t.getAttribute(s) || ""),
                    ((o = this.add(
                      t,
                      "setAttribute",
                      (a || 0) + "",
                      e[s],
                      i,
                      r,
                      0,
                      0,
                      s
                    )).op = s),
                    (o.b = a),
                    this._props.push(s);
              },
              render: function (t, e) {
                for (var n = e._pt; n; )
                  h ? n.set(n.t, n.p, n.b, n) : n.r(t, n.d), (n = n._next);
              },
            },
            {
              name: "endArray",
              init: function (t, e) {
                for (var n = e.length; n--; )
                  this.add(t, n, t[n] || 0, e[n], 0, 0, 0, 0, 0, 1);
              },
            },
            An("roundProps", ce),
            An("modifiers"),
            An("snap", ue)
          ) || wn;
      (en.version = We.version = Cn.version = "3.12.2"),
        (v = 1),
        B() && Pe(),
        Re.Power0,
        Re.Power1,
        Re.Power2,
        Re.Power3,
        Re.Power4,
        Re.Linear,
        Re.Quad,
        Re.Cubic,
        Re.Quart,
        Re.Quint,
        Re.Strong,
        Re.Elastic,
        Re.Back,
        Re.SteppedEase,
        Re.Bounce,
        Re.Sine,
        Re.Expo,
        Re.Circ;
      var Pn,
        Rn,
        Ln,
        On,
        In,
        Fn,
        Nn,
        Un,
        kn = {},
        zn = 180 / Math.PI,
        Bn = Math.PI / 180,
        Hn = Math.atan2,
        Vn = /([A-Z])/g,
        Gn = /(left|right|width|margin|padding|x)/i,
        Wn = /[\s,\(]\S/,
        jn = {
          autoAlpha: "opacity,visibility",
          scale: "scaleX,scaleY",
          alpha: "opacity",
        },
        Xn = function (t, e) {
          return e.set(
            e.t,
            e.p,
            Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u,
            e
          );
        },
        qn = function (t, e) {
          return e.set(
            e.t,
            e.p,
            1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u,
            e
          );
        },
        Yn = function (t, e) {
          return e.set(
            e.t,
            e.p,
            t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b,
            e
          );
        },
        Kn = function (t, e) {
          var n = e.s + e.c * t;
          e.set(e.t, e.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + e.u, e);
        },
        Zn = function (t, e) {
          return e.set(e.t, e.p, t ? e.e : e.b, e);
        },
        $n = function (t, e) {
          return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e);
        },
        Jn = function (t, e, n) {
          return (t.style[e] = n);
        },
        Qn = function (t, e, n) {
          return t.style.setProperty(e, n);
        },
        ti = function (t, e, n) {
          return (t._gsap[e] = n);
        },
        ei = function (t, e, n) {
          return (t._gsap.scaleX = t._gsap.scaleY = n);
        },
        ni = function (t, e, n, i, r) {
          var s = t._gsap;
          (s.scaleX = s.scaleY = n), s.renderTransform(r, s);
        },
        ii = function (t, e, n, i, r) {
          var s = t._gsap;
          (s[e] = n), s.renderTransform(r, s);
        },
        ri = "transform",
        si = ri + "Origin",
        oi = function t(e, n) {
          var i = this,
            r = this.target,
            s = r.style;
          if (e in kn && s) {
            if (((this.tfm = this.tfm || {}), "transform" === e))
              return jn.transform.split(",").forEach(function (e) {
                return t.call(i, e, n);
              });
            if (
              (~(e = jn[e] || e).indexOf(",")
                ? e.split(",").forEach(function (t) {
                    return (i.tfm[t] = Ti(r, t));
                  })
                : (this.tfm[e] = r._gsap.x ? r._gsap[e] : Ti(r, e)),
              this.props.indexOf(ri) >= 0)
            )
              return;
            r._gsap.svg &&
              ((this.svgo = r.getAttribute("data-svg-origin")),
              this.props.push(si, n, "")),
              (e = ri);
          }
          (s || n) && this.props.push(e, n, s[e]);
        },
        ai = function (t) {
          t.translate &&
            (t.removeProperty("translate"),
            t.removeProperty("scale"),
            t.removeProperty("rotate"));
        },
        li = function () {
          var t,
            e,
            n = this.props,
            i = this.target,
            r = i.style,
            s = i._gsap;
          for (t = 0; t < n.length; t += 3)
            n[t + 1]
              ? (i[n[t]] = n[t + 2])
              : n[t + 2]
              ? (r[n[t]] = n[t + 2])
              : r.removeProperty(
                  "--" === n[t].substr(0, 2)
                    ? n[t]
                    : n[t].replace(Vn, "-$1").toLowerCase()
                );
          if (this.tfm) {
            for (e in this.tfm) s[e] = this.tfm[e];
            s.svg &&
              (s.renderTransform(),
              i.setAttribute("data-svg-origin", this.svgo || "")),
              ((t = Nn()) && t.isStart) || r[ri] || (ai(r), (s.uncache = 1));
          }
        },
        ci = function (t, e) {
          var n = {
            target: t,
            props: [],
            revert: li,
            save: oi,
          };
          return (
            t._gsap || Cn.core.getCache(t),
            e &&
              e.split(",").forEach(function (t) {
                return n.save(t);
              }),
            n
          );
        },
        ui = function (t, e) {
          var n = Rn.createElementNS
            ? Rn.createElementNS(
                (e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"),
                t
              )
            : Rn.createElement(t);
          return n.style ? n : Rn.createElement(t);
        },
        hi = function t(e, n, i) {
          var r = getComputedStyle(e);
          return (
            r[n] ||
            r.getPropertyValue(n.replace(Vn, "-$1").toLowerCase()) ||
            r.getPropertyValue(n) ||
            (!i && t(e, pi(n) || n, 1)) ||
            ""
          );
        },
        di = "O,Moz,ms,Ms,Webkit".split(","),
        pi = function (t, e, n) {
          var i = (e || In).style,
            r = 5;
          if (t in i && !n) return t;
          for (
            t = t.charAt(0).toUpperCase() + t.substr(1);
            r-- && !(di[r] + t in i);

          );
          return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? di[r] : "") + t;
        },
        fi = function () {
          "undefined" != typeof window &&
            window.document &&
            ((Pn = window),
            (Rn = Pn.document),
            (Ln = Rn.documentElement),
            (In = ui("div") || {
              style: {},
            }),
            ui("div"),
            (ri = pi(ri)),
            (si = ri + "Origin"),
            (In.style.cssText =
              "border-width:0;line-height:0;position:absolute;padding:0"),
            (Un = !!pi("perspective")),
            (Nn = Cn.core.reverting),
            (On = 1));
        },
        mi = function t(e) {
          var n,
            i = ui(
              "svg",
              (this.ownerSVGElement &&
                this.ownerSVGElement.getAttribute("xmlns")) ||
                "http://www.w3.org/2000/svg"
            ),
            r = this.parentNode,
            s = this.nextSibling,
            o = this.style.cssText;
          if (
            (Ln.appendChild(i),
            i.appendChild(this),
            (this.style.display = "block"),
            e)
          )
            try {
              (n = this.getBBox()),
                (this._gsapBBox = this.getBBox),
                (this.getBBox = t);
            } catch (t) {}
          else this._gsapBBox && (n = this._gsapBBox());
          return (
            r && (s ? r.insertBefore(this, s) : r.appendChild(this)),
            Ln.removeChild(i),
            (this.style.cssText = o),
            n
          );
        },
        gi = function (t, e) {
          for (var n = e.length; n--; )
            if (t.hasAttribute(e[n])) return t.getAttribute(e[n]);
        },
        vi = function (t) {
          var e;
          try {
            e = t.getBBox();
          } catch (n) {
            e = mi.call(t, !0);
          }
          return (
            (e && (e.width || e.height)) ||
              t.getBBox === mi ||
              (e = mi.call(t, !0)),
            !e || e.width || e.x || e.y
              ? e
              : {
                  x: +gi(t, ["x", "cx", "x1"]) || 0,
                  y: +gi(t, ["y", "cy", "y1"]) || 0,
                  width: 0,
                  height: 0,
                }
          );
        },
        _i = function (t) {
          return !(!t.getCTM || (t.parentNode && !t.ownerSVGElement) || !vi(t));
        },
        yi = function (t, e) {
          if (e) {
            var n = t.style;
            e in kn && e !== si && (e = ri),
              n.removeProperty
                ? (("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6)) ||
                    (e = "-" + e),
                  n.removeProperty(e.replace(Vn, "-$1").toLowerCase()))
                : n.removeAttribute(e);
          }
        },
        xi = function (t, e, n, i, r, s) {
          var o = new gn(t._pt, e, n, 0, 1, s ? $n : Zn);
          return (t._pt = o), (o.b = i), (o.e = r), t._props.push(n), o;
        },
        bi = {
          deg: 1,
          rad: 1,
          turn: 1,
        },
        Si = {
          grid: 1,
          flex: 1,
        },
        Ei = function t(e, n, i, r) {
          var s,
            o,
            a,
            l,
            c = parseFloat(i) || 0,
            u = (i + "").trim().substr((c + "").length) || "px",
            h = In.style,
            d = Gn.test(n),
            p = "svg" === e.tagName.toLowerCase(),
            f = (p ? "client" : "offset") + (d ? "Width" : "Height"),
            m = 100,
            g = "px" === r,
            v = "%" === r;
          return r === u || !c || bi[r] || bi[u]
            ? c
            : ("px" !== u && !g && (c = t(e, n, i, "px")),
              (l = e.getCTM && _i(e)),
              (!v && "%" !== u) || (!kn[n] && !~n.indexOf("adius"))
                ? ((h[d ? "width" : "height"] = m + (g ? u : r)),
                  (o =
                    ~n.indexOf("adius") || ("em" === r && e.appendChild && !p)
                      ? e
                      : e.parentNode),
                  l && (o = (e.ownerSVGElement || {}).parentNode),
                  (o && o !== Rn && o.appendChild) || (o = Rn.body),
                  (a = o._gsap) &&
                  v &&
                  a.width &&
                  d &&
                  a.time === Ce.time &&
                  !a.uncache
                    ? yt((c / a.width) * m)
                    : ((v || "%" === u) &&
                        !Si[hi(o, "display")] &&
                        (h.position = hi(e, "position")),
                      o === e && (h.position = "static"),
                      o.appendChild(In),
                      (s = In[f]),
                      o.removeChild(In),
                      (h.position = "absolute"),
                      d &&
                        v &&
                        (((a = gt(o)).time = Ce.time), (a.width = o[f])),
                      yt(g ? (s * c) / m : s && c ? (m / s) * c : 0)))
                : ((s = l ? e.getBBox()[d ? "width" : "height"] : e[f]),
                  yt(v ? (c / s) * m : (c / 100) * s)));
        },
        Ti = function (t, e, n, i) {
          var r;
          return (
            On || fi(),
            e in jn &&
              "transform" !== e &&
              ~(e = jn[e]).indexOf(",") &&
              (e = e.split(",")[0]),
            kn[e] && "transform" !== e
              ? ((r = Fi(t, i)),
                (r =
                  "transformOrigin" !== e
                    ? r[e]
                    : r.svg
                    ? r.origin
                    : Ni(hi(t, si)) + " " + r.zOrigin + "px"))
              : (!(r = t.style[e]) ||
                  "auto" === r ||
                  i ||
                  ~(r + "").indexOf("calc(")) &&
                (r =
                  (Ai[e] && Ai[e](t, e, n)) ||
                  hi(t, e) ||
                  vt(t, e) ||
                  ("opacity" === e ? 1 : 0)),
            n && !~(r + "").trim().indexOf(" ") ? Ei(t, e, r, n) + n : r
          );
        },
        Mi = function (t, e, n, i) {
          if (!n || "none" === n) {
            var r = pi(e, t, 1),
              s = r && hi(t, r, 1);
            s && s !== n
              ? ((e = r), (n = s))
              : "borderColor" === e && (n = hi(t, "borderTopColor"));
          }
          var o,
            a,
            l,
            c,
            u,
            h,
            d,
            p,
            f,
            m,
            g,
            v = new gn(this._pt, t.style, e, 0, 1, un),
            _ = 0,
            y = 0;
          if (
            ((v.b = n),
            (v.e = i),
            (n += ""),
            "auto" == (i += "") &&
              ((t.style[e] = i), (i = hi(t, e) || i), (t.style[e] = n)),
            Ae((o = [n, i])),
            (i = o[1]),
            (l = (n = o[0]).match(X) || []),
            (i.match(X) || []).length)
          ) {
            for (; (a = X.exec(i)); )
              (d = a[0]),
                (f = i.substring(_, a.index)),
                u
                  ? (u = (u + 1) % 5)
                  : ("rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5)) ||
                    (u = 1),
                d !== (h = l[y++] || "") &&
                  ((c = parseFloat(h) || 0),
                  (g = h.substr((c + "").length)),
                  "=" === d.charAt(1) && (d = bt(c, d) + g),
                  (p = parseFloat(d)),
                  (m = d.substr((p + "").length)),
                  (_ = X.lastIndex - m.length),
                  m ||
                    ((m = m || T.units[e] || g),
                    _ === i.length && ((i += m), (v.e += m))),
                  g !== m && (c = Ei(t, e, h, m) || 0),
                  (v._pt = {
                    _next: v._pt,
                    p: f || 1 === y ? f : ",",
                    s: c,
                    c: p - c,
                    m: (u && u < 4) || "zIndex" === e ? Math.round : 0,
                  }));
            v.c = _ < i.length ? i.substring(_, i.length) : "";
          } else v.r = "display" === e && "none" === i ? $n : Zn;
          return Y.test(i) && (v.e = 0), (this._pt = v), v;
        },
        wi = {
          top: "0%",
          bottom: "100%",
          left: "0%",
          right: "100%",
          center: "50%",
        },
        Di = function (t, e) {
          if (e.tween && e.tween._time === e.tween._dur) {
            var n,
              i,
              r,
              s = e.t,
              o = s.style,
              a = e.u,
              l = s._gsap;
            if ("all" === a || !0 === a) (o.cssText = ""), (i = 1);
            else
              for (r = (a = a.split(",")).length; --r > -1; )
                (n = a[r]),
                  kn[n] && ((i = 1), (n = "transformOrigin" === n ? si : ri)),
                  yi(s, n);
            i &&
              (yi(s, ri),
              l &&
                (l.svg && s.removeAttribute("transform"),
                Fi(s, 1),
                (l.uncache = 1),
                ai(o)));
          }
        },
        Ai = {
          clearProps: function (t, e, n, i, r) {
            if ("isFromStart" !== r.data) {
              var s = (t._pt = new gn(t._pt, e, n, 0, 0, Di));
              return (
                (s.u = i), (s.pr = -10), (s.tween = r), t._props.push(n), 1
              );
            }
          },
        },
        Ci = [1, 0, 0, 1, 0, 0],
        Pi = {},
        Ri = function (t) {
          return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t;
        },
        Li = function (t) {
          var e = hi(t, ri);
          return Ri(e) ? Ci : e.substr(7).match(j).map(yt);
        },
        Oi = function (t, e) {
          var n,
            i,
            r,
            s,
            o = t._gsap || gt(t),
            a = t.style,
            l = Li(t);
          return o.svg && t.getAttribute("transform")
            ? "1,0,0,1,0,0" ===
              (l = [
                (r = t.transform.baseVal.consolidate().matrix).a,
                r.b,
                r.c,
                r.d,
                r.e,
                r.f,
              ]).join(",")
              ? Ci
              : l
            : (l !== Ci ||
                t.offsetParent ||
                t === Ln ||
                o.svg ||
                ((r = a.display),
                (a.display = "block"),
                ((n = t.parentNode) && t.offsetParent) ||
                  ((s = 1), (i = t.nextElementSibling), Ln.appendChild(t)),
                (l = Li(t)),
                r ? (a.display = r) : yi(t, "display"),
                s &&
                  (i
                    ? n.insertBefore(t, i)
                    : n
                    ? n.appendChild(t)
                    : Ln.removeChild(t))),
              e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l);
        },
        Ii = function (t, e, n, i, r, s) {
          var o,
            a,
            l,
            c = t._gsap,
            u = r || Oi(t, !0),
            h = c.xOrigin || 0,
            d = c.yOrigin || 0,
            p = c.xOffset || 0,
            f = c.yOffset || 0,
            m = u[0],
            g = u[1],
            v = u[2],
            _ = u[3],
            y = u[4],
            x = u[5],
            b = e.split(" "),
            S = parseFloat(b[0]) || 0,
            E = parseFloat(b[1]) || 0;
          n
            ? u !== Ci &&
              (a = m * _ - g * v) &&
              ((l = S * (-g / a) + E * (m / a) - (m * x - g * y) / a),
              (S = S * (_ / a) + E * (-v / a) + (v * x - _ * y) / a),
              (E = l))
            : ((S =
                (o = vi(t)).x + (~b[0].indexOf("%") ? (S / 100) * o.width : S)),
              (E =
                o.y +
                (~(b[1] || b[0]).indexOf("%") ? (E / 100) * o.height : E))),
            i || (!1 !== i && c.smooth)
              ? ((y = S - h),
                (x = E - d),
                (c.xOffset = p + (y * m + x * v) - y),
                (c.yOffset = f + (y * g + x * _) - x))
              : (c.xOffset = c.yOffset = 0),
            (c.xOrigin = S),
            (c.yOrigin = E),
            (c.smooth = !!i),
            (c.origin = e),
            (c.originIsAbsolute = !!n),
            (t.style[si] = "0px 0px"),
            s &&
              (xi(s, c, "xOrigin", h, S),
              xi(s, c, "yOrigin", d, E),
              xi(s, c, "xOffset", p, c.xOffset),
              xi(s, c, "yOffset", f, c.yOffset)),
            t.setAttribute("data-svg-origin", S + " " + E);
        },
        Fi = function (t, e) {
          var n = t._gsap || new Ve(t);
          if ("x" in n && !e && !n.uncache) return n;
          var i,
            r,
            s,
            o,
            a,
            l,
            c,
            u,
            h,
            d,
            p,
            f,
            m,
            g,
            v,
            _,
            y,
            x,
            b,
            S,
            E,
            M,
            w,
            D,
            A,
            C,
            P,
            R,
            L,
            O,
            I,
            F,
            N = t.style,
            U = n.scaleX < 0,
            k = "px",
            z = "deg",
            B = getComputedStyle(t),
            H = hi(t, si) || "0";
          return (
            (i = r = s = l = c = u = h = d = p = 0),
            (o = a = 1),
            (n.svg = !(!t.getCTM || !_i(t))),
            B.translate &&
              (("none" === B.translate &&
                "none" === B.scale &&
                "none" === B.rotate) ||
                (N[ri] =
                  ("none" !== B.translate
                    ? "translate3d(" +
                      (B.translate + " 0 0").split(" ").slice(0, 3).join(", ") +
                      ") "
                    : "") +
                  ("none" !== B.rotate ? "rotate(" + B.rotate + ") " : "") +
                  ("none" !== B.scale
                    ? "scale(" + B.scale.split(" ").join(",") + ") "
                    : "") +
                  ("none" !== B[ri] ? B[ri] : "")),
              (N.scale = N.rotate = N.translate = "none")),
            (g = Oi(t, n.svg)),
            n.svg &&
              (n.uncache
                ? ((A = t.getBBox()),
                  (H = n.xOrigin - A.x + "px " + (n.yOrigin - A.y) + "px"),
                  (D = ""))
                : (D = !e && t.getAttribute("data-svg-origin")),
              Ii(t, D || H, !!D || n.originIsAbsolute, !1 !== n.smooth, g)),
            (f = n.xOrigin || 0),
            (m = n.yOrigin || 0),
            g !== Ci &&
              ((x = g[0]),
              (b = g[1]),
              (S = g[2]),
              (E = g[3]),
              (i = M = g[4]),
              (r = w = g[5]),
              6 === g.length
                ? ((o = Math.sqrt(x * x + b * b)),
                  (a = Math.sqrt(E * E + S * S)),
                  (l = x || b ? Hn(b, x) * zn : 0),
                  (h = S || E ? Hn(S, E) * zn + l : 0) &&
                    (a *= Math.abs(Math.cos(h * Bn))),
                  n.svg &&
                    ((i -= f - (f * x + m * S)), (r -= m - (f * b + m * E))))
                : ((F = g[6]),
                  (O = g[7]),
                  (P = g[8]),
                  (R = g[9]),
                  (L = g[10]),
                  (I = g[11]),
                  (i = g[12]),
                  (r = g[13]),
                  (s = g[14]),
                  (c = (v = Hn(F, L)) * zn),
                  v &&
                    ((D = M * (_ = Math.cos(-v)) + P * (y = Math.sin(-v))),
                    (A = w * _ + R * y),
                    (C = F * _ + L * y),
                    (P = M * -y + P * _),
                    (R = w * -y + R * _),
                    (L = F * -y + L * _),
                    (I = O * -y + I * _),
                    (M = D),
                    (w = A),
                    (F = C)),
                  (u = (v = Hn(-S, L)) * zn),
                  v &&
                    ((_ = Math.cos(-v)),
                    (I = E * (y = Math.sin(-v)) + I * _),
                    (x = D = x * _ - P * y),
                    (b = A = b * _ - R * y),
                    (S = C = S * _ - L * y)),
                  (l = (v = Hn(b, x)) * zn),
                  v &&
                    ((D = x * (_ = Math.cos(v)) + b * (y = Math.sin(v))),
                    (A = M * _ + w * y),
                    (b = b * _ - x * y),
                    (w = w * _ - M * y),
                    (x = D),
                    (M = A)),
                  c &&
                    Math.abs(c) + Math.abs(l) > 359.9 &&
                    ((c = l = 0), (u = 180 - u)),
                  (o = yt(Math.sqrt(x * x + b * b + S * S))),
                  (a = yt(Math.sqrt(w * w + F * F))),
                  (v = Hn(M, w)),
                  (h = Math.abs(v) > 2e-4 ? v * zn : 0),
                  (p = I ? 1 / (I < 0 ? -I : I) : 0)),
              n.svg &&
                ((D = t.getAttribute("transform")),
                (n.forceCSS =
                  t.setAttribute("transform", "") || !Ri(hi(t, ri))),
                D && t.setAttribute("transform", D))),
            Math.abs(h) > 90 &&
              Math.abs(h) < 270 &&
              (U
                ? ((o *= -1),
                  (h += l <= 0 ? 180 : -180),
                  (l += l <= 0 ? 180 : -180))
                : ((a *= -1), (h += h <= 0 ? 180 : -180))),
            (e = e || n.uncache),
            (n.x =
              i -
              ((n.xPercent =
                i &&
                ((!e && n.xPercent) ||
                  (Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0)))
                ? (t.offsetWidth * n.xPercent) / 100
                : 0) +
              k),
            (n.y =
              r -
              ((n.yPercent =
                r &&
                ((!e && n.yPercent) ||
                  (Math.round(t.offsetHeight / 2) === Math.round(-r)
                    ? -50
                    : 0)))
                ? (t.offsetHeight * n.yPercent) / 100
                : 0) +
              k),
            (n.z = s + k),
            (n.scaleX = yt(o)),
            (n.scaleY = yt(a)),
            (n.rotation = yt(l) + z),
            (n.rotationX = yt(c) + z),
            (n.rotationY = yt(u) + z),
            (n.skewX = h + z),
            (n.skewY = d + z),
            (n.transformPerspective = p + k),
            (n.zOrigin = parseFloat(H.split(" ")[2]) || 0) && (N[si] = Ni(H)),
            (n.xOffset = n.yOffset = 0),
            (n.force3D = T.force3D),
            (n.renderTransform = n.svg ? Gi : Un ? Vi : ki),
            (n.uncache = 0),
            n
          );
        },
        Ni = function (t) {
          return (t = t.split(" "))[0] + " " + t[1];
        },
        Ui = function (t, e, n) {
          var i = ne(e);
          return yt(parseFloat(e) + parseFloat(Ei(t, "x", n + "px", i))) + i;
        },
        ki = function (t, e) {
          (e.z = "0px"),
            (e.rotationY = e.rotationX = "0deg"),
            (e.force3D = 0),
            Vi(t, e);
        },
        zi = "0deg",
        Bi = "0px",
        Hi = ") ",
        Vi = function (t, e) {
          var n = e || this,
            i = n.xPercent,
            r = n.yPercent,
            s = n.x,
            o = n.y,
            a = n.z,
            l = n.rotation,
            c = n.rotationY,
            u = n.rotationX,
            h = n.skewX,
            d = n.skewY,
            p = n.scaleX,
            f = n.scaleY,
            m = n.transformPerspective,
            g = n.force3D,
            v = n.target,
            _ = n.zOrigin,
            y = "",
            x = ("auto" === g && t && 1 !== t) || !0 === g;
          if (_ && (u !== zi || c !== zi)) {
            var b,
              S = parseFloat(c) * Bn,
              E = Math.sin(S),
              T = Math.cos(S);
            (S = parseFloat(u) * Bn),
              (b = Math.cos(S)),
              (s = Ui(v, s, E * b * -_)),
              (o = Ui(v, o, -Math.sin(S) * -_)),
              (a = Ui(v, a, T * b * -_ + _));
          }
          m !== Bi && (y += "perspective(" + m + Hi),
            (i || r) && (y += "translate(" + i + "%, " + r + "%) "),
            (x || s !== Bi || o !== Bi || a !== Bi) &&
              (y +=
                a !== Bi || x
                  ? "translate3d(" + s + ", " + o + ", " + a + ") "
                  : "translate(" + s + ", " + o + Hi),
            l !== zi && (y += "rotate(" + l + Hi),
            c !== zi && (y += "rotateY(" + c + Hi),
            u !== zi && (y += "rotateX(" + u + Hi),
            (h === zi && d === zi) || (y += "skew(" + h + ", " + d + Hi),
            (1 === p && 1 === f) || (y += "scale(" + p + ", " + f + Hi),
            (v.style[ri] = y || "translate(0, 0)");
        },
        Gi = function (t, e) {
          var n,
            i,
            r,
            s,
            o,
            a = e || this,
            l = a.xPercent,
            c = a.yPercent,
            u = a.x,
            h = a.y,
            d = a.rotation,
            p = a.skewX,
            f = a.skewY,
            m = a.scaleX,
            g = a.scaleY,
            v = a.target,
            _ = a.xOrigin,
            y = a.yOrigin,
            x = a.xOffset,
            b = a.yOffset,
            S = a.forceCSS,
            E = parseFloat(u),
            T = parseFloat(h);
          (d = parseFloat(d)),
            (p = parseFloat(p)),
            (f = parseFloat(f)) && ((p += f = parseFloat(f)), (d += f)),
            d || p
              ? ((d *= Bn),
                (p *= Bn),
                (n = Math.cos(d) * m),
                (i = Math.sin(d) * m),
                (r = Math.sin(d - p) * -g),
                (s = Math.cos(d - p) * g),
                p &&
                  ((f *= Bn),
                  (o = Math.tan(p - f)),
                  (r *= o = Math.sqrt(1 + o * o)),
                  (s *= o),
                  f &&
                    ((o = Math.tan(f)),
                    (n *= o = Math.sqrt(1 + o * o)),
                    (i *= o))),
                (n = yt(n)),
                (i = yt(i)),
                (r = yt(r)),
                (s = yt(s)))
              : ((n = m), (s = g), (i = r = 0)),
            ((E && !~(u + "").indexOf("px")) ||
              (T && !~(h + "").indexOf("px"))) &&
              ((E = Ei(v, "x", u, "px")), (T = Ei(v, "y", h, "px"))),
            (_ || y || x || b) &&
              ((E = yt(E + _ - (_ * n + y * r) + x)),
              (T = yt(T + y - (_ * i + y * s) + b))),
            (l || c) &&
              ((o = v.getBBox()),
              (E = yt(E + (l / 100) * o.width)),
              (T = yt(T + (c / 100) * o.height))),
            (o =
              "matrix(" +
              n +
              "," +
              i +
              "," +
              r +
              "," +
              s +
              "," +
              E +
              "," +
              T +
              ")"),
            v.setAttribute("transform", o),
            S && (v.style[ri] = o);
        },
        Wi = function (t, e, n, i, r) {
          var s,
            o,
            a = 360,
            l = I(r),
            c = parseFloat(r) * (l && ~r.indexOf("rad") ? zn : 1) - i,
            u = i + c + "deg";
          return (
            l &&
              ("short" === (s = r.split("_")[1]) &&
                (c %= a) != c % 180 &&
                (c += c < 0 ? a : -360),
              "cw" === s && c < 0
                ? (c = ((c + 36e9) % a) - ~~(c / a) * a)
                : "ccw" === s &&
                  c > 0 &&
                  (c = ((c - 36e9) % a) - ~~(c / a) * a)),
            (t._pt = o = new gn(t._pt, e, n, i, c, qn)),
            (o.e = u),
            (o.u = "deg"),
            t._props.push(n),
            o
          );
        },
        ji = function (t, e) {
          for (var n in e) t[n] = e[n];
          return t;
        },
        Xi = function (t, e, n) {
          var i,
            r,
            s,
            o,
            a,
            l,
            c,
            u = ji({}, n._gsap),
            h = n.style;
          for (r in (u.svg
            ? ((s = n.getAttribute("transform")),
              n.setAttribute("transform", ""),
              (h[ri] = e),
              (i = Fi(n, 1)),
              yi(n, ri),
              n.setAttribute("transform", s))
            : ((s = getComputedStyle(n)[ri]),
              (h[ri] = e),
              (i = Fi(n, 1)),
              (h[ri] = s)),
          kn))
            (s = u[r]) !== (o = i[r]) &&
              "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 &&
              ((a = ne(s) !== (c = ne(o)) ? Ei(n, r, s, c) : parseFloat(s)),
              (l = parseFloat(o)),
              (t._pt = new gn(t._pt, i, r, a, l - a, Xn)),
              (t._pt.u = c || 0),
              t._props.push(r));
          ji(i, u);
        };
      _t("padding,margin,Width,Radius", function (t, e) {
        var n = "Top",
          i = "Right",
          r = "Bottom",
          s = "Left",
          o = (e < 3 ? [n, i, r, s] : [n + s, n + i, r + i, r + s]).map(
            function (n) {
              return e < 2 ? t + n : "border" + n + t;
            }
          );
        Ai[e > 1 ? "border" + t : t] = function (t, e, n, i, r) {
          var s, a;
          if (arguments.length < 4)
            return (
              (s = o.map(function (e) {
                return Ti(t, e, n);
              })),
              5 === (a = s.join(" ")).split(s[0]).length ? s[0] : a
            );
          (s = (i + "").split(" ")),
            (a = {}),
            o.forEach(function (t, e) {
              return (a[t] = s[e] = s[e] || s[((e - 1) / 2) | 0]);
            }),
            t.init(e, a, r);
        };
      });
      var qi,
        Yi,
        Ki = {
          name: "css",
          register: fi,
          targetTest: function (t) {
            return t.style && t.nodeType;
          },
          init: function (t, e, n, i, r) {
            var s,
              o,
              a,
              l,
              c,
              u,
              h,
              d,
              p,
              f,
              m,
              g,
              v,
              _,
              y,
              x,
              b,
              S,
              E,
              M,
              w = this._props,
              D = t.style,
              A = n.vars.startAt;
            for (h in (On || fi(),
            (this.styles = this.styles || ci(t)),
            (x = this.styles.props),
            (this.tween = n),
            e))
              if (
                "autoRound" !== h &&
                ((o = e[h]), !ut[h] || !Ke(h, e, n, i, t, r))
              )
                if (
                  ((c = typeof o),
                  (u = Ai[h]),
                  "function" === c && (c = typeof (o = o.call(n, i, t, r))),
                  "string" === c && ~o.indexOf("random(") && (o = pe(o)),
                  u)
                )
                  u(this, t, h, o, n) && (y = 1);
                else if ("--" === h.substr(0, 2))
                  (s = (getComputedStyle(t).getPropertyValue(h) + "").trim()),
                    (o += ""),
                    (we.lastIndex = 0),
                    we.test(s) || ((d = ne(s)), (p = ne(o))),
                    p ? d !== p && (s = Ei(t, h, s, p) + p) : d && (o += d),
                    this.add(D, "setProperty", s, o, i, r, 0, 0, h),
                    w.push(h),
                    x.push(h, 0, D[h]);
                else if ("undefined" !== c) {
                  if (
                    (A && h in A
                      ? ((s =
                          "function" == typeof A[h]
                            ? A[h].call(n, i, t, r)
                            : A[h]),
                        I(s) && ~s.indexOf("random(") && (s = pe(s)),
                        ne(s + "") || (s += T.units[h] || ne(Ti(t, h)) || ""),
                        "=" === (s + "").charAt(1) && (s = Ti(t, h)))
                      : (s = Ti(t, h)),
                    (l = parseFloat(s)),
                    (f =
                      "string" === c &&
                      "=" === o.charAt(1) &&
                      o.substr(0, 2)) && (o = o.substr(2)),
                    (a = parseFloat(o)),
                    h in jn &&
                      ("autoAlpha" === h &&
                        (1 === l &&
                          "hidden" === Ti(t, "visibility") &&
                          a &&
                          (l = 0),
                        x.push("visibility", 0, D.visibility),
                        xi(
                          this,
                          D,
                          "visibility",
                          l ? "inherit" : "hidden",
                          a ? "inherit" : "hidden",
                          !a
                        )),
                      "scale" !== h &&
                        "transform" !== h &&
                        ~(h = jn[h]).indexOf(",") &&
                        (h = h.split(",")[0])),
                    (m = h in kn))
                  )
                    if (
                      (this.styles.save(h),
                      g ||
                        (((v = t._gsap).renderTransform && !e.parseTransform) ||
                          Fi(t, e.parseTransform),
                        (_ = !1 !== e.smoothOrigin && v.smooth),
                        ((g = this._pt =
                          new gn(
                            this._pt,
                            D,
                            ri,
                            0,
                            1,
                            v.renderTransform,
                            v,
                            0,
                            -1
                          )).dep = 1)),
                      "scale" === h)
                    )
                      (this._pt = new gn(
                        this._pt,
                        v,
                        "scaleY",
                        v.scaleY,
                        (f ? bt(v.scaleY, f + a) : a) - v.scaleY || 0,
                        Xn
                      )),
                        (this._pt.u = 0),
                        w.push("scaleY", h),
                        (h += "X");
                    else {
                      if ("transformOrigin" === h) {
                        x.push(si, 0, D[si]),
                          (S = void 0),
                          (E = void 0),
                          (M = void 0),
                          (E = (S = (b = o).split(" "))[0]),
                          (M = S[1] || "50%"),
                          ("top" !== E &&
                            "bottom" !== E &&
                            "left" !== M &&
                            "right" !== M) ||
                            ((b = E), (E = M), (M = b)),
                          (S[0] = wi[E] || E),
                          (S[1] = wi[M] || M),
                          (o = S.join(" ")),
                          v.svg
                            ? Ii(t, o, 0, _, 0, this)
                            : ((p = parseFloat(o.split(" ")[2]) || 0) !==
                                v.zOrigin &&
                                xi(this, v, "zOrigin", v.zOrigin, p),
                              xi(this, D, h, Ni(s), Ni(o)));
                        continue;
                      }
                      if ("svgOrigin" === h) {
                        Ii(t, o, 1, _, 0, this);
                        continue;
                      }
                      if (h in Pi) {
                        Wi(this, v, h, l, f ? bt(l, f + o) : o);
                        continue;
                      }
                      if ("smoothOrigin" === h) {
                        xi(this, v, "smooth", v.smooth, o);
                        continue;
                      }
                      if ("force3D" === h) {
                        v[h] = o;
                        continue;
                      }
                      if ("transform" === h) {
                        Xi(this, o, t);
                        continue;
                      }
                    }
                  else h in D || (h = pi(h) || h);
                  if (
                    m ||
                    ((a || 0 === a) && (l || 0 === l) && !Wn.test(o) && h in D)
                  )
                    a || (a = 0),
                      (d = (s + "").substr((l + "").length)) !==
                        (p = ne(o) || (h in T.units ? T.units[h] : d)) &&
                        (l = Ei(t, h, s, p)),
                      (this._pt = new gn(
                        this._pt,
                        m ? v : D,
                        h,
                        l,
                        (f ? bt(l, f + a) : a) - l,
                        m ||
                        ("px" !== p && "zIndex" !== h) ||
                        !1 === e.autoRound
                          ? Xn
                          : Kn
                      )),
                      (this._pt.u = p || 0),
                      d !== p &&
                        "%" !== p &&
                        ((this._pt.b = s), (this._pt.r = Yn));
                  else if (h in D) Mi.call(this, t, h, s, f ? f + o : o);
                  else if (h in t)
                    this.add(t, h, s || t[h], f ? f + o : o, i, r);
                  else if ("parseTransform" !== h) {
                    tt(h, o);
                    continue;
                  }
                  m || (h in D ? x.push(h, 0, D[h]) : x.push(h, 1, s || t[h])),
                    w.push(h);
                }
            y && mn(this);
          },
          render: function (t, e) {
            if (e.tween._time || !Nn())
              for (var n = e._pt; n; ) n.r(t, n.d), (n = n._next);
            else e.styles.revert();
          },
          get: Ti,
          aliases: jn,
          getSetter: function (t, e, n) {
            var i = jn[e];
            return (
              i && i.indexOf(",") < 0 && (e = i),
              e in kn && e !== si && (t._gsap.x || Ti(t, "x"))
                ? n && Fn === n
                  ? "scale" === e
                    ? ei
                    : ti
                  : (Fn = n || {}) && ("scale" === e ? ni : ii)
                : t.style && !U(t.style[e])
                ? Jn
                : ~e.indexOf("-")
                ? Qn
                : an(t, e)
            );
          },
          core: {
            _removeProperty: yi,
            _getMatrix: Oi,
          },
        };
      (Cn.utils.checkPrefix = pi),
        (Cn.core.getStyleSaver = ci),
        (Yi = _t(
          "x,y,z,scale,scaleX,scaleY,xPercent,yPercent" +
            "," +
            (qi = "rotation,rotationX,rotationY,skewX,skewY") +
            ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
          function (t) {
            kn[t] = 1;
          }
        )),
        _t(qi, function (t) {
          (T.units[t] = "deg"), (Pi[t] = 1);
        }),
        (jn[Yi[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + qi),
        _t(
          "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY",
          function (t) {
            var e = t.split(":");
            jn[e[1]] = Yi[e[0]];
          }
        ),
        _t(
          "x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
          function (t) {
            T.units[t] = "px";
          }
        ),
        Cn.registerPlugin(Ki);
      var Zi = Cn.registerPlugin(Ki) || Cn;
      function $i(t, e) {
        for (var n = 0; n < e.length; n++) {
          var i = e[n];
          (i.enumerable = i.enumerable || !1),
            (i.configurable = !0),
            "value" in i && (i.writable = !0),
            Object.defineProperty(t, i.key, i);
        }
      }
      Zi.core.Tween;
      var Ji,
        Qi,
        tr,
        er,
        nr,
        ir,
        rr,
        sr,
        or,
        ar,
        lr,
        cr,
        ur,
        hr = function () {
          return (
            Ji ||
            ("undefined" != typeof window &&
              (Ji = window.gsap) &&
              Ji.registerPlugin &&
              Ji)
          );
        },
        dr = 1,
        pr = [],
        fr = [],
        mr = [],
        gr = Date.now,
        vr = function (t, e) {
          return e;
        },
        _r = function (t, e) {
          return ~mr.indexOf(t) && mr[mr.indexOf(t) + 1][e];
        },
        yr = function (t) {
          return !!~ar.indexOf(t);
        },
        xr = function (t, e, n, i, r) {
          return t.addEventListener(e, n, {
            passive: !i,
            capture: !!r,
          });
        },
        br = function (t, e, n, i) {
          return t.removeEventListener(e, n, !!i);
        },
        Sr = "scrollLeft",
        Er = "scrollTop",
        Tr = function () {
          return (lr && lr.isPressed) || fr.cache++;
        },
        Mr = function (t, e) {
          var n = function n(i) {
            if (i || 0 === i) {
              dr && (tr.history.scrollRestoration = "manual");
              var r = lr && lr.isPressed;
              (i = n.v = Math.round(i) || (lr && lr.iOS ? 1 : 0)),
                t(i),
                (n.cacheID = fr.cache),
                r && vr("ss", i);
            } else
              (e || fr.cache !== n.cacheID || vr("ref")) &&
                ((n.cacheID = fr.cache), (n.v = t()));
            return n.v + n.offset;
          };
          return (n.offset = 0), t && n;
        },
        wr = {
          s: Sr,
          p: "left",
          p2: "Left",
          os: "right",
          os2: "Right",
          d: "width",
          d2: "Width",
          a: "x",
          sc: Mr(function (t) {
            return arguments.length
              ? tr.scrollTo(t, Dr.sc())
              : tr.pageXOffset || er[Sr] || nr[Sr] || ir[Sr] || 0;
          }),
        },
        Dr = {
          s: Er,
          p: "top",
          p2: "Top",
          os: "bottom",
          os2: "Bottom",
          d: "height",
          d2: "Height",
          a: "y",
          op: wr,
          sc: Mr(function (t) {
            return arguments.length
              ? tr.scrollTo(wr.sc(), t)
              : tr.pageYOffset || er[Er] || nr[Er] || ir[Er] || 0;
          }),
        },
        Ar = function (t, e) {
          return (
            ((e && e._ctx && e._ctx.selector) || Ji.utils.toArray)(t)[0] ||
            ("string" == typeof t && !1 !== Ji.config().nullTargetWarn
              ? console.warn("Element not found:", t)
              : null)
          );
        },
        Cr = function (t, e) {
          var n = e.s,
            i = e.sc;
          yr(t) && (t = er.scrollingElement || nr);
          var r = fr.indexOf(t),
            s = i === Dr.sc ? 1 : 2;
          !~r && (r = fr.push(t) - 1), fr[r + s] || xr(t, "scroll", Tr);
          var o = fr[r + s],
            a =
              o ||
              (fr[r + s] =
                Mr(_r(t, n), !0) ||
                (yr(t)
                  ? i
                  : Mr(function (e) {
                      return arguments.length ? (t[n] = e) : t[n];
                    })));
          return (
            (a.target = t),
            o || (a.smooth = "smooth" === Ji.getProperty(t, "scrollBehavior")),
            a
          );
        },
        Pr = function (t, e, n) {
          var i = t,
            r = t,
            s = gr(),
            o = s,
            a = e || 50,
            l = Math.max(500, 3 * a),
            c = function (t, e) {
              var l = gr();
              e || l - s > a
                ? ((r = i), (i = t), (o = s), (s = l))
                : n
                ? (i += t)
                : (i = r + ((t - r) / (l - o)) * (s - o));
            };
          return {
            update: c,
            reset: function () {
              (r = i = n ? 0 : i), (o = s = 0);
            },
            getVelocity: function (t) {
              var e = o,
                a = r,
                u = gr();
              return (
                (t || 0 === t) && t !== i && c(t),
                s === o || u - o > l
                  ? 0
                  : ((i + (n ? a : -a)) / ((n ? u : s) - e)) * 1e3
              );
            },
          };
        },
        Rr = function (t, e) {
          return (
            e && !t._gsapAllow && t.preventDefault(),
            t.changedTouches ? t.changedTouches[0] : t
          );
        },
        Lr = function (t) {
          var e = Math.max.apply(Math, t),
            n = Math.min.apply(Math, t);
          return Math.abs(e) >= Math.abs(n) ? e : n;
        },
        Or = function () {
          (or = Ji.core.globals().ScrollTrigger) &&
            or.core &&
            (function () {
              var t = or.core,
                e = t.bridge || {},
                n = t._scrollers,
                i = t._proxies;
              n.push.apply(n, fr),
                i.push.apply(i, mr),
                (fr = n),
                (mr = i),
                (vr = function (t, n) {
                  return e[t](n);
                });
            })();
        },
        Ir = function (t) {
          return (
            (Ji = t || hr()) &&
              "undefined" != typeof document &&
              document.body &&
              ((tr = window),
              (er = document),
              (nr = er.documentElement),
              (ir = er.body),
              (ar = [tr, er, nr, ir]),
              Ji.utils.clamp,
              (ur = Ji.core.context || function () {}),
              (sr = "onpointerenter" in ir ? "pointer" : "mouse"),
              (rr = Fr.isTouch =
                tr.matchMedia &&
                tr.matchMedia("(hover: none), (pointer: coarse)").matches
                  ? 1
                  : "ontouchstart" in tr ||
                    navigator.maxTouchPoints > 0 ||
                    navigator.msMaxTouchPoints > 0
                  ? 2
                  : 0),
              (cr = Fr.eventTypes =
                (
                  "ontouchstart" in nr
                    ? "touchstart,touchmove,touchcancel,touchend"
                    : "onpointerdown" in nr
                    ? "pointerdown,pointermove,pointercancel,pointerup"
                    : "mousedown,mousemove,mouseup,mouseup"
                ).split(",")),
              setTimeout(function () {
                return (dr = 0);
              }, 500),
              Or(),
              (Qi = 1)),
            Qi
          );
        };
      (wr.op = Dr), (fr.cache = 0);
      var Fr = (function () {
        function t(t) {
          this.init(t);
        }
        var e, n;
        return (
          (t.prototype.init = function (t) {
            Qi ||
              Ir(Ji) ||
              console.warn("Please gsap.registerPlugin(Observer)"),
              or || Or();
            var e = t.tolerance,
              n = t.dragMinimum,
              i = t.type,
              r = t.target,
              s = t.lineHeight,
              o = t.debounce,
              a = t.preventDefault,
              l = t.onStop,
              c = t.onStopDelay,
              u = t.ignore,
              h = t.wheelSpeed,
              d = t.event,
              p = t.onDragStart,
              f = t.onDragEnd,
              m = t.onDrag,
              g = t.onPress,
              v = t.onRelease,
              _ = t.onRight,
              y = t.onLeft,
              x = t.onUp,
              b = t.onDown,
              S = t.onChangeX,
              E = t.onChangeY,
              T = t.onChange,
              M = t.onToggleX,
              w = t.onToggleY,
              D = t.onHover,
              A = t.onHoverEnd,
              C = t.onMove,
              P = t.ignoreCheck,
              R = t.isNormalizer,
              L = t.onGestureStart,
              O = t.onGestureEnd,
              I = t.onWheel,
              F = t.onEnable,
              N = t.onDisable,
              U = t.onClick,
              k = t.scrollSpeed,
              z = t.capture,
              B = t.allowClicks,
              H = t.lockAxis,
              V = t.onLockAxis;
            (this.target = r = Ar(r) || nr),
              (this.vars = t),
              u && (u = Ji.utils.toArray(u)),
              (e = e || 1e-9),
              (n = n || 0),
              (h = h || 1),
              (k = k || 1),
              (i = i || "wheel,touch,pointer"),
              (o = !1 !== o),
              s || (s = parseFloat(tr.getComputedStyle(ir).lineHeight) || 22);
            var G,
              W,
              j,
              X,
              q,
              Y,
              K,
              Z = this,
              $ = 0,
              J = 0,
              Q = Cr(r, wr),
              tt = Cr(r, Dr),
              et = Q(),
              nt = tt(),
              it =
                ~i.indexOf("touch") &&
                !~i.indexOf("pointer") &&
                "pointerdown" === cr[0],
              rt = yr(r),
              st = r.ownerDocument || er,
              ot = [0, 0, 0],
              at = [0, 0, 0],
              lt = 0,
              ct = function () {
                return (lt = gr());
              },
              ut = function (t, e) {
                return (
                  ((Z.event = t) && u && ~u.indexOf(t.target)) ||
                  (e && it && "touch" !== t.pointerType) ||
                  (P && P(t, e))
                );
              },
              ht = function () {
                var t = (Z.deltaX = Lr(ot)),
                  n = (Z.deltaY = Lr(at)),
                  i = Math.abs(t) >= e,
                  r = Math.abs(n) >= e;
                T && (i || r) && T(Z, t, n, ot, at),
                  i &&
                    (_ && Z.deltaX > 0 && _(Z),
                    y && Z.deltaX < 0 && y(Z),
                    S && S(Z),
                    M && Z.deltaX < 0 != $ < 0 && M(Z),
                    ($ = Z.deltaX),
                    (ot[0] = ot[1] = ot[2] = 0)),
                  r &&
                    (b && Z.deltaY > 0 && b(Z),
                    x && Z.deltaY < 0 && x(Z),
                    E && E(Z),
                    w && Z.deltaY < 0 != J < 0 && w(Z),
                    (J = Z.deltaY),
                    (at[0] = at[1] = at[2] = 0)),
                  (X || j) && (C && C(Z), j && (m(Z), (j = !1)), (X = !1)),
                  Y && !(Y = !1) && V && V(Z),
                  q && (I(Z), (q = !1)),
                  (G = 0);
              },
              dt = function (t, e, n) {
                (ot[n] += t),
                  (at[n] += e),
                  Z._vx.update(t),
                  Z._vy.update(e),
                  o ? G || (G = requestAnimationFrame(ht)) : ht();
              },
              pt = function (t, e) {
                H &&
                  !K &&
                  ((Z.axis = K = Math.abs(t) > Math.abs(e) ? "x" : "y"),
                  (Y = !0)),
                  "y" !== K && ((ot[2] += t), Z._vx.update(t, !0)),
                  "x" !== K && ((at[2] += e), Z._vy.update(e, !0)),
                  o ? G || (G = requestAnimationFrame(ht)) : ht();
              },
              ft = function (t) {
                if (!ut(t, 1)) {
                  var e = (t = Rr(t, a)).clientX,
                    i = t.clientY,
                    r = e - Z.x,
                    s = i - Z.y,
                    o = Z.isDragging;
                  (Z.x = e),
                    (Z.y = i),
                    (o ||
                      Math.abs(Z.startX - e) >= n ||
                      Math.abs(Z.startY - i) >= n) &&
                      (m && (j = !0),
                      o || (Z.isDragging = !0),
                      pt(r, s),
                      o || (p && p(Z)));
                }
              },
              mt = (Z.onPress = function (t) {
                ut(t, 1) ||
                  (t && t.button) ||
                  ((Z.axis = K = null),
                  W.pause(),
                  (Z.isPressed = !0),
                  (t = Rr(t)),
                  ($ = J = 0),
                  (Z.startX = Z.x = t.clientX),
                  (Z.startY = Z.y = t.clientY),
                  Z._vx.reset(),
                  Z._vy.reset(),
                  xr(R ? r : st, cr[1], ft, a, !0),
                  (Z.deltaX = Z.deltaY = 0),
                  g && g(Z));
              }),
              gt = (Z.onRelease = function (t) {
                if (!ut(t, 1)) {
                  br(R ? r : st, cr[1], ft, !0);
                  var e = !isNaN(Z.y - Z.startY),
                    n =
                      Z.isDragging &&
                      (Math.abs(Z.x - Z.startX) > 3 ||
                        Math.abs(Z.y - Z.startY) > 3),
                    i = Rr(t);
                  !n &&
                    e &&
                    (Z._vx.reset(),
                    Z._vy.reset(),
                    a &&
                      B &&
                      Ji.delayedCall(0.08, function () {
                        if (gr() - lt > 300 && !t.defaultPrevented)
                          if (t.target.click) t.target.click();
                          else if (st.createEvent) {
                            var e = st.createEvent("MouseEvents");
                            e.initMouseEvent(
                              "click",
                              !0,
                              !0,
                              tr,
                              1,
                              i.screenX,
                              i.screenY,
                              i.clientX,
                              i.clientY,
                              !1,
                              !1,
                              !1,
                              !1,
                              0,
                              null
                            ),
                              t.target.dispatchEvent(e);
                          }
                      })),
                    (Z.isDragging = Z.isGesturing = Z.isPressed = !1),
                    l && !R && W.restart(!0),
                    f && n && f(Z),
                    v && v(Z, n);
                }
              }),
              vt = function (t) {
                return (
                  t.touches &&
                  t.touches.length > 1 &&
                  (Z.isGesturing = !0) &&
                  L(t, Z.isDragging)
                );
              },
              _t = function () {
                return (Z.isGesturing = !1) || O(Z);
              },
              yt = function (t) {
                if (!ut(t)) {
                  var e = Q(),
                    n = tt();
                  dt((e - et) * k, (n - nt) * k, 1),
                    (et = e),
                    (nt = n),
                    l && W.restart(!0);
                }
              },
              xt = function (t) {
                if (!ut(t)) {
                  (t = Rr(t, a)), I && (q = !0);
                  var e =
                    (1 === t.deltaMode
                      ? s
                      : 2 === t.deltaMode
                      ? tr.innerHeight
                      : 1) * h;
                  dt(t.deltaX * e, t.deltaY * e, 0), l && !R && W.restart(!0);
                }
              },
              bt = function (t) {
                if (!ut(t)) {
                  var e = t.clientX,
                    n = t.clientY,
                    i = e - Z.x,
                    r = n - Z.y;
                  (Z.x = e), (Z.y = n), (X = !0), (i || r) && pt(i, r);
                }
              },
              St = function (t) {
                (Z.event = t), D(Z);
              },
              Et = function (t) {
                (Z.event = t), A(Z);
              },
              Tt = function (t) {
                return ut(t) || (Rr(t, a) && U(Z));
              };
            (W = Z._dc =
              Ji.delayedCall(c || 0.25, function () {
                Z._vx.reset(), Z._vy.reset(), W.pause(), l && l(Z);
              }).pause()),
              (Z.deltaX = Z.deltaY = 0),
              (Z._vx = Pr(0, 50, !0)),
              (Z._vy = Pr(0, 50, !0)),
              (Z.scrollX = Q),
              (Z.scrollY = tt),
              (Z.isDragging = Z.isGesturing = Z.isPressed = !1),
              ur(this),
              (Z.enable = function (t) {
                return (
                  Z.isEnabled ||
                    (xr(rt ? st : r, "scroll", Tr),
                    i.indexOf("scroll") >= 0 &&
                      xr(rt ? st : r, "scroll", yt, a, z),
                    i.indexOf("wheel") >= 0 && xr(r, "wheel", xt, a, z),
                    ((i.indexOf("touch") >= 0 && rr) ||
                      i.indexOf("pointer") >= 0) &&
                      (xr(r, cr[0], mt, a, z),
                      xr(st, cr[2], gt),
                      xr(st, cr[3], gt),
                      B && xr(r, "click", ct, !1, !0),
                      U && xr(r, "click", Tt),
                      L && xr(st, "gesturestart", vt),
                      O && xr(st, "gestureend", _t),
                      D && xr(r, sr + "enter", St),
                      A && xr(r, sr + "leave", Et),
                      C && xr(r, sr + "move", bt)),
                    (Z.isEnabled = !0),
                    t && t.type && mt(t),
                    F && F(Z)),
                  Z
                );
              }),
              (Z.disable = function () {
                Z.isEnabled &&
                  (pr.filter(function (t) {
                    return t !== Z && yr(t.target);
                  }).length || br(rt ? st : r, "scroll", Tr),
                  Z.isPressed &&
                    (Z._vx.reset(),
                    Z._vy.reset(),
                    br(R ? r : st, cr[1], ft, !0)),
                  br(rt ? st : r, "scroll", yt, z),
                  br(r, "wheel", xt, z),
                  br(r, cr[0], mt, z),
                  br(st, cr[2], gt),
                  br(st, cr[3], gt),
                  br(r, "click", ct, !0),
                  br(r, "click", Tt),
                  br(st, "gesturestart", vt),
                  br(st, "gestureend", _t),
                  br(r, sr + "enter", St),
                  br(r, sr + "leave", Et),
                  br(r, sr + "move", bt),
                  (Z.isEnabled = Z.isPressed = Z.isDragging = !1),
                  N && N(Z));
              }),
              (Z.kill = Z.revert =
                function () {
                  Z.disable();
                  var t = pr.indexOf(Z);
                  t >= 0 && pr.splice(t, 1), lr === Z && (lr = 0);
                }),
              pr.push(Z),
              R && yr(r) && (lr = Z),
              Z.enable(d);
          }),
          (e = t),
          (n = [
            {
              key: "velocityX",
              get: function () {
                return this._vx.getVelocity();
              },
            },
            {
              key: "velocityY",
              get: function () {
                return this._vy.getVelocity();
              },
            },
          ]) && $i(e.prototype, n),
          t
        );
      })();
      (Fr.version = "3.12.2"),
        (Fr.create = function (t) {
          return new Fr(t);
        }),
        (Fr.register = Ir),
        (Fr.getAll = function () {
          return pr.slice();
        }),
        (Fr.getById = function (t) {
          return pr.filter(function (e) {
            return e.vars.id === t;
          })[0];
        }),
        hr() && Ji.registerPlugin(Fr);
      var Nr,
        Ur,
        kr,
        zr,
        Br,
        Hr,
        Vr,
        Gr,
        Wr,
        jr,
        Xr,
        qr,
        Yr,
        Kr,
        Zr,
        $r,
        Jr,
        Qr,
        ts,
        es,
        ns,
        is,
        rs,
        ss,
        os,
        as,
        ls,
        cs,
        us,
        hs,
        ds,
        ps,
        fs,
        ms,
        gs,
        vs,
        _s = 1,
        ys = Date.now,
        xs = ys(),
        bs = 0,
        Ss = 0,
        Es = function (t, e, n) {
          var i =
            Us(t) && ("clamp(" === t.substr(0, 6) || t.indexOf("max") > -1);
          return (n["_" + e + "Clamp"] = i), i ? t.substr(6, t.length - 7) : t;
        },
        Ts = function (t, e) {
          return !e || (Us(t) && "clamp(" === t.substr(0, 6))
            ? t
            : "clamp(" + t + ")";
        },
        Ms = function t() {
          return Ss && requestAnimationFrame(t);
        },
        ws = function () {
          return (Kr = 1);
        },
        Ds = function () {
          return (Kr = 0);
        },
        As = function (t) {
          return t;
        },
        Cs = function (t) {
          return Math.round(1e5 * t) / 1e5 || 0;
        },
        Ps = function () {
          return "undefined" != typeof window;
        },
        Rs = function () {
          return Nr || (Ps() && (Nr = window.gsap) && Nr.registerPlugin && Nr);
        },
        Ls = function (t) {
          return !!~Vr.indexOf(t);
        },
        Os = function (t) {
          return (
            ("Height" === t ? ds : kr["inner" + t]) ||
            Br["client" + t] ||
            Hr["client" + t]
          );
        },
        Is = function (t) {
          return (
            _r(t, "getBoundingClientRect") ||
            (Ls(t)
              ? function () {
                  return (qo.width = kr.innerWidth), (qo.height = ds), qo;
                }
              : function () {
                  return oo(t);
                })
          );
        },
        Fs = function (t, e) {
          var n = e.s,
            i = e.d2,
            r = e.d,
            s = e.a;
          return Math.max(
            0,
            (n = "scroll" + i) && (s = _r(t, n))
              ? s() - Is(t)()[r]
              : Ls(t)
              ? (Br[n] || Hr[n]) - Os(i)
              : t[n] - t["offset" + i]
          );
        },
        Ns = function (t, e) {
          for (var n = 0; n < ts.length; n += 3)
            (!e || ~e.indexOf(ts[n + 1])) && t(ts[n], ts[n + 1], ts[n + 2]);
        },
        Us = function (t) {
          return "string" == typeof t;
        },
        ks = function (t) {
          return "function" == typeof t;
        },
        zs = function (t) {
          return "number" == typeof t;
        },
        Bs = function (t) {
          return "object" == typeof t;
        },
        Hs = function (t, e, n) {
          return t && t.progress(e ? 0 : 1) && n && t.pause();
        },
        Vs = function (t, e) {
          if (t.enabled) {
            var n = e(t);
            n && n.totalTime && (t.callbackAnimation = n);
          }
        },
        Gs = Math.abs,
        Ws = "left",
        js = "right",
        Xs = "bottom",
        qs = "width",
        Ys = "height",
        Ks = "Right",
        Zs = "Left",
        $s = "Top",
        Js = "Bottom",
        Qs = "padding",
        to = "margin",
        eo = "Width",
        no = "Height",
        io = "px",
        ro = function (t) {
          return kr.getComputedStyle(t);
        },
        so = function (t, e) {
          for (var n in e) n in t || (t[n] = e[n]);
          return t;
        },
        oo = function (t, e) {
          var n =
              e &&
              "matrix(1, 0, 0, 1, 0, 0)" !== ro(t)[Zr] &&
              Nr.to(t, {
                x: 0,
                y: 0,
                xPercent: 0,
                yPercent: 0,
                rotation: 0,
                rotationX: 0,
                rotationY: 0,
                scale: 1,
                skewX: 0,
                skewY: 0,
              }).progress(1),
            i = t.getBoundingClientRect();
          return n && n.progress(0).kill(), i;
        },
        ao = function (t, e) {
          var n = e.d2;
          return t["offset" + n] || t["client" + n] || 0;
        },
        lo = function (t) {
          var e,
            n = [],
            i = t.labels,
            r = t.duration();
          for (e in i) n.push(i[e] / r);
          return n;
        },
        co = function (t) {
          var e = Nr.utils.snap(t),
            n =
              Array.isArray(t) &&
              t.slice(0).sort(function (t, e) {
                return t - e;
              });
          return n
            ? function (t, i, r) {
                var s;
                if ((void 0 === r && (r = 0.001), !i)) return e(t);
                if (i > 0) {
                  for (t -= r, s = 0; s < n.length; s++)
                    if (n[s] >= t) return n[s];
                  return n[s - 1];
                }
                for (s = n.length, t += r; s--; ) if (n[s] <= t) return n[s];
                return n[0];
              }
            : function (n, i, r) {
                void 0 === r && (r = 0.001);
                var s = e(n);
                return !i || Math.abs(s - n) < r || s - n < 0 == i < 0
                  ? s
                  : e(i < 0 ? n - t : n + t);
              };
        },
        uo = function (t, e, n, i) {
          return n.split(",").forEach(function (n) {
            return t(e, n, i);
          });
        },
        ho = function (t, e, n, i, r) {
          return t.addEventListener(e, n, {
            passive: !i,
            capture: !!r,
          });
        },
        po = function (t, e, n, i) {
          return t.removeEventListener(e, n, !!i);
        },
        fo = function (t, e, n) {
          (n = n && n.wheelHandler) && (t(e, "wheel", n), t(e, "touchmove", n));
        },
        mo = {
          startColor: "green",
          endColor: "red",
          indent: 0,
          fontSize: "16px",
          fontWeight: "normal",
        },
        go = {
          toggleActions: "play",
          anticipatePin: 0,
        },
        vo = {
          top: 0,
          left: 0,
          center: 0.5,
          bottom: 1,
          right: 1,
        },
        _o = function (t, e) {
          if (Us(t)) {
            var n = t.indexOf("="),
              i = ~n ? +(t.charAt(n - 1) + 1) * parseFloat(t.substr(n + 1)) : 0;
            ~n &&
              (t.indexOf("%") > n && (i *= e / 100), (t = t.substr(0, n - 1))),
              (t =
                i +
                (t in vo
                  ? vo[t] * e
                  : ~t.indexOf("%")
                  ? (parseFloat(t) * e) / 100
                  : parseFloat(t) || 0));
          }
          return t;
        },
        yo = function (t, e, n, i, r, s, o, a) {
          var l = r.startColor,
            c = r.endColor,
            u = r.fontSize,
            h = r.indent,
            d = r.fontWeight,
            p = zr.createElement("div"),
            f = Ls(n) || "fixed" === _r(n, "pinType"),
            m = -1 !== t.indexOf("scroller"),
            g = f ? Hr : n,
            v = -1 !== t.indexOf("start"),
            _ = v ? l : c,
            y =
              "border-color:" +
              _ +
              ";font-size:" +
              u +
              ";color:" +
              _ +
              ";font-weight:" +
              d +
              ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
          return (
            (y += "position:" + ((m || a) && f ? "fixed;" : "absolute;")),
            (m || a || !f) &&
              (y += (i === Dr ? js : Xs) + ":" + (s + parseFloat(h)) + "px;"),
            o &&
              (y +=
                "box-sizing:border-box;text-align:left;width:" +
                o.offsetWidth +
                "px;"),
            (p._isStart = v),
            p.setAttribute(
              "class",
              "gsap-marker-" + t + (e ? " marker-" + e : "")
            ),
            (p.style.cssText = y),
            (p.innerText = e || 0 === e ? t + "-" + e : t),
            g.children[0] ? g.insertBefore(p, g.children[0]) : g.appendChild(p),
            (p._offset = p["offset" + i.op.d2]),
            xo(p, 0, i, v),
            p
          );
        },
        xo = function (t, e, n, i) {
          var r = {
              display: "block",
            },
            s = n[i ? "os2" : "p2"],
            o = n[i ? "p2" : "os2"];
          (t._isFlipped = i),
            (r[n.a + "Percent"] = i ? -100 : 0),
            (r[n.a] = i ? "1px" : 0),
            (r["border" + s + eo] = 1),
            (r["border" + o + eo] = 0),
            (r[n.p] = e + "px"),
            Nr.set(t, r);
        },
        bo = [],
        So = {},
        Eo = function () {
          return ys() - bs > 34 && (fs || (fs = requestAnimationFrame(Bo)));
        },
        To = function () {
          (!rs || !rs.isPressed || rs.startX > Hr.clientWidth) &&
            (fr.cache++,
            rs ? fs || (fs = requestAnimationFrame(Bo)) : Bo(),
            bs || Po("scrollStart"),
            (bs = ys()));
        },
        Mo = function () {
          (as = kr.innerWidth), (os = kr.innerHeight);
        },
        wo = function () {
          fr.cache++,
            !Yr &&
              !is &&
              !zr.fullscreenElement &&
              !zr.webkitFullscreenElement &&
              (!ss ||
                as !== kr.innerWidth ||
                Math.abs(kr.innerHeight - os) > 0.25 * kr.innerHeight) &&
              Gr.restart(!0);
        },
        Do = {},
        Ao = [],
        Co = function t() {
          return po(ta, "scrollEnd", t) || Uo(!0);
        },
        Po = function (t) {
          return (
            (Do[t] &&
              Do[t].map(function (t) {
                return t();
              })) ||
            Ao
          );
        },
        Ro = [],
        Lo = function (t) {
          for (var e = 0; e < Ro.length; e += 5)
            (!t || (Ro[e + 4] && Ro[e + 4].query === t)) &&
              ((Ro[e].style.cssText = Ro[e + 1]),
              Ro[e].getBBox && Ro[e].setAttribute("transform", Ro[e + 2] || ""),
              (Ro[e + 3].uncache = 1));
        },
        Oo = function (t, e) {
          var n;
          for ($r = 0; $r < bo.length; $r++)
            !(n = bo[$r]) ||
              (e && n._ctx !== e) ||
              (t ? n.kill(1) : n.revert(!0, !0));
          e && Lo(e), e || Po("revert");
        },
        Io = function (t, e) {
          fr.cache++,
            (e || !ms) &&
              fr.forEach(function (t) {
                return ks(t) && t.cacheID++ && (t.rec = 0);
              }),
            Us(t) && (kr.history.scrollRestoration = us = t);
        },
        Fo = 0,
        No = function () {
          Hr.appendChild(hs),
            (ds = hs.offsetHeight || kr.innerHeight),
            Hr.removeChild(hs);
        },
        Uo = function (t, e) {
          if (!bs || t) {
            No(),
              (ms = ta.isRefreshing = !0),
              fr.forEach(function (t) {
                return ks(t) && ++t.cacheID && (t.rec = t());
              });
            var n = Po("refreshInit");
            es && ta.sort(),
              e || Oo(),
              fr.forEach(function (t) {
                ks(t) &&
                  (t.smooth && (t.target.style.scrollBehavior = "auto"), t(0));
              }),
              bo.slice(0).forEach(function (t) {
                return t.refresh();
              }),
              bo.forEach(function (t, e) {
                if (t._subPinOffset && t.pin) {
                  var n = t.vars.horizontal ? "offsetWidth" : "offsetHeight",
                    i = t.pin[n];
                  t.revert(!0, 1),
                    t.adjustPinSpacing(t.pin[n] - i),
                    t.refresh();
                }
              }),
              bo.forEach(function (t) {
                var e = Fs(t.scroller, t._dir);
                ("max" === t.vars.end || (t._endClamp && t.end > e)) &&
                  t.setPositions(t.start, Math.max(t.start + 1, e), !0);
              }),
              n.forEach(function (t) {
                return t && t.render && t.render(-1);
              }),
              fr.forEach(function (t) {
                ks(t) &&
                  (t.smooth &&
                    requestAnimationFrame(function () {
                      return (t.target.style.scrollBehavior = "smooth");
                    }),
                  t.rec && t(t.rec));
              }),
              Io(us, 1),
              Gr.pause(),
              Fo++,
              (ms = 2),
              Bo(2),
              bo.forEach(function (t) {
                return ks(t.vars.onRefresh) && t.vars.onRefresh(t);
              }),
              (ms = ta.isRefreshing = !1),
              Po("refresh");
          } else ho(ta, "scrollEnd", Co);
        },
        ko = 0,
        zo = 1,
        Bo = function (t) {
          if (!ms || 2 === t) {
            (ta.isUpdating = !0), vs && vs.update(0);
            var e = bo.length,
              n = ys(),
              i = n - xs >= 50,
              r = e && bo[0].scroll();
            if (
              ((zo = ko > r ? -1 : 1),
              ms || (ko = r),
              i &&
                (bs && !Kr && n - bs > 200 && ((bs = 0), Po("scrollEnd")),
                (Xr = xs),
                (xs = n)),
              zo < 0)
            ) {
              for ($r = e; $r-- > 0; ) bo[$r] && bo[$r].update(0, i);
              zo = 1;
            } else for ($r = 0; $r < e; $r++) bo[$r] && bo[$r].update(0, i);
            ta.isUpdating = !1;
          }
          fs = 0;
        },
        Ho = [
          Ws,
          "top",
          Xs,
          js,
          to + Js,
          to + Ks,
          to + $s,
          to + Zs,
          "display",
          "flexShrink",
          "float",
          "zIndex",
          "gridColumnStart",
          "gridColumnEnd",
          "gridRowStart",
          "gridRowEnd",
          "gridArea",
          "justifySelf",
          "alignSelf",
          "placeSelf",
          "order",
        ],
        Vo = Ho.concat([
          qs,
          Ys,
          "boxSizing",
          "max" + eo,
          "max" + no,
          "position",
          to,
          Qs,
          Qs + $s,
          Qs + Ks,
          Qs + Js,
          Qs + Zs,
        ]),
        Go = function (t, e, n, i) {
          if (!t._gsap.swappedIn) {
            for (var r, s = Ho.length, o = e.style, a = t.style; s--; )
              o[(r = Ho[s])] = n[r];
            (o.position = "absolute" === n.position ? "absolute" : "relative"),
              "inline" === n.display && (o.display = "inline-block"),
              (a[Xs] = a[js] = "auto"),
              (o.flexBasis = n.flexBasis || "auto"),
              (o.overflow = "visible"),
              (o.boxSizing = "border-box"),
              (o[qs] = ao(t, wr) + io),
              (o[Ys] = ao(t, Dr) + io),
              (o[Qs] = a[to] = a.top = a[Ws] = "0"),
              jo(i),
              (a[qs] = a["max" + eo] = n[qs]),
              (a[Ys] = a["max" + no] = n[Ys]),
              (a[Qs] = n[Qs]),
              t.parentNode !== e &&
                (t.parentNode.insertBefore(e, t), e.appendChild(t)),
              (t._gsap.swappedIn = !0);
          }
        },
        Wo = /([A-Z])/g,
        jo = function (t) {
          if (t) {
            var e,
              n,
              i = t.t.style,
              r = t.length,
              s = 0;
            for (
              (t.t._gsap || Nr.core.getCache(t.t)).uncache = 1;
              s < r;
              s += 2
            )
              (n = t[s + 1]),
                (e = t[s]),
                n
                  ? (i[e] = n)
                  : i[e] &&
                    i.removeProperty(e.replace(Wo, "-$1").toLowerCase());
          }
        },
        Xo = function (t) {
          for (var e = Vo.length, n = t.style, i = [], r = 0; r < e; r++)
            i.push(Vo[r], n[Vo[r]]);
          return (i.t = t), i;
        },
        qo = {
          left: 0,
          top: 0,
        },
        Yo = function (t, e, n, i, r, s, o, a, l, c, u, h, d, p) {
          ks(t) && (t = t(a)),
            Us(t) &&
              "max" === t.substr(0, 3) &&
              (t = h + ("=" === t.charAt(4) ? _o("0" + t.substr(3), n) : 0));
          var f,
            m,
            g,
            v = d ? d.time() : 0;
          if ((d && d.seek(0), isNaN(t) || (t = +t), zs(t)))
            d &&
              (t = Nr.utils.mapRange(
                d.scrollTrigger.start,
                d.scrollTrigger.end,
                0,
                h,
                t
              )),
              o && xo(o, n, i, !0);
          else {
            ks(e) && (e = e(a));
            var _,
              y,
              x,
              b,
              S = (t || "0").split(" ");
            (g = Ar(e, a) || Hr),
              ((_ = oo(g) || {}) && (_.left || _.top)) ||
                "none" !== ro(g).display ||
                ((b = g.style.display),
                (g.style.display = "block"),
                (_ = oo(g)),
                b ? (g.style.display = b) : g.style.removeProperty("display")),
              (y = _o(S[0], _[i.d])),
              (x = _o(S[1] || "0", n)),
              (t = _[i.p] - l[i.p] - c + y + r - x),
              o && xo(o, x, i, n - x < 20 || (o._isStart && x > 20)),
              (n -= n - x);
          }
          if ((p && ((a[p] = t || -0.001), t < 0 && (t = 0)), s)) {
            var E = t + n,
              T = s._isStart;
            (f = "scroll" + i.d2),
              xo(
                s,
                E,
                i,
                (T && E > 20) ||
                  (!T &&
                    (u ? Math.max(Hr[f], Br[f]) : s.parentNode[f]) <= E + 1)
              ),
              u &&
                ((l = oo(o)),
                u && (s.style[i.op.p] = l[i.op.p] - i.op.m - s._offset + io));
          }
          return (
            d &&
              g &&
              ((f = oo(g)),
              d.seek(h),
              (m = oo(g)),
              (d._caScrollDist = f[i.p] - m[i.p]),
              (t = (t / d._caScrollDist) * h)),
            d && d.seek(v),
            d ? t : Math.round(t)
          );
        },
        Ko = /(webkit|moz|length|cssText|inset)/i,
        Zo = function (t, e, n, i) {
          if (t.parentNode !== e) {
            var r,
              s,
              o = t.style;
            if (e === Hr) {
              for (r in ((t._stOrig = o.cssText), (s = ro(t))))
                +r ||
                  Ko.test(r) ||
                  !s[r] ||
                  "string" != typeof o[r] ||
                  "0" === r ||
                  (o[r] = s[r]);
              (o.top = n), (o.left = i);
            } else o.cssText = t._stOrig;
            (Nr.core.getCache(t).uncache = 1), e.appendChild(t);
          }
        },
        $o = function (t, e, n) {
          var i = e,
            r = i;
          return function (e) {
            var s = Math.round(t());
            return (
              s !== i &&
                s !== r &&
                Math.abs(s - i) > 3 &&
                Math.abs(s - r) > 3 &&
                ((e = s), n && n()),
              (r = i),
              (i = e),
              e
            );
          };
        },
        Jo = function (t, e, n) {
          var i = {};
          (i[e.p] = "+=" + n), Nr.set(t, i);
        },
        Qo = function (t, e) {
          var n = Cr(t, e),
            i = "_scroll" + e.p2,
            r = function e(r, s, o, a, l) {
              var c = e.tween,
                u = s.onComplete,
                h = {};
              o = o || n();
              var d = $o(n, o, function () {
                c.kill(), (e.tween = 0);
              });
              return (
                (l = (a && l) || 0),
                (a = a || r - o),
                c && c.kill(),
                (s[i] = r),
                (s.modifiers = h),
                (h[i] = function () {
                  return d(o + a * c.ratio + l * c.ratio * c.ratio);
                }),
                (s.onUpdate = function () {
                  fr.cache++, Bo();
                }),
                (s.onComplete = function () {
                  (e.tween = 0), u && u.call(c);
                }),
                (c = e.tween = Nr.to(t, s))
              );
            };
          return (
            (t[i] = n),
            (n.wheelHandler = function () {
              return r.tween && r.tween.kill() && (r.tween = 0);
            }),
            ho(t, "wheel", n.wheelHandler),
            ta.isTouch && ho(t, "touchmove", n.wheelHandler),
            r
          );
        },
        ta = (function () {
          function t(e, n) {
            Ur ||
              t.register(Nr) ||
              console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
              cs(this),
              this.init(e, n);
          }
          return (
            (t.prototype.init = function (e, n) {
              if (
                ((this.progress = this.start = 0),
                this.vars && this.kill(!0, !0),
                Ss)
              ) {
                var i,
                  r,
                  s,
                  o,
                  a,
                  l,
                  c,
                  u,
                  h,
                  d,
                  p,
                  f,
                  m,
                  g,
                  v,
                  _,
                  y,
                  x,
                  b,
                  S,
                  E,
                  T,
                  M,
                  w,
                  D,
                  A,
                  C,
                  P,
                  R,
                  L,
                  O,
                  I,
                  F,
                  N,
                  U,
                  k,
                  z,
                  B,
                  H,
                  V,
                  G,
                  W,
                  j = (e = so(
                    Us(e) || zs(e) || e.nodeType
                      ? {
                          trigger: e,
                        }
                      : e,
                    go
                  )),
                  X = j.onUpdate,
                  q = j.toggleClass,
                  Y = j.id,
                  K = j.onToggle,
                  Z = j.onRefresh,
                  $ = j.scrub,
                  J = j.trigger,
                  Q = j.pin,
                  tt = j.pinSpacing,
                  et = j.invalidateOnRefresh,
                  nt = j.anticipatePin,
                  it = j.onScrubComplete,
                  rt = j.onSnapComplete,
                  st = j.once,
                  ot = j.snap,
                  at = j.pinReparent,
                  lt = j.pinSpacer,
                  ct = j.containerAnimation,
                  ut = j.fastScrollEnd,
                  ht = j.preventOverlaps,
                  dt =
                    e.horizontal ||
                    (e.containerAnimation && !1 !== e.horizontal)
                      ? wr
                      : Dr,
                  pt = !$ && 0 !== $,
                  ft = Ar(e.scroller || kr),
                  mt = Nr.core.getCache(ft),
                  gt = Ls(ft),
                  vt =
                    "fixed" ===
                    ("pinType" in e
                      ? e.pinType
                      : _r(ft, "pinType") || (gt && "fixed")),
                  _t = [e.onEnter, e.onLeave, e.onEnterBack, e.onLeaveBack],
                  yt = pt && e.toggleActions.split(" "),
                  xt = "markers" in e ? e.markers : go.markers,
                  bt = gt ? 0 : parseFloat(ro(ft)["border" + dt.p2 + eo]) || 0,
                  St = this,
                  Et =
                    e.onRefreshInit &&
                    function () {
                      return e.onRefreshInit(St);
                    },
                  Tt = (function (t, e, n) {
                    var i = n.d,
                      r = n.d2,
                      s = n.a;
                    return (s = _r(t, "getBoundingClientRect"))
                      ? function () {
                          return s()[i];
                        }
                      : function () {
                          return (e ? Os(r) : t["client" + r]) || 0;
                        };
                  })(ft, gt, dt),
                  Mt = (function (t, e) {
                    return !e || ~mr.indexOf(t)
                      ? Is(t)
                      : function () {
                          return qo;
                        };
                  })(ft, gt),
                  wt = 0,
                  Dt = 0,
                  At = 0,
                  Ct = Cr(ft, dt);
                if (
                  ((St._startClamp = St._endClamp = !1),
                  (St._dir = dt),
                  (nt *= 45),
                  (St.scroller = ft),
                  (St.scroll = ct ? ct.time.bind(ct) : Ct),
                  (o = Ct()),
                  (St.vars = e),
                  (n = n || e.animation),
                  "refreshPriority" in e &&
                    ((es = 1), -9999 === e.refreshPriority && (vs = St)),
                  (mt.tweenScroll = mt.tweenScroll || {
                    top: Qo(ft, Dr),
                    left: Qo(ft, wr),
                  }),
                  (St.tweenTo = i = mt.tweenScroll[dt.p]),
                  (St.scrubDuration = function (t) {
                    (F = zs(t) && t)
                      ? I
                        ? I.duration(t)
                        : (I = Nr.to(n, {
                            ease: "expo",
                            totalProgress: "+=0",
                            duration: F,
                            paused: !0,
                            onComplete: function () {
                              return it && it(St);
                            },
                          }))
                      : (I && I.progress(1).kill(), (I = 0));
                  }),
                  n &&
                    ((n.vars.lazy = !1),
                    (n._initted && !St.isReverted) ||
                      (!1 !== n.vars.immediateRender &&
                        !1 !== e.immediateRender &&
                        n.duration() &&
                        n.render(0, !0, !0)),
                    (St.animation = n.pause()),
                    (n.scrollTrigger = St),
                    St.scrubDuration($),
                    (L = 0),
                    Y || (Y = n.vars.id)),
                  ot &&
                    ((Bs(ot) && !ot.push) ||
                      (ot = {
                        snapTo: ot,
                      }),
                    "scrollBehavior" in Hr.style &&
                      Nr.set(gt ? [Hr, Br] : ft, {
                        scrollBehavior: "auto",
                      }),
                    fr.forEach(function (t) {
                      return (
                        ks(t) &&
                        t.target === (gt ? zr.scrollingElement || Br : ft) &&
                        (t.smooth = !1)
                      );
                    }),
                    (s = ks(ot.snapTo)
                      ? ot.snapTo
                      : "labels" === ot.snapTo
                      ? (function (t) {
                          return function (e) {
                            return Nr.utils.snap(lo(t), e);
                          };
                        })(n)
                      : "labelsDirectional" === ot.snapTo
                      ? ((V = n),
                        function (t, e) {
                          return co(lo(V))(t, e.direction);
                        })
                      : !1 !== ot.directional
                      ? function (t, e) {
                          return co(ot.snapTo)(
                            t,
                            ys() - Dt < 500 ? 0 : e.direction
                          );
                        }
                      : Nr.utils.snap(ot.snapTo)),
                    (N = ot.duration || {
                      min: 0.1,
                      max: 2,
                    }),
                    (N = Bs(N) ? jr(N.min, N.max) : jr(N, N)),
                    (U = Nr.delayedCall(ot.delay || F / 2 || 0.1, function () {
                      var t = Ct(),
                        e = ys() - Dt < 500,
                        r = i.tween;
                      if (
                        !(e || Math.abs(St.getVelocity()) < 10) ||
                        r ||
                        Kr ||
                        wt === t
                      )
                        St.isActive && wt !== t && U.restart(!0);
                      else {
                        var o = (t - l) / g,
                          a = n && !pt ? n.totalProgress() : o,
                          u = e ? 0 : ((a - O) / (ys() - Xr)) * 1e3 || 0,
                          h = Nr.utils.clamp(
                            -o,
                            1 - o,
                            (Gs(u / 2) * u) / 0.185
                          ),
                          d = o + (!1 === ot.inertia ? 0 : h),
                          p = jr(0, 1, s(d, St)),
                          f = Math.round(l + p * g),
                          m = ot,
                          v = m.onStart,
                          _ = m.onInterrupt,
                          y = m.onComplete;
                        if (t <= c && t >= l && f !== t) {
                          if (r && !r._initted && r.data <= Gs(f - t)) return;
                          !1 === ot.inertia && (h = p - o),
                            i(
                              f,
                              {
                                duration: N(
                                  Gs(
                                    (0.185 * Math.max(Gs(d - a), Gs(p - a))) /
                                      u /
                                      0.05 || 0
                                  )
                                ),
                                ease: ot.ease || "power3",
                                data: Gs(f - t),
                                onInterrupt: function () {
                                  return U.restart(!0) && _ && _(St);
                                },
                                onComplete: function () {
                                  St.update(),
                                    (wt = Ct()),
                                    (L = O =
                                      n && !pt
                                        ? n.totalProgress()
                                        : St.progress),
                                    rt && rt(St),
                                    y && y(St);
                                },
                              },
                              t,
                              h * g,
                              f - t - h * g
                            ),
                            v && v(St, i.tween);
                        }
                      }
                    }).pause())),
                  Y && (So[Y] = St),
                  (H =
                    (J = St.trigger = Ar(J || (!0 !== Q && Q))) &&
                    J._gsap &&
                    J._gsap.stRevert) && (H = H(St)),
                  (Q = !0 === Q ? J : Ar(Q)),
                  Us(q) &&
                    (q = {
                      targets: J,
                      className: q,
                    }),
                  Q &&
                    (!1 === tt ||
                      tt === to ||
                      (tt =
                        !(
                          !tt &&
                          Q.parentNode &&
                          Q.parentNode.style &&
                          "flex" === ro(Q.parentNode).display
                        ) && Qs),
                    (St.pin = Q),
                    (r = Nr.core.getCache(Q)).spacer
                      ? (v = r.pinState)
                      : (lt &&
                          ((lt = Ar(lt)) &&
                            !lt.nodeType &&
                            (lt = lt.current || lt.nativeElement),
                          (r.spacerIsNative = !!lt),
                          lt && (r.spacerState = Xo(lt))),
                        (r.spacer = x = lt || zr.createElement("div")),
                        x.classList.add("pin-spacer"),
                        Y && x.classList.add("pin-spacer-" + Y),
                        (r.pinState = v = Xo(Q))),
                    !1 !== e.force3D &&
                      Nr.set(Q, {
                        force3D: !0,
                      }),
                    (St.spacer = x = r.spacer),
                    (R = ro(Q)),
                    (w = R[tt + dt.os2]),
                    (S = Nr.getProperty(Q)),
                    (E = Nr.quickSetter(Q, dt.a, io)),
                    Go(Q, x, R),
                    (y = Xo(Q))),
                  xt)
                ) {
                  (f = Bs(xt) ? so(xt, mo) : mo),
                    (d = yo("scroller-start", Y, ft, dt, f, 0)),
                    (p = yo("scroller-end", Y, ft, dt, f, 0, d)),
                    (b = d["offset" + dt.op.d2]);
                  var Pt = Ar(_r(ft, "content") || ft);
                  (u = this.markerStart = yo("start", Y, Pt, dt, f, b, 0, ct)),
                    (h = this.markerEnd = yo("end", Y, Pt, dt, f, b, 0, ct)),
                    ct && (B = Nr.quickSetter([u, h], dt.a, io)),
                    vt ||
                      (mr.length && !0 === _r(ft, "fixedMarkers")) ||
                      ((W = ro((G = gt ? Hr : ft)).position),
                      (G.style.position =
                        "absolute" === W || "fixed" === W ? W : "relative"),
                      Nr.set([d, p], {
                        force3D: !0,
                      }),
                      (A = Nr.quickSetter(d, dt.a, io)),
                      (P = Nr.quickSetter(p, dt.a, io)));
                }
                if (ct) {
                  var Rt = ct.vars.onUpdate,
                    Lt = ct.vars.onUpdateParams;
                  ct.eventCallback("onUpdate", function () {
                    St.update(0, 0, 1), Rt && Rt.apply(ct, Lt || []);
                  });
                }
                if (
                  ((St.previous = function () {
                    return bo[bo.indexOf(St) - 1];
                  }),
                  (St.next = function () {
                    return bo[bo.indexOf(St) + 1];
                  }),
                  (St.revert = function (t, e) {
                    if (!e) return St.kill(!0);
                    var i = !1 !== t || !St.enabled,
                      r = Yr;
                    i !== St.isReverted &&
                      (i &&
                        ((k = Math.max(Ct(), St.scroll.rec || 0)),
                        (At = St.progress),
                        (z = n && n.progress())),
                      u &&
                        [u, h, d, p].forEach(function (t) {
                          return (t.style.display = i ? "none" : "block");
                        }),
                      i && ((Yr = St), St.update(i)),
                      !Q ||
                        (at && St.isActive) ||
                        (i
                          ? (function (t, e, n) {
                              jo(n);
                              var i = t._gsap;
                              if (i.spacerIsNative) jo(i.spacerState);
                              else if (t._gsap.swappedIn) {
                                var r = e.parentNode;
                                r && (r.insertBefore(t, e), r.removeChild(e));
                              }
                              t._gsap.swappedIn = !1;
                            })(Q, x, v)
                          : Go(Q, x, ro(Q), D)),
                      i || St.update(i),
                      (Yr = r),
                      (St.isReverted = i));
                  }),
                  (St.refresh = function (r, s, f, b) {
                    if ((!Yr && St.enabled) || s)
                      if (Q && r && bs) ho(t, "scrollEnd", Co);
                      else {
                        !ms && Et && Et(St),
                          (Yr = St),
                          i.tween && !f && (i.tween.kill(), (i.tween = 0)),
                          I && I.pause(),
                          et &&
                            n &&
                            n
                              .revert({
                                kill: !1,
                              })
                              .invalidate(),
                          St.isReverted || St.revert(!0, !0),
                          (St._subPinOffset = !1);
                        var E,
                          w,
                          A,
                          P,
                          R,
                          L,
                          O,
                          F,
                          N,
                          B,
                          H,
                          V,
                          G,
                          W = Tt(),
                          j = Mt(),
                          X = ct ? ct.duration() : Fs(ft, dt),
                          q = g <= 0.01,
                          Y = 0,
                          K = b || 0,
                          $ = Bs(f) ? f.end : e.end,
                          nt = e.endTrigger || J,
                          it = Bs(f)
                            ? f.start
                            : e.start ||
                              (0 !== e.start && J ? (Q ? "0 0" : "0 100%") : 0),
                          rt = (St.pinnedContainer =
                            e.pinnedContainer && Ar(e.pinnedContainer, St)),
                          st = (J && Math.max(0, bo.indexOf(St))) || 0,
                          ot = st;
                        for (
                          xt &&
                          Bs(f) &&
                          ((V = Nr.getProperty(d, dt.p)),
                          (G = Nr.getProperty(p, dt.p)));
                          ot--;

                        )
                          (L = bo[ot]).end || L.refresh(0, 1) || (Yr = St),
                            !(O = L.pin) ||
                              (O !== J && O !== Q && O !== rt) ||
                              L.isReverted ||
                              (B || (B = []), B.unshift(L), L.revert(!0, !0)),
                            L !== bo[ot] && (st--, ot--);
                        for (
                          ks(it) && (it = it(St)),
                            it = Es(it, "start", St),
                            l =
                              Yo(
                                it,
                                J,
                                W,
                                dt,
                                Ct(),
                                u,
                                d,
                                St,
                                j,
                                bt,
                                vt,
                                X,
                                ct,
                                St._startClamp && "_startClamp"
                              ) || (Q ? -0.001 : 0),
                            ks($) && ($ = $(St)),
                            Us($) &&
                              !$.indexOf("+=") &&
                              (~$.indexOf(" ")
                                ? ($ = (Us(it) ? it.split(" ")[0] : "") + $)
                                : ((Y = _o($.substr(2), W)),
                                  ($ = Us(it)
                                    ? it
                                    : (ct
                                        ? Nr.utils.mapRange(
                                            0,
                                            ct.duration(),
                                            ct.scrollTrigger.start,
                                            ct.scrollTrigger.end,
                                            l
                                          )
                                        : l) + Y),
                                  (nt = J))),
                            $ = Es($, "end", St),
                            c =
                              Math.max(
                                l,
                                Yo(
                                  $ || (nt ? "100% 0" : X),
                                  nt,
                                  W,
                                  dt,
                                  Ct() + Y,
                                  h,
                                  p,
                                  St,
                                  j,
                                  bt,
                                  vt,
                                  X,
                                  ct,
                                  St._endClamp && "_endClamp"
                                )
                              ) || -0.001,
                            Y = 0,
                            ot = st;
                          ot--;

                        )
                          (O = (L = bo[ot]).pin) &&
                            L.start - L._pinPush <= l &&
                            !ct &&
                            L.end > 0 &&
                            ((E =
                              L.end -
                              (St._startClamp
                                ? Math.max(0, L.start)
                                : L.start)),
                            ((O === J && L.start - L._pinPush < l) ||
                              O === rt) &&
                              isNaN(it) &&
                              (Y += E * (1 - L.progress)),
                            O === Q && (K += E));
                        if (
                          ((l += Y),
                          (c += Y),
                          St._startClamp && (St._startClamp += Y),
                          St._endClamp &&
                            !ms &&
                            ((St._endClamp = c || -0.001),
                            (c = Math.min(c, Fs(ft, dt)))),
                          (g = c - l || ((l -= 0.01) && 0.001)),
                          q &&
                            (At = Nr.utils.clamp(
                              0,
                              1,
                              Nr.utils.normalize(l, c, k)
                            )),
                          (St._pinPush = K),
                          u &&
                            Y &&
                            (((E = {})[dt.a] = "+=" + Y),
                            rt && (E[dt.p] = "-=" + Ct()),
                            Nr.set([u, h], E)),
                          Q)
                        )
                          (E = ro(Q)),
                            (P = dt === Dr),
                            (A = Ct()),
                            (T = parseFloat(S(dt.a)) + K),
                            !X &&
                              c > 1 &&
                              ((H = {
                                style: (H = (
                                  gt ? zr.scrollingElement || Br : ft
                                ).style),
                                value: H["overflow" + dt.a.toUpperCase()],
                              }),
                              gt &&
                                "scroll" !==
                                  ro(Hr)["overflow" + dt.a.toUpperCase()] &&
                                (H.style["overflow" + dt.a.toUpperCase()] =
                                  "scroll")),
                            Go(Q, x, E),
                            (y = Xo(Q)),
                            (w = oo(Q, !0)),
                            (F = vt && Cr(ft, P ? wr : Dr)()),
                            tt &&
                              (((D = [tt + dt.os2, g + K + io]).t = x),
                              (ot = tt === Qs ? ao(Q, dt) + g + K : 0) &&
                                D.push(dt.d, ot + io),
                              jo(D),
                              rt &&
                                bo.forEach(function (t) {
                                  t.pin === rt &&
                                    !1 !== t.vars.pinSpacing &&
                                    (t._subPinOffset = !0);
                                }),
                              vt && Ct(k)),
                            vt &&
                              (((R = {
                                top: w.top + (P ? A - l : F) + io,
                                left: w.left + (P ? F : A - l) + io,
                                boxSizing: "border-box",
                                position: "fixed",
                              })[qs] = R["max" + eo] =
                                Math.ceil(w.width) + io),
                              (R[Ys] = R["max" + no] =
                                Math.ceil(w.height) + io),
                              (R[to] =
                                R[to + $s] =
                                R[to + Ks] =
                                R[to + Js] =
                                R[to + Zs] =
                                  "0"),
                              (R[Qs] = E[Qs]),
                              (R[Qs + $s] = E[Qs + $s]),
                              (R[Qs + Ks] = E[Qs + Ks]),
                              (R[Qs + Js] = E[Qs + Js]),
                              (R[Qs + Zs] = E[Qs + Zs]),
                              (_ = (function (t, e, n) {
                                for (
                                  var i, r = [], s = t.length, o = n ? 8 : 0;
                                  o < s;
                                  o += 2
                                )
                                  (i = t[o]),
                                    r.push(i, i in e ? e[i] : t[o + 1]);
                                return (r.t = t.t), r;
                              })(v, R, at)),
                              ms && Ct(0)),
                            n
                              ? ((N = n._initted),
                                ns(1),
                                n.render(n.duration(), !0, !0),
                                (M = S(dt.a) - T + g + K),
                                (C = Math.abs(g - M) > 1),
                                vt && C && _.splice(_.length - 2, 2),
                                n.render(0, !0, !0),
                                N || n.invalidate(!0),
                                n.parent || n.totalTime(n.totalTime()),
                                ns(0))
                              : (M = g),
                            H &&
                              (H.value
                                ? (H.style["overflow" + dt.a.toUpperCase()] =
                                    H.value)
                                : H.style.removeProperty("overflow-" + dt.a));
                        else if (J && Ct() && !ct)
                          for (w = J.parentNode; w && w !== Hr; )
                            w._pinOffset &&
                              ((l -= w._pinOffset), (c -= w._pinOffset)),
                              (w = w.parentNode);
                        B &&
                          B.forEach(function (t) {
                            return t.revert(!1, !0);
                          }),
                          (St.start = l),
                          (St.end = c),
                          (o = a = ms ? k : Ct()),
                          ct || ms || (o < k && Ct(k), (St.scroll.rec = 0)),
                          St.revert(!1, !0),
                          (Dt = ys()),
                          U && ((wt = -1), U.restart(!0)),
                          (Yr = 0),
                          n &&
                            pt &&
                            (n._initted || z) &&
                            n.progress() !== z &&
                            n.progress(z || 0, !0).render(n.time(), !0, !0),
                          (q || At !== St.progress || ct) &&
                            (n &&
                              !pt &&
                              n.totalProgress(
                                ct && l < -0.001 && !At
                                  ? Nr.utils.normalize(l, c, 0)
                                  : At,
                                !0
                              ),
                            (St.progress = q || (o - l) / g === At ? 0 : At)),
                          Q &&
                            tt &&
                            (x._pinOffset = Math.round(St.progress * M)),
                          I && I.invalidate(),
                          isNaN(V) ||
                            ((V -= Nr.getProperty(d, dt.p)),
                            (G -= Nr.getProperty(p, dt.p)),
                            Jo(d, dt, V),
                            Jo(u, dt, V - (b || 0)),
                            Jo(p, dt, G),
                            Jo(h, dt, G - (b || 0))),
                          q && !ms && St.update(),
                          !Z || ms || m || ((m = !0), Z(St), (m = !1));
                      }
                  }),
                  (St.getVelocity = function () {
                    return ((Ct() - a) / (ys() - Xr)) * 1e3 || 0;
                  }),
                  (St.endAnimation = function () {
                    Hs(St.callbackAnimation),
                      n &&
                        (I
                          ? I.progress(1)
                          : n.paused()
                          ? pt || Hs(n, St.direction < 0, 1)
                          : Hs(n, n.reversed()));
                  }),
                  (St.labelToScroll = function (t) {
                    return (
                      (n &&
                        n.labels &&
                        (l || St.refresh() || l) +
                          (n.labels[t] / n.duration()) * g) ||
                      0
                    );
                  }),
                  (St.getTrailing = function (t) {
                    var e = bo.indexOf(St),
                      n =
                        St.direction > 0
                          ? bo.slice(0, e).reverse()
                          : bo.slice(e + 1);
                    return (
                      Us(t)
                        ? n.filter(function (e) {
                            return e.vars.preventOverlaps === t;
                          })
                        : n
                    ).filter(function (t) {
                      return St.direction > 0 ? t.end <= l : t.start >= c;
                    });
                  }),
                  (St.update = function (t, e, r) {
                    if (!ct || r || t) {
                      var s,
                        u,
                        h,
                        p,
                        f,
                        m,
                        v,
                        b = !0 === ms ? k : St.scroll(),
                        S = t ? 0 : (b - l) / g,
                        D = S < 0 ? 0 : S > 1 ? 1 : S || 0,
                        R = St.progress;
                      if (
                        (e &&
                          ((a = o),
                          (o = ct ? Ct() : b),
                          ot &&
                            ((O = L), (L = n && !pt ? n.totalProgress() : D))),
                        nt &&
                          !D &&
                          Q &&
                          !Yr &&
                          !_s &&
                          bs &&
                          l < b + ((b - a) / (ys() - Xr)) * nt &&
                          (D = 1e-4),
                        D !== R && St.enabled)
                      ) {
                        if (
                          ((p =
                            (f =
                              (s = St.isActive = !!D && D < 1) !=
                              (!!R && R < 1)) || !!D != !!R),
                          (St.direction = D > R ? 1 : -1),
                          (St.progress = D),
                          p &&
                            !Yr &&
                            ((u = D && !R ? 0 : 1 === D ? 1 : 1 === R ? 2 : 3),
                            pt &&
                              ((h =
                                (!f && "none" !== yt[u + 1] && yt[u + 1]) ||
                                yt[u]),
                              (v =
                                n &&
                                ("complete" === h ||
                                  "reset" === h ||
                                  h in n)))),
                          ht &&
                            (f || v) &&
                            (v || $ || !n) &&
                            (ks(ht)
                              ? ht(St)
                              : St.getTrailing(ht).forEach(function (t) {
                                  return t.endAnimation();
                                })),
                          pt ||
                            (!I || Yr || _s
                              ? n && n.totalProgress(D, !(!Yr || (!Dt && !t)))
                              : (I._dp._time - I._start !== I._time &&
                                  I.render(I._dp._time - I._start),
                                I.resetTo
                                  ? I.resetTo(
                                      "totalProgress",
                                      D,
                                      n._tTime / n._tDur
                                    )
                                  : ((I.vars.totalProgress = D),
                                    I.invalidate().restart()))),
                          Q)
                        )
                          if ((t && tt && (x.style[tt + dt.os2] = w), vt)) {
                            if (p) {
                              if (
                                ((m =
                                  !t &&
                                  D > R &&
                                  c + 1 > b &&
                                  b + 1 >= Fs(ft, dt)),
                                at)
                              )
                                if (t || (!s && !m)) Zo(Q, x);
                                else {
                                  var F = oo(Q, !0),
                                    N = b - l;
                                  Zo(
                                    Q,
                                    Hr,
                                    F.top + (dt === Dr ? N : 0) + io,
                                    F.left + (dt === Dr ? 0 : N) + io
                                  );
                                }
                              jo(s || m ? _ : y),
                                (C && D < 1 && s) ||
                                  E(T + (1 !== D || m ? 0 : M));
                            }
                          } else E(Cs(T + M * D));
                        ot && !i.tween && !Yr && !_s && U.restart(!0),
                          q &&
                            (f || (st && D && (D < 1 || !ps))) &&
                            Wr(q.targets).forEach(function (t) {
                              return t.classList[s || st ? "add" : "remove"](
                                q.className
                              );
                            }),
                          X && !pt && !t && X(St),
                          p && !Yr
                            ? (pt &&
                                (v &&
                                  ("complete" === h
                                    ? n.pause().totalProgress(1)
                                    : "reset" === h
                                    ? n.restart(!0).pause()
                                    : "restart" === h
                                    ? n.restart(!0)
                                    : n[h]()),
                                X && X(St)),
                              (!f && ps) ||
                                (K && f && Vs(St, K),
                                _t[u] && Vs(St, _t[u]),
                                st && (1 === D ? St.kill(!1, 1) : (_t[u] = 0)),
                                f ||
                                  (_t[(u = 1 === D ? 1 : 3)] && Vs(St, _t[u]))),
                              ut &&
                                !s &&
                                Math.abs(St.getVelocity()) >
                                  (zs(ut) ? ut : 2500) &&
                                (Hs(St.callbackAnimation),
                                I
                                  ? I.progress(1)
                                  : Hs(n, "reverse" === h ? 1 : !D, 1)))
                            : pt && X && !Yr && X(St);
                      }
                      if (P) {
                        var z = ct
                          ? (b / ct.duration()) * (ct._caScrollDist || 0)
                          : b;
                        A(z + (d._isFlipped ? 1 : 0)), P(z);
                      }
                      B && B((-b / ct.duration()) * (ct._caScrollDist || 0));
                    }
                  }),
                  (St.enable = function (e, n) {
                    St.enabled ||
                      ((St.enabled = !0),
                      ho(ft, "resize", wo),
                      gt || ho(ft, "scroll", To),
                      Et && ho(t, "refreshInit", Et),
                      !1 !== e && ((St.progress = At = 0), (o = a = wt = Ct())),
                      !1 !== n && St.refresh());
                  }),
                  (St.getTween = function (t) {
                    return t && i ? i.tween : I;
                  }),
                  (St.setPositions = function (t, e, n, i) {
                    if (ct) {
                      var r = ct.scrollTrigger,
                        s = ct.duration(),
                        o = r.end - r.start;
                      (t = r.start + (o * t) / s), (e = r.start + (o * e) / s);
                    }
                    St.refresh(
                      !1,
                      !1,
                      {
                        start: Ts(t, n && !!St._startClamp),
                        end: Ts(e, n && !!St._endClamp),
                      },
                      i
                    ),
                      St.update();
                  }),
                  (St.adjustPinSpacing = function (t) {
                    if (D && t) {
                      var e = D.indexOf(dt.d) + 1;
                      (D[e] = parseFloat(D[e]) + t + io),
                        (D[1] = parseFloat(D[1]) + t + io),
                        jo(D);
                    }
                  }),
                  (St.disable = function (e, n) {
                    if (
                      St.enabled &&
                      (!1 !== e && St.revert(!0, !0),
                      (St.enabled = St.isActive = !1),
                      n || (I && I.pause()),
                      (k = 0),
                      r && (r.uncache = 1),
                      Et && po(t, "refreshInit", Et),
                      U &&
                        (U.pause(), i.tween && i.tween.kill() && (i.tween = 0)),
                      !gt)
                    ) {
                      for (var s = bo.length; s--; )
                        if (bo[s].scroller === ft && bo[s] !== St) return;
                      po(ft, "resize", wo), gt || po(ft, "scroll", To);
                    }
                  }),
                  (St.kill = function (t, i) {
                    St.disable(t, i), I && !i && I.kill(), Y && delete So[Y];
                    var s = bo.indexOf(St);
                    s >= 0 && bo.splice(s, 1),
                      s === $r && zo > 0 && $r--,
                      (s = 0),
                      bo.forEach(function (t) {
                        return t.scroller === St.scroller && (s = 1);
                      }),
                      s || ms || (St.scroll.rec = 0),
                      n &&
                        ((n.scrollTrigger = null),
                        t &&
                          n.revert({
                            kill: !1,
                          }),
                        i || n.kill()),
                      u &&
                        [u, h, d, p].forEach(function (t) {
                          return t.parentNode && t.parentNode.removeChild(t);
                        }),
                      vs === St && (vs = 0),
                      Q &&
                        (r && (r.uncache = 1),
                        (s = 0),
                        bo.forEach(function (t) {
                          return t.pin === Q && s++;
                        }),
                        s || (r.spacer = 0)),
                      e.onKill && e.onKill(St);
                  }),
                  bo.push(St),
                  St.enable(!1, !1),
                  H && H(St),
                  n && n.add && !g)
                ) {
                  var Ot = St.update;
                  (St.update = function () {
                    (St.update = Ot), l || c || St.refresh();
                  }),
                    Nr.delayedCall(0.01, St.update),
                    (g = 0.01),
                    (l = c = 0);
                } else St.refresh();
                Q &&
                  (function () {
                    if (gs !== Fo) {
                      var t = (gs = Fo);
                      requestAnimationFrame(function () {
                        return t === Fo && Uo(!0);
                      });
                    }
                  })();
              } else this.update = this.refresh = this.kill = As;
            }),
            (t.register = function (e) {
              return (
                Ur ||
                  ((Nr = e || Rs()),
                  Ps() && window.document && t.enable(),
                  (Ur = Ss)),
                Ur
              );
            }),
            (t.defaults = function (t) {
              if (t) for (var e in t) go[e] = t[e];
              return go;
            }),
            (t.disable = function (t, e) {
              (Ss = 0),
                bo.forEach(function (n) {
                  return n[e ? "kill" : "disable"](t);
                }),
                po(kr, "wheel", To),
                po(zr, "scroll", To),
                clearInterval(qr),
                po(zr, "touchcancel", As),
                po(Hr, "touchstart", As),
                uo(po, zr, "pointerdown,touchstart,mousedown", ws),
                uo(po, zr, "pointerup,touchend,mouseup", Ds),
                Gr.kill(),
                Ns(po);
              for (var n = 0; n < fr.length; n += 3)
                fo(po, fr[n], fr[n + 1]), fo(po, fr[n], fr[n + 2]);
            }),
            (t.enable = function () {
              if (
                ((kr = window),
                (zr = document),
                (Br = zr.documentElement),
                (Hr = zr.body),
                Nr &&
                  ((Wr = Nr.utils.toArray),
                  (jr = Nr.utils.clamp),
                  (cs = Nr.core.context || As),
                  (ns = Nr.core.suppressOverwrites || As),
                  (us = kr.history.scrollRestoration || "auto"),
                  (ko = kr.pageYOffset),
                  Nr.core.globals("ScrollTrigger", t),
                  Hr))
              ) {
                (Ss = 1),
                  ((hs = document.createElement("div")).style.height = "100vh"),
                  (hs.style.position = "absolute"),
                  No(),
                  Ms(),
                  Fr.register(Nr),
                  (t.isTouch = Fr.isTouch),
                  (ls =
                    Fr.isTouch &&
                    /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent)),
                  ho(kr, "wheel", To),
                  (Vr = [kr, zr, Br, Hr]),
                  Nr.matchMedia
                    ? ((t.matchMedia = function (t) {
                        var e,
                          n = Nr.matchMedia();
                        for (e in t) n.add(e, t[e]);
                        return n;
                      }),
                      Nr.addEventListener("matchMediaInit", function () {
                        return Oo();
                      }),
                      Nr.addEventListener("matchMediaRevert", function () {
                        return Lo();
                      }),
                      Nr.addEventListener("matchMedia", function () {
                        Uo(0, 1), Po("matchMedia");
                      }),
                      Nr.matchMedia("(orientation: portrait)", function () {
                        return Mo(), Mo;
                      }))
                    : console.warn("Requires GSAP 3.11.0 or later"),
                  Mo(),
                  ho(zr, "scroll", To);
                var e,
                  n,
                  i = Hr.style,
                  r = i.borderTopStyle,
                  s = Nr.core.Animation.prototype;
                for (
                  s.revert ||
                    Object.defineProperty(s, "revert", {
                      value: function () {
                        return this.time(-0.01, !0);
                      },
                    }),
                    i.borderTopStyle = "solid",
                    e = oo(Hr),
                    Dr.m = Math.round(e.top + Dr.sc()) || 0,
                    wr.m = Math.round(e.left + wr.sc()) || 0,
                    r
                      ? (i.borderTopStyle = r)
                      : i.removeProperty("border-top-style"),
                    qr = setInterval(Eo, 250),
                    Nr.delayedCall(0.5, function () {
                      return (_s = 0);
                    }),
                    ho(zr, "touchcancel", As),
                    ho(Hr, "touchstart", As),
                    uo(ho, zr, "pointerdown,touchstart,mousedown", ws),
                    uo(ho, zr, "pointerup,touchend,mouseup", Ds),
                    Zr = Nr.utils.checkPrefix("transform"),
                    Vo.push(Zr),
                    Ur = ys(),
                    Gr = Nr.delayedCall(0.2, Uo).pause(),
                    ts = [
                      zr,
                      "visibilitychange",
                      function () {
                        var t = kr.innerWidth,
                          e = kr.innerHeight;
                        zr.hidden
                          ? ((Jr = t), (Qr = e))
                          : (Jr === t && Qr === e) || wo();
                      },
                      zr,
                      "DOMContentLoaded",
                      Uo,
                      kr,
                      "load",
                      Uo,
                      kr,
                      "resize",
                      wo,
                    ],
                    Ns(ho),
                    bo.forEach(function (t) {
                      return t.enable(0, 1);
                    }),
                    n = 0;
                  n < fr.length;
                  n += 3
                )
                  fo(po, fr[n], fr[n + 1]), fo(po, fr[n], fr[n + 2]);
              }
            }),
            (t.config = function (e) {
              "limitCallbacks" in e && (ps = !!e.limitCallbacks);
              var n = e.syncInterval;
              (n && clearInterval(qr)) || ((qr = n) && setInterval(Eo, n)),
                "ignoreMobileResize" in e &&
                  (ss = 1 === t.isTouch && e.ignoreMobileResize),
                "autoRefreshEvents" in e &&
                  (Ns(po) || Ns(ho, e.autoRefreshEvents || "none"),
                  (is = -1 === (e.autoRefreshEvents + "").indexOf("resize")));
            }),
            (t.scrollerProxy = function (t, e) {
              var n = Ar(t),
                i = fr.indexOf(n),
                r = Ls(n);
              ~i && fr.splice(i, r ? 6 : 2),
                e && (r ? mr.unshift(kr, e, Hr, e, Br, e) : mr.unshift(n, e));
            }),
            (t.clearMatchMedia = function (t) {
              bo.forEach(function (e) {
                return e._ctx && e._ctx.query === t && e._ctx.kill(!0, !0);
              });
            }),
            (t.isInViewport = function (t, e, n) {
              var i = (Us(t) ? Ar(t) : t).getBoundingClientRect(),
                r = i[n ? qs : Ys] * e || 0;
              return n
                ? i.right - r > 0 && i.left + r < kr.innerWidth
                : i.bottom - r > 0 && i.top + r < kr.innerHeight;
            }),
            (t.positionInViewport = function (t, e, n) {
              Us(t) && (t = Ar(t));
              var i = t.getBoundingClientRect(),
                r = i[n ? qs : Ys],
                s =
                  null == e
                    ? r / 2
                    : e in vo
                    ? vo[e] * r
                    : ~e.indexOf("%")
                    ? (parseFloat(e) * r) / 100
                    : parseFloat(e) || 0;
              return n
                ? (i.left + s) / kr.innerWidth
                : (i.top + s) / kr.innerHeight;
            }),
            (t.killAll = function (t) {
              if (
                (bo.slice(0).forEach(function (t) {
                  return "ScrollSmoother" !== t.vars.id && t.kill();
                }),
                !0 !== t)
              ) {
                var e = Do.killAll || [];
                (Do = {}),
                  e.forEach(function (t) {
                    return t();
                  });
              }
            }),
            t
          );
        })();
      (ta.version = "3.12.2"),
        (ta.saveStyles = function (t) {
          return t
            ? Wr(t).forEach(function (t) {
                if (t && t.style) {
                  var e = Ro.indexOf(t);
                  e >= 0 && Ro.splice(e, 5),
                    Ro.push(
                      t,
                      t.style.cssText,
                      t.getBBox && t.getAttribute("transform"),
                      Nr.core.getCache(t),
                      cs()
                    );
                }
              })
            : Ro;
        }),
        (ta.revert = function (t, e) {
          return Oo(!t, e);
        }),
        (ta.create = function (t, e) {
          return new ta(t, e);
        }),
        (ta.refresh = function (t) {
          return t ? wo() : (Ur || ta.register()) && Uo(!0);
        }),
        (ta.update = function (t) {
          return ++fr.cache && Bo(!0 === t ? 2 : 0);
        }),
        (ta.clearScrollMemory = Io),
        (ta.maxScroll = function (t, e) {
          return Fs(t, e ? wr : Dr);
        }),
        (ta.getScrollFunc = function (t, e) {
          return Cr(Ar(t), e ? wr : Dr);
        }),
        (ta.getById = function (t) {
          return So[t];
        }),
        (ta.getAll = function () {
          return bo.filter(function (t) {
            return "ScrollSmoother" !== t.vars.id;
          });
        }),
        (ta.isScrolling = function () {
          return !!bs;
        }),
        (ta.snapDirectional = co),
        (ta.addEventListener = function (t, e) {
          var n = Do[t] || (Do[t] = []);
          ~n.indexOf(e) || n.push(e);
        }),
        (ta.removeEventListener = function (t, e) {
          var n = Do[t],
            i = n && n.indexOf(e);
          i >= 0 && n.splice(i, 1);
        }),
        (ta.batch = function (t, e) {
          var n,
            i = [],
            r = {},
            s = e.interval || 0.016,
            o = e.batchMax || 1e9,
            a = function (t, e) {
              var n = [],
                i = [],
                r = Nr.delayedCall(s, function () {
                  e(n, i), (n = []), (i = []);
                }).pause();
              return function (t) {
                n.length || r.restart(!0),
                  n.push(t.trigger),
                  i.push(t),
                  o <= n.length && r.progress(1);
              };
            };
          for (n in e)
            r[n] =
              "on" === n.substr(0, 2) && ks(e[n]) && "onRefreshInit" !== n
                ? a(0, e[n])
                : e[n];
          return (
            ks(o) &&
              ((o = o()),
              ho(ta, "refresh", function () {
                return (o = e.batchMax());
              })),
            Wr(t).forEach(function (t) {
              var e = {};
              for (n in r) e[n] = r[n];
              (e.trigger = t), i.push(ta.create(e));
            }),
            i
          );
        });
      var ea,
        na = function (t, e, n, i) {
          return (
            e > i ? t(i) : e < 0 && t(0),
            n > i ? (i - e) / (n - e) : n < 0 ? e / (e - n) : 1
          );
        },
        ia = function t(e, n) {
          !0 === n
            ? e.style.removeProperty("touch-action")
            : (e.style.touchAction =
                !0 === n
                  ? "auto"
                  : n
                  ? "pan-" + n + (Fr.isTouch ? " pinch-zoom" : "")
                  : "none"),
            e === Br && t(Hr, n);
        },
        ra = {
          auto: 1,
          scroll: 1,
        },
        sa = function (t) {
          var e,
            n = t.event,
            i = t.target,
            r = t.axis,
            s = (n.changedTouches ? n.changedTouches[0] : n).target,
            o = s._gsap || Nr.core.getCache(s),
            a = ys();
          if (!o._isScrollT || a - o._isScrollT > 2e3) {
            for (
              ;
              s &&
              s !== Hr &&
              ((s.scrollHeight <= s.clientHeight &&
                s.scrollWidth <= s.clientWidth) ||
                (!ra[(e = ro(s)).overflowY] && !ra[e.overflowX]));

            )
              s = s.parentNode;
            (o._isScroll =
              s &&
              s !== i &&
              !Ls(s) &&
              (ra[(e = ro(s)).overflowY] || ra[e.overflowX])),
              (o._isScrollT = a);
          }
          (o._isScroll || "x" === r) &&
            (n.stopPropagation(), (n._gsapAllow = !0));
        },
        oa = function (t, e, n, i) {
          return Fr.create({
            target: t,
            capture: !0,
            debounce: !1,
            lockAxis: !0,
            type: e,
            onWheel: (i = i && sa),
            onPress: i,
            onDrag: i,
            onScroll: i,
            onEnable: function () {
              return n && ho(zr, Fr.eventTypes[0], la, !1, !0);
            },
            onDisable: function () {
              return po(zr, Fr.eventTypes[0], la, !0);
            },
          });
        },
        aa = /(input|label|select|textarea)/i,
        la = function (t) {
          var e = aa.test(t.target.tagName);
          (e || ea) && ((t._gsapAllow = !0), (ea = e));
        };
      (ta.sort = function (t) {
        return bo.sort(
          t ||
            function (t, e) {
              return (
                -1e6 * (t.vars.refreshPriority || 0) +
                t.start -
                (e.start + -1e6 * (e.vars.refreshPriority || 0))
              );
            }
        );
      }),
        (ta.observe = function (t) {
          return new Fr(t);
        }),
        (ta.normalizeScroll = function (t) {
          if (void 0 === t) return rs;
          if (!0 === t && rs) return rs.enable();
          if (!1 === t) return rs && rs.kill();
          var e =
            t instanceof Fr
              ? t
              : (function (t) {
                  Bs(t) || (t = {}),
                    (t.preventDefault = t.isNormalizer = t.allowClicks = !0),
                    t.type || (t.type = "wheel,touch"),
                    (t.debounce = !!t.debounce),
                    (t.id = t.id || "normalizer");
                  var e,
                    n,
                    i,
                    r,
                    s,
                    o,
                    a,
                    l,
                    c = t,
                    u = c.normalizeScrollX,
                    h = c.momentum,
                    d = c.allowNestedScroll,
                    p = c.onRelease,
                    f = Ar(t.target) || Br,
                    m = Nr.core.globals().ScrollSmoother,
                    g = m && m.get(),
                    v =
                      ls &&
                      ((t.content && Ar(t.content)) ||
                        (g && !1 !== t.content && !g.smooth() && g.content())),
                    _ = Cr(f, Dr),
                    y = Cr(f, wr),
                    x = 1,
                    b =
                      (Fr.isTouch && kr.visualViewport
                        ? kr.visualViewport.scale * kr.visualViewport.width
                        : kr.outerWidth) / kr.innerWidth,
                    S = 0,
                    E = ks(h)
                      ? function () {
                          return h(e);
                        }
                      : function () {
                          return h || 2.8;
                        },
                    T = oa(f, t.type, !0, d),
                    M = function () {
                      return (r = !1);
                    },
                    w = As,
                    D = As,
                    A = function () {
                      (n = Fs(f, Dr)),
                        (D = jr(ls ? 1 : 0, n)),
                        u && (w = jr(0, Fs(f, wr))),
                        (i = Fo);
                    },
                    C = function () {
                      (v._gsap.y = Cs(parseFloat(v._gsap.y) + _.offset) + "px"),
                        (v.style.transform =
                          "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " +
                          parseFloat(v._gsap.y) +
                          ", 0, 1)"),
                        (_.offset = _.cacheID = 0);
                    },
                    P = function () {
                      A(),
                        s.isActive() &&
                          s.vars.scrollY > n &&
                          (_() > n
                            ? s.progress(1) && _(n)
                            : s.resetTo("scrollY", n));
                    };
                  return (
                    v &&
                      Nr.set(v, {
                        y: "+=0",
                      }),
                    (t.ignoreCheck = function (t) {
                      return (
                        (ls &&
                          "touchmove" === t.type &&
                          (function () {
                            if (r) {
                              requestAnimationFrame(M);
                              var t = Cs(e.deltaY / 2),
                                n = D(_.v - t);
                              if (v && n !== _.v + _.offset) {
                                _.offset = n - _.v;
                                var i = Cs(
                                  (parseFloat(v && v._gsap.y) || 0) - _.offset
                                );
                                (v.style.transform =
                                  "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " +
                                  i +
                                  ", 0, 1)"),
                                  (v._gsap.y = i + "px"),
                                  (_.cacheID = fr.cache),
                                  Bo();
                              }
                              return !0;
                            }
                            _.offset && C(), (r = !0);
                          })()) ||
                        (x > 1.05 && "touchstart" !== t.type) ||
                        e.isGesturing ||
                        (t.touches && t.touches.length > 1)
                      );
                    }),
                    (t.onPress = function () {
                      r = !1;
                      var t = x;
                      (x = Cs(
                        ((kr.visualViewport && kr.visualViewport.scale) || 1) /
                          b
                      )),
                        s.pause(),
                        t !== x && ia(f, x > 1.01 || (!u && "x")),
                        (o = y()),
                        (a = _()),
                        A(),
                        (i = Fo);
                    }),
                    (t.onRelease = t.onGestureStart =
                      function (t, e) {
                        if ((_.offset && C(), e)) {
                          fr.cache++;
                          var i,
                            r,
                            o = E();
                          u &&
                            ((r =
                              (i = y()) + (0.05 * o * -t.velocityX) / 0.227),
                            (o *= na(y, i, r, Fs(f, wr))),
                            (s.vars.scrollX = w(r))),
                            (r = (i = _()) + (0.05 * o * -t.velocityY) / 0.227),
                            (o *= na(_, i, r, Fs(f, Dr))),
                            (s.vars.scrollY = D(r)),
                            s.invalidate().duration(o).play(0.01),
                            ((ls && s.vars.scrollY >= n) || i >= n - 1) &&
                              Nr.to(
                                {},
                                {
                                  onUpdate: P,
                                  duration: o,
                                }
                              );
                        } else l.restart(!0);
                        p && p(t);
                      }),
                    (t.onWheel = function () {
                      s._ts && s.pause(),
                        ys() - S > 1e3 && ((i = 0), (S = ys()));
                    }),
                    (t.onChange = function (t, e, n, r, s) {
                      if (
                        (Fo !== i && A(),
                        e &&
                          u &&
                          y(
                            w(
                              r[2] === e ? o + (t.startX - t.x) : y() + e - r[1]
                            )
                          ),
                        n)
                      ) {
                        _.offset && C();
                        var l = s[2] === n,
                          c = l ? a + t.startY - t.y : _() + n - s[1],
                          h = D(c);
                        l && c !== h && (a += h - c), _(h);
                      }
                      (n || e) && Bo();
                    }),
                    (t.onEnable = function () {
                      ia(f, !u && "x"),
                        ta.addEventListener("refresh", P),
                        ho(kr, "resize", P),
                        _.smooth &&
                          ((_.target.style.scrollBehavior = "auto"),
                          (_.smooth = y.smooth = !1)),
                        T.enable();
                    }),
                    (t.onDisable = function () {
                      ia(f, !0),
                        po(kr, "resize", P),
                        ta.removeEventListener("refresh", P),
                        T.kill();
                    }),
                    (t.lockAxis = !1 !== t.lockAxis),
                    ((e = new Fr(t)).iOS = ls),
                    ls && !_() && _(1),
                    ls && Nr.ticker.add(As),
                    (l = e._dc),
                    (s = Nr.to(e, {
                      ease: "power4",
                      paused: !0,
                      scrollX: u ? "+=0.1" : "+=0",
                      scrollY: "+=0.1",
                      modifiers: {
                        scrollY: $o(_, _(), function () {
                          return s.pause();
                        }),
                      },
                      onUpdate: Bo,
                      onComplete: l.vars.onComplete,
                    })),
                    e
                  );
                })(t);
          return (
            rs && rs.target === e.target && rs.kill(),
            Ls(e.target) && (rs = e),
            e
          );
        }),
        (ta.core = {
          _getVelocityProp: Pr,
          _inputObserver: oa,
          _scrollers: fr,
          _proxies: mr,
          bridge: {
            ss: function () {
              bs || Po("scrollStart"), (bs = ys());
            },
            ref: function () {
              return Yr;
            },
          },
        }),
        Rs() && Nr.registerPlugin(ta);
      var ca,
        ua,
        ha,
        da,
        pa,
        fa,
        ma,
        ga,
        va = function () {
          return "undefined" != typeof window;
        },
        _a = function () {
          return ca || (va() && (ca = window.gsap) && ca.registerPlugin && ca);
        },
        ya = function (t) {
          return "string" == typeof t;
        },
        xa = function (t) {
          return "function" == typeof t;
        },
        ba = function (t, e) {
          var n = "x" === e ? "Width" : "Height",
            i = "scroll" + n,
            r = "client" + n;
          return t === ha || t === da || t === pa
            ? Math.max(da[i], pa[i]) - (ha["inner" + n] || da[r] || pa[r])
            : t[i] - t["offset" + n];
        },
        Sa = function (t, e) {
          var n = "scroll" + ("x" === e ? "Left" : "Top");
          return (
            t === ha &&
              (null != t.pageXOffset
                ? (n = "page" + e.toUpperCase() + "Offset")
                : (t = null != da[n] ? da : pa)),
            function () {
              return t[n];
            }
          );
        },
        Ea = function (t, e) {
          if (!(t = fa(t)[0]) || !t.getBoundingClientRect)
            return (
              console.warn("scrollTo target doesn't exist. Using 0") || {
                x: 0,
                y: 0,
              }
            );
          var n = t.getBoundingClientRect(),
            i = !e || e === ha || e === pa,
            r = i
              ? {
                  top:
                    da.clientTop -
                    (ha.pageYOffset || da.scrollTop || pa.scrollTop || 0),
                  left:
                    da.clientLeft -
                    (ha.pageXOffset || da.scrollLeft || pa.scrollLeft || 0),
                }
              : e.getBoundingClientRect(),
            s = {
              x: n.left - r.left,
              y: n.top - r.top,
            };
          return !i && e && ((s.x += Sa(e, "x")()), (s.y += Sa(e, "y")())), s;
        },
        Ta = function (t, e, n, i, r) {
          return isNaN(t) || "object" == typeof t
            ? ya(t) && "=" === t.charAt(1)
              ? parseFloat(t.substr(2)) * ("-" === t.charAt(0) ? -1 : 1) + i - r
              : "max" === t
              ? ba(e, n) - r
              : Math.min(ba(e, n), Ea(t, e)[n] - r)
            : parseFloat(t) - r;
        },
        Ma = function () {
          (ca = _a()),
            va() &&
              ca &&
              "undefined" != typeof document &&
              document.body &&
              ((ha = window),
              (pa = document.body),
              (da = document.documentElement),
              (fa = ca.utils.toArray),
              ca.config({
                autoKillThreshold: 7,
              }),
              (ma = ca.config()),
              (ua = 1));
        },
        wa = {
          version: "3.12.2",
          name: "scrollTo",
          rawVars: 1,
          register: function (t) {
            (ca = t), Ma();
          },
          init: function (t, e, n, i, r) {
            ua || Ma();
            var s = this,
              o = ca.getProperty(t, "scrollSnapType");
            (s.isWin = t === ha),
              (s.target = t),
              (s.tween = n),
              (e = (function (t, e, n, i) {
                if ((xa(t) && (t = t(e, n, i)), "object" != typeof t))
                  return ya(t) && "max" !== t && "=" !== t.charAt(1)
                    ? {
                        x: t,
                        y: t,
                      }
                    : {
                        y: t,
                      };
                if (t.nodeType)
                  return {
                    y: t,
                    x: t,
                  };
                var r,
                  s = {};
                for (r in t)
                  s[r] = "onAutoKill" !== r && xa(t[r]) ? t[r](e, n, i) : t[r];
                return s;
              })(e, i, t, r)),
              (s.vars = e),
              (s.autoKill = !!e.autoKill),
              (s.getX = Sa(t, "x")),
              (s.getY = Sa(t, "y")),
              (s.x = s.xPrev = s.getX()),
              (s.y = s.yPrev = s.getY()),
              ga || (ga = ca.core.globals().ScrollTrigger),
              "smooth" === ca.getProperty(t, "scrollBehavior") &&
                ca.set(t, {
                  scrollBehavior: "auto",
                }),
              o &&
                "none" !== o &&
                ((s.snap = 1),
                (s.snapInline = t.style.scrollSnapType),
                (t.style.scrollSnapType = "none")),
              null != e.x
                ? (s.add(
                    s,
                    "x",
                    s.x,
                    Ta(e.x, t, "x", s.x, e.offsetX || 0),
                    i,
                    r
                  ),
                  s._props.push("scrollTo_x"))
                : (s.skipX = 1),
              null != e.y
                ? (s.add(
                    s,
                    "y",
                    s.y,
                    Ta(e.y, t, "y", s.y, e.offsetY || 0),
                    i,
                    r
                  ),
                  s._props.push("scrollTo_y"))
                : (s.skipY = 1);
          },
          render: function (t, e) {
            for (
              var n,
                i,
                r,
                s,
                o,
                a = e._pt,
                l = e.target,
                c = e.tween,
                u = e.autoKill,
                h = e.xPrev,
                d = e.yPrev,
                p = e.isWin,
                f = e.snap,
                m = e.snapInline;
              a;

            )
              a.r(t, a.d), (a = a._next);
            (n = p || !e.skipX ? e.getX() : h),
              (r = (i = p || !e.skipY ? e.getY() : d) - d),
              (s = n - h),
              (o = ma.autoKillThreshold),
              e.x < 0 && (e.x = 0),
              e.y < 0 && (e.y = 0),
              u &&
                (!e.skipX &&
                  (s > o || s < -o) &&
                  n < ba(l, "x") &&
                  (e.skipX = 1),
                !e.skipY &&
                  (r > o || r < -o) &&
                  i < ba(l, "y") &&
                  (e.skipY = 1),
                e.skipX &&
                  e.skipY &&
                  (c.kill(),
                  e.vars.onAutoKill &&
                    e.vars.onAutoKill.apply(c, e.vars.onAutoKillParams || []))),
              p
                ? ha.scrollTo(e.skipX ? n : e.x, e.skipY ? i : e.y)
                : (e.skipY || (l.scrollTop = e.y),
                  e.skipX || (l.scrollLeft = e.x)),
              !f ||
                (1 !== t && 0 !== t) ||
                ((i = l.scrollTop),
                (n = l.scrollLeft),
                m
                  ? (l.style.scrollSnapType = m)
                  : l.style.removeProperty("scroll-snap-type"),
                (l.scrollTop = i + 1),
                (l.scrollLeft = n + 1),
                (l.scrollTop = i),
                (l.scrollLeft = n)),
              (e.xPrev = e.x),
              (e.yPrev = e.y),
              ga && ga.update();
          },
          kill: function (t) {
            var e = "scrollTo" === t;
            (e || "scrollTo_x" === t) && (this.skipX = 1),
              (e || "scrollTo_y" === t) && (this.skipY = 1);
          },
        };
      (wa.max = ba),
        (wa.getOffset = Ea),
        (wa.buildGetter = Sa),
        _a() && ca.registerPlugin(wa);
      var Da = function (t, e) {
          return (
            (Da =
              Object.setPrototypeOf ||
              ({
                __proto__: [],
              } instanceof Array &&
                function (t, e) {
                  t.__proto__ = e;
                }) ||
              function (t, e) {
                for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
              }),
            Da(t, e)
          );
        },
        Aa = function () {
          return (
            (Aa =
              Object.assign ||
              function (t) {
                for (var e, n = 1, i = arguments.length; n < i; n++)
                  for (var r in (e = arguments[n]))
                    Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
                return t;
              }),
            Aa.apply(this, arguments)
          );
        };
      function Ca(t, e, n, i) {
        var r,
          s = arguments.length,
          o =
            s < 3
              ? e
              : null === i
              ? (i = Object.getOwnPropertyDescriptor(e, n))
              : i;
        if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
          o = Reflect.decorate(t, e, n, i);
        else
          for (var a = t.length - 1; a >= 0; a--)
            (r = t[a]) &&
              (o = (s < 3 ? r(o) : s > 3 ? r(e, n, o) : r(e, n)) || o);
        return s > 3 && o && Object.defineProperty(e, n, o), o;
      }
      function Pa() {
        for (var t = 0, e = 0, n = arguments.length; e < n; e++)
          t += arguments[e].length;
        var i = Array(t),
          r = 0;
        for (e = 0; e < n; e++)
          for (var s = arguments[e], o = 0, a = s.length; o < a; o++, r++)
            i[r] = s[o];
        return i;
      }
      n(3662), n(8188), n(9074), n(4370), n(9116);
      var Ra,
        La = new WeakMap();
      function Oa() {
        if (void 0 !== Ra) return Ra;
        var t = !1;
        try {
          var e = function () {},
            n = Object.defineProperty({}, "passive", {
              enumerable: !0,
              get: function () {
                return (t = !0), !0;
              },
            });
          window.addEventListener("testPassive", e, n),
            window.removeEventListener("testPassive", e, n);
        } catch (t) {}
        return (Ra = !!t && {
          passive: !1,
        });
      }
      function Ia(t) {
        var e = La.get(t) || [];
        return (
          La.set(t, e),
          function (t, n, i) {
            function r(t) {
              t.defaultPrevented || i(t);
            }
            n.split(/\s+/g).forEach(function (n) {
              e.push({
                elem: t,
                eventName: n,
                handler: r,
              }),
                t.addEventListener(n, r, Oa());
            });
          }
        );
      }
      function Fa(t) {
        var e = (function (t) {
          return t.touches ? t.touches[t.touches.length - 1] : t;
        })(t);
        return {
          x: e.clientX,
          y: e.clientY,
        };
      }
      function Na(t, e) {
        return (
          void 0 === e && (e = []),
          e.some(function (e) {
            return t === e;
          })
        );
      }
      var Ua = ["webkit", "moz", "ms", "o"],
        ka = new RegExp("^-(?!(?:" + Ua.join("|") + ")-)");
      function za(t, e) {
        (e = (function (t) {
          var e = {};
          return (
            Object.keys(t).forEach(function (n) {
              if (ka.test(n)) {
                var i = t[n];
                (n = n.replace(/^-/, "")),
                  (e[n] = i),
                  Ua.forEach(function (t) {
                    e["-" + t + "-" + n] = i;
                  });
              } else e[n] = t[n];
            }),
            e
          );
        })(e)),
          Object.keys(e).forEach(function (n) {
            var i = n.replace(/^-/, "").replace(/-([a-z])/g, function (t, e) {
              return e.toUpperCase();
            });
            t.style[i] = e[n];
          });
      }
      var Ba = (function () {
          function t(t) {
            (this.velocityMultiplier = window.devicePixelRatio),
              (this.updateTime = Date.now()),
              (this.delta = {
                x: 0,
                y: 0,
              }),
              (this.velocity = {
                x: 0,
                y: 0,
              }),
              (this.lastPosition = {
                x: 0,
                y: 0,
              }),
              (this.lastPosition = Fa(t));
          }
          return (
            (t.prototype.update = function (t) {
              var e = this,
                n = e.velocity,
                i = e.updateTime,
                r = e.lastPosition,
                s = Date.now(),
                o = Fa(t),
                a = {
                  x: -(o.x - r.x),
                  y: -(o.y - r.y),
                },
                l = s - i || 16.7,
                c = (a.x / l) * 16.7,
                u = (a.y / l) * 16.7;
              (n.x = c * this.velocityMultiplier),
                (n.y = u * this.velocityMultiplier),
                (this.delta = a),
                (this.updateTime = s),
                (this.lastPosition = o);
            }),
            t
          );
        })(),
        Ha = (function () {
          function t() {
            this._touchList = {};
          }
          return (
            Object.defineProperty(t.prototype, "_primitiveValue", {
              get: function () {
                return {
                  x: 0,
                  y: 0,
                };
              },
              enumerable: !0,
              configurable: !0,
            }),
            (t.prototype.isActive = function () {
              return void 0 !== this._activeTouchID;
            }),
            (t.prototype.getDelta = function () {
              var t = this._getActiveTracker();
              return t ? Aa({}, t.delta) : this._primitiveValue;
            }),
            (t.prototype.getVelocity = function () {
              var t = this._getActiveTracker();
              return t ? Aa({}, t.velocity) : this._primitiveValue;
            }),
            (t.prototype.getEasingDistance = function (t) {
              var e = 1 - t,
                n = {
                  x: 0,
                  y: 0,
                },
                i = this.getVelocity();
              return (
                Object.keys(i).forEach(function (t) {
                  for (var r = Math.abs(i[t]) <= 10 ? 0 : i[t]; 0 !== r; )
                    (n[t] += r), (r = (r * e) | 0);
                }),
                n
              );
            }),
            (t.prototype.track = function (t) {
              var e = this,
                n = t.targetTouches;
              return (
                Array.from(n).forEach(function (t) {
                  e._add(t);
                }),
                this._touchList
              );
            }),
            (t.prototype.update = function (t) {
              var e = this,
                n = t.touches,
                i = t.changedTouches;
              return (
                Array.from(n).forEach(function (t) {
                  e._renew(t);
                }),
                this._setActiveID(i),
                this._touchList
              );
            }),
            (t.prototype.release = function (t) {
              var e = this;
              delete this._activeTouchID,
                Array.from(t.changedTouches).forEach(function (t) {
                  e._delete(t);
                });
            }),
            (t.prototype._add = function (t) {
              this._has(t) && this._delete(t);
              var e = new Ba(t);
              this._touchList[t.identifier] = e;
            }),
            (t.prototype._renew = function (t) {
              this._has(t) && this._touchList[t.identifier].update(t);
            }),
            (t.prototype._delete = function (t) {
              delete this._touchList[t.identifier];
            }),
            (t.prototype._has = function (t) {
              return this._touchList.hasOwnProperty(t.identifier);
            }),
            (t.prototype._setActiveID = function (t) {
              this._activeTouchID = t[t.length - 1].identifier;
            }),
            (t.prototype._getActiveTracker = function () {
              return this._touchList[this._activeTouchID];
            }),
            t
          );
        })();
      function Va(t, e, n) {
        return Math.max(e, Math.min(n, t));
      }
      function Ga(t, e, n) {
        var i;
        void 0 === e && (e = 0);
        var r = -1 / 0;
        return function () {
          for (var s = this, o = [], a = 0; a < arguments.length; a++)
            o[a] = arguments[a];
          if (n) {
            var l = Date.now(),
              c = l - r;
            (r = l), c >= e && t.apply(this, o);
          }
          clearTimeout(i),
            (i = setTimeout(function () {
              t.apply(s, o);
            }, e));
        };
      }
      function Wa(t, e) {
        return (
          void 0 === t && (t = -1 / 0),
          void 0 === e && (e = 1 / 0),
          function (n, i) {
            var r = "_" + i;
            Object.defineProperty(n, i, {
              get: function () {
                return this[r];
              },
              set: function (n) {
                Object.defineProperty(this, r, {
                  value: Va(n, t, e),
                  enumerable: !1,
                  writable: !0,
                  configurable: !0,
                });
              },
              enumerable: !0,
              configurable: !0,
            });
          }
        );
      }
      function ja(t, e) {
        var n = "_" + e;
        Object.defineProperty(t, e, {
          get: function () {
            return this[n];
          },
          set: function (t) {
            Object.defineProperty(this, n, {
              value: !!t,
              enumerable: !1,
              writable: !0,
              configurable: !0,
            });
          },
          enumerable: !0,
          configurable: !0,
        });
      }
      function Xa() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
        return function (e, n, i) {
          var r = i.value;
          return {
            get: function () {
              return (
                this.hasOwnProperty(n) ||
                  Object.defineProperty(this, n, {
                    value: Ga.apply(void 0, Pa([r], t)),
                  }),
                this[n]
              );
            },
          };
        };
      }
      var qa,
        Ya = (function () {
          function t(t) {
            var e = this;
            void 0 === t && (t = {}),
              (this.damping = 0.1),
              (this.thumbMinSize = 20),
              (this.renderByPixels = !0),
              (this.alwaysShowTracks = !1),
              (this.continuousScrolling = !0),
              (this.delegateTo = null),
              (this.plugins = {}),
              Object.keys(t).forEach(function (n) {
                e[n] = t[n];
              });
          }
          return (
            Object.defineProperty(t.prototype, "wheelEventTarget", {
              get: function () {
                return this.delegateTo;
              },
              set: function (t) {
                console.warn(
                  "[smooth-scrollbar]: `options.wheelEventTarget` is deprecated and will be removed in the future, use `options.delegateTo` instead."
                ),
                  (this.delegateTo = t);
              },
              enumerable: !0,
              configurable: !0,
            }),
            Ca([Wa(0, 1)], t.prototype, "damping", void 0),
            Ca([Wa(0, 1 / 0)], t.prototype, "thumbMinSize", void 0),
            Ca([ja], t.prototype, "renderByPixels", void 0),
            Ca([ja], t.prototype, "alwaysShowTracks", void 0),
            Ca([ja], t.prototype, "continuousScrolling", void 0),
            t
          );
        })();
      !(function (t) {
        (t.X = "x"), (t.Y = "y");
      })(qa || (qa = {}));
      var Ka = (function () {
          function t(t, e) {
            void 0 === e && (e = 0),
              (this._direction = t),
              (this._minSize = e),
              (this.element = document.createElement("div")),
              (this.displaySize = 0),
              (this.realSize = 0),
              (this.offset = 0),
              (this.element.className = "scrollbar-thumb scrollbar-thumb-" + t);
          }
          return (
            (t.prototype.attachTo = function (t) {
              t.appendChild(this.element);
            }),
            (t.prototype.update = function (t, e, n) {
              (this.realSize = Math.min(e / n, 1) * e),
                (this.displaySize = Math.max(this.realSize, this._minSize)),
                (this.offset =
                  (t / n) * (e + (this.realSize - this.displaySize))),
                za(this.element, this._getStyle());
            }),
            (t.prototype._getStyle = function () {
              switch (this._direction) {
                case qa.X:
                  return {
                    width: this.displaySize + "px",
                    "-transform": "translate3d(" + this.offset + "px, 0, 0)",
                  };
                case qa.Y:
                  return {
                    height: this.displaySize + "px",
                    "-transform": "translate3d(0, " + this.offset + "px, 0)",
                  };
                default:
                  return null;
              }
            }),
            t
          );
        })(),
        Za = (function () {
          function t(t, e) {
            void 0 === e && (e = 0),
              (this.element = document.createElement("div")),
              (this._isShown = !1),
              (this.element.className = "scrollbar-track scrollbar-track-" + t),
              (this.thumb = new Ka(t, e)),
              this.thumb.attachTo(this.element);
          }
          return (
            (t.prototype.attachTo = function (t) {
              t.appendChild(this.element);
            }),
            (t.prototype.show = function () {
              this._isShown ||
                ((this._isShown = !0), this.element.classList.add("show"));
            }),
            (t.prototype.hide = function () {
              this._isShown &&
                ((this._isShown = !1), this.element.classList.remove("show"));
            }),
            (t.prototype.update = function (t, e, n) {
              za(this.element, {
                display: n <= e ? "none" : "block",
              }),
                this.thumb.update(t, e, n);
            }),
            t
          );
        })(),
        $a = (function () {
          function t(t) {
            this._scrollbar = t;
            var e = t.options.thumbMinSize;
            (this.xAxis = new Za(qa.X, e)),
              (this.yAxis = new Za(qa.Y, e)),
              this.xAxis.attachTo(t.containerEl),
              this.yAxis.attachTo(t.containerEl),
              t.options.alwaysShowTracks &&
                (this.xAxis.show(), this.yAxis.show());
          }
          return (
            (t.prototype.update = function () {
              var t = this._scrollbar,
                e = t.size,
                n = t.offset;
              this.xAxis.update(n.x, e.container.width, e.content.width),
                this.yAxis.update(n.y, e.container.height, e.content.height);
            }),
            (t.prototype.autoHideOnIdle = function () {
              this._scrollbar.options.alwaysShowTracks ||
                (this.xAxis.hide(), this.yAxis.hide());
            }),
            Ca([Xa(300)], t.prototype, "autoHideOnIdle", null),
            t
          );
        })(),
        Ja = new WeakMap();
      function Qa(t) {
        return Math.pow(t - 1, 3) + 1;
      }
      var tl,
        el,
        nl,
        il = (function () {
          function t(t, e) {
            var n = this.constructor;
            (this.scrollbar = t),
              (this.name = n.pluginName),
              (this.options = Aa(Aa({}, n.defaultOptions), e));
          }
          return (
            (t.prototype.onInit = function () {}),
            (t.prototype.onDestroy = function () {}),
            (t.prototype.onUpdate = function () {}),
            (t.prototype.onRender = function (t) {}),
            (t.prototype.transformDelta = function (t, e) {
              return Aa({}, t);
            }),
            (t.pluginName = ""),
            (t.defaultOptions = {}),
            t
          );
        })(),
        rl = {
          order: new Set(),
          constructors: {},
        };
      function sl() {
        for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
        t.forEach(function (t) {
          var e = t.pluginName;
          if (!e) throw new TypeError("plugin name is required");
          rl.order.add(e), (rl.constructors[e] = t);
        });
      }
      function ol(t) {
        var e = Ia(t),
          n = t.containerEl;
        e(n, "keydown", function (e) {
          var i,
            r = document.activeElement;
          if (
            (r === n || n.contains(r)) &&
            (("INPUT" !== (i = r).tagName &&
              "SELECT" !== i.tagName &&
              "TEXTAREA" !== i.tagName &&
              !i.isContentEditable) ||
              i.disabled)
          ) {
            var s = (function (t, e) {
              var n = t.size,
                i = t.limit,
                r = t.offset;
              switch (e) {
                case tl.TAB:
                  return (function (t) {
                    requestAnimationFrame(function () {
                      t.scrollIntoView(document.activeElement, {
                        offsetTop: t.size.container.height / 2,
                        offsetLeft: t.size.container.width / 2,
                        onlyScrollIfNeeded: !0,
                      });
                    });
                  })(t);
                case tl.SPACE:
                  return [0, 200];
                case tl.PAGE_UP:
                  return [0, 40 - n.container.height];
                case tl.PAGE_DOWN:
                  return [0, n.container.height - 40];
                case tl.END:
                  return [0, i.y - r.y];
                case tl.HOME:
                  return [0, -r.y];
                case tl.LEFT:
                  return [-40, 0];
                case tl.UP:
                  return [0, -40];
                case tl.RIGHT:
                  return [40, 0];
                case tl.DOWN:
                  return [0, 40];
                default:
                  return null;
              }
            })(t, e.keyCode || e.which);
            if (s) {
              var o = s[0],
                a = s[1];
              t.addTransformableMomentum(o, a, e, function (n) {
                n
                  ? e.preventDefault()
                  : (t.containerEl.blur(),
                    t.parent && t.parent.containerEl.focus());
              });
            }
          }
        });
      }
      function al(t) {
        var e,
          n,
          i,
          r,
          s,
          o = Ia(t),
          a = t.containerEl,
          l = t.track,
          c = l.xAxis,
          u = l.yAxis;
        function h(e, n) {
          var i = t.size,
            r = t.limit,
            s = t.offset;
          return e === el.X
            ? Va(
                (n /
                  (i.container.width +
                    (c.thumb.realSize - c.thumb.displaySize))) *
                  i.content.width,
                0,
                r.x
              ) - s.x
            : e === el.Y
            ? Va(
                (n /
                  (i.container.height +
                    (u.thumb.realSize - u.thumb.displaySize))) *
                  i.content.height,
                0,
                r.y
              ) - s.y
            : 0;
        }
        function d(t) {
          return Na(t, [c.element, c.thumb.element])
            ? el.X
            : Na(t, [u.element, u.thumb.element])
            ? el.Y
            : void 0;
        }
        o(a, "click", function (e) {
          if (!n && Na(e.target, [c.element, u.element])) {
            var i = e.target,
              r = d(i),
              s = i.getBoundingClientRect(),
              o = Fa(e);
            if (r === el.X) {
              var a = o.x - s.left - c.thumb.displaySize / 2;
              t.setMomentum(h(r, a), 0);
            }
            r === el.Y &&
              ((a = o.y - s.top - u.thumb.displaySize / 2),
              t.setMomentum(0, h(r, a)));
          }
        }),
          o(a, "mousedown", function (n) {
            if (Na(n.target, [c.thumb.element, u.thumb.element])) {
              e = !0;
              var o = n.target,
                l = Fa(n),
                h = o.getBoundingClientRect();
              (r = d(o)),
                (i = {
                  x: l.x - h.left,
                  y: l.y - h.top,
                }),
                (s = a.getBoundingClientRect()),
                za(t.containerEl, {
                  "-user-select": "none",
                });
            }
          }),
          o(window, "mousemove", function (o) {
            if (e) {
              n = !0;
              var a = Fa(o);
              if (r === el.X) {
                var l = a.x - i.x - s.left;
                t.setMomentum(h(r, l), 0);
              }
              r === el.Y &&
                ((l = a.y - i.y - s.top), t.setMomentum(0, h(r, l)));
            }
          }),
          o(window, "mouseup blur", function () {
            (e = n = !1),
              za(t.containerEl, {
                "-user-select": "",
              });
          });
      }
      function ll(t) {
        Ia(t)(window, "resize", Ga(t.update.bind(t), 300));
      }
      function cl(t) {
        var e,
          n = Ia(t),
          i = t.containerEl,
          r = t.contentEl,
          s = !1,
          o = !1;
        function a(n) {
          var i = n.x,
            r = n.y;
          if (i || r) {
            var s = t.offset,
              o = t.limit;
            t.setMomentum(Va(s.x + i, 0, o.x) - s.x, Va(s.y + r, 0, o.y) - s.y),
              (e = requestAnimationFrame(function () {
                a({
                  x: i,
                  y: r,
                });
              }));
          }
        }
        n(window, "mousemove", function (n) {
          if (s) {
            cancelAnimationFrame(e);
            var i = (function (t, e) {
              var n = t.bounding,
                i = n.top,
                r = n.right,
                s = n.bottom,
                o = n.left,
                a = Fa(e),
                l = a.x,
                c = a.y,
                u = {
                  x: 0,
                  y: 0,
                },
                h = 20;
              return (
                (0 === l && 0 === c) ||
                  (l > r - h
                    ? (u.x = l - r + h)
                    : l < o + h && (u.x = l - o - h),
                  c > s - h
                    ? (u.y = c - s + h)
                    : c < i + h && (u.y = c - i - h),
                  (u.x *= 2),
                  (u.y *= 2)),
                u
              );
            })(t, n);
            a(i);
          }
        }),
          n(r, "contextmenu", function () {
            (o = !0), cancelAnimationFrame(e), (s = !1);
          }),
          n(r, "mousedown", function () {
            o = !1;
          }),
          n(r, "selectstart", function () {
            o || (cancelAnimationFrame(e), (s = !0));
          }),
          n(window, "mouseup blur", function () {
            cancelAnimationFrame(e), (s = !1), (o = !1);
          }),
          n(i, "scroll", function (t) {
            t.preventDefault(), (i.scrollTop = i.scrollLeft = 0);
          });
      }
      function ul(t) {
        var e,
          n = t.options.delegateTo || t.containerEl,
          i = new Ha(),
          r = Ia(t),
          s = 0;
        r(n, "touchstart", function (n) {
          i.track(n),
            t.setMomentum(0, 0),
            0 === s &&
              ((e = t.options.damping), (t.options.damping = Math.max(e, 0.5))),
            s++;
        }),
          r(n, "touchmove", function (e) {
            if (!nl || nl === t) {
              i.update(e);
              var n = i.getDelta(),
                r = n.x,
                s = n.y;
              t.addTransformableMomentum(r, s, e, function (n) {
                n && e.cancelable && (e.preventDefault(), (nl = t));
              });
            }
          }),
          r(n, "touchcancel touchend", function (n) {
            var r = i.getEasingDistance(e);
            t.addTransformableMomentum(r.x, r.y, n),
              0 == --s && (t.options.damping = e),
              i.release(n),
              (nl = null);
          });
      }
      function hl(t) {
        Ia(t)(
          t.options.delegateTo || t.containerEl,
          "onwheel" in window ||
            document.implementation.hasFeature("Events.wheel", "3.0")
            ? "wheel"
            : "mousewheel",
          function (e) {
            var n = (function (t) {
                if ("deltaX" in t) {
                  var e = fl(t.deltaMode);
                  return {
                    x: (t.deltaX / dl.STANDARD) * e,
                    y: (t.deltaY / dl.STANDARD) * e,
                  };
                }
                return "wheelDeltaX" in t
                  ? {
                      x: t.wheelDeltaX / dl.OTHERS,
                      y: t.wheelDeltaY / dl.OTHERS,
                    }
                  : {
                      x: 0,
                      y: t.wheelDelta / dl.OTHERS,
                    };
              })(e),
              i = n.x,
              r = n.y;
            t.addTransformableMomentum(i, r, e, function (t) {
              t && e.preventDefault();
            });
          }
        );
      }
      !(function (t) {
        (t[(t.TAB = 9)] = "TAB"),
          (t[(t.SPACE = 32)] = "SPACE"),
          (t[(t.PAGE_UP = 33)] = "PAGE_UP"),
          (t[(t.PAGE_DOWN = 34)] = "PAGE_DOWN"),
          (t[(t.END = 35)] = "END"),
          (t[(t.HOME = 36)] = "HOME"),
          (t[(t.LEFT = 37)] = "LEFT"),
          (t[(t.UP = 38)] = "UP"),
          (t[(t.RIGHT = 39)] = "RIGHT"),
          (t[(t.DOWN = 40)] = "DOWN");
      })(tl || (tl = {})),
        (function (t) {
          (t[(t.X = 0)] = "X"), (t[(t.Y = 1)] = "Y");
        })(el || (el = {}));
      var dl = {
          STANDARD: 1,
          OTHERS: -3,
        },
        pl = [1, 28, 500],
        fl = function (t) {
          return pl[t] || pl[0];
        },
        ml = new Map(),
        gl = (function () {
          function e(t, e) {
            var n = this;
            (this.offset = {
              x: 0,
              y: 0,
            }),
              (this.limit = {
                x: 1 / 0,
                y: 1 / 0,
              }),
              (this.bounding = {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0,
              }),
              (this._plugins = []),
              (this._momentum = {
                x: 0,
                y: 0,
              }),
              (this._listeners = new Set()),
              (this.containerEl = t);
            var i = (this.contentEl = document.createElement("div"));
            (this.options = new Ya(e)),
              t.setAttribute("data-scrollbar", "true"),
              t.setAttribute("tabindex", "-1"),
              za(t, {
                overflow: "hidden",
                outline: "none",
              }),
              window.navigator.msPointerEnabled &&
                (t.style.msTouchAction = "none"),
              (i.className = "scroll-content"),
              Array.from(t.childNodes).forEach(function (t) {
                i.appendChild(t);
              }),
              t.appendChild(i),
              (this.track = new $a(this)),
              (this.size = this.getSize()),
              (this._plugins = (function (t, e) {
                return Array.from(rl.order)
                  .filter(function (t) {
                    return !1 !== e[t];
                  })
                  .map(function (n) {
                    var i = new (0, rl.constructors[n])(t, e[n]);
                    return (e[n] = i.options), i;
                  });
              })(this, this.options.plugins));
            var r = t.scrollLeft,
              s = t.scrollTop;
            (t.scrollLeft = t.scrollTop = 0),
              this.setPosition(r, s, {
                withoutCallbacks: !0,
              });
            var o = window.ResizeObserver;
            "function" == typeof o &&
              ((this._observer = new o(function () {
                n.update();
              })),
              this._observer.observe(i)),
              ml.set(t, this),
              requestAnimationFrame(function () {
                n._init();
              });
          }
          return (
            Object.defineProperty(e.prototype, "parent", {
              get: function () {
                for (var t = this.containerEl.parentElement; t; ) {
                  var e = ml.get(t);
                  if (e) return e;
                  t = t.parentElement;
                }
                return null;
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(e.prototype, "scrollTop", {
              get: function () {
                return this.offset.y;
              },
              set: function (t) {
                this.setPosition(this.scrollLeft, t);
              },
              enumerable: !0,
              configurable: !0,
            }),
            Object.defineProperty(e.prototype, "scrollLeft", {
              get: function () {
                return this.offset.x;
              },
              set: function (t) {
                this.setPosition(t, this.scrollTop);
              },
              enumerable: !0,
              configurable: !0,
            }),
            (e.prototype.getSize = function () {
              return (
                (t = this.containerEl),
                (e = this.contentEl),
                (n = getComputedStyle(t)),
                (r =
                  (i = [
                    "paddingTop",
                    "paddingBottom",
                    "paddingLeft",
                    "paddingRight",
                  ].map(function (t) {
                    return n[t] ? parseFloat(n[t]) : 0;
                  }))[0] + i[1]),
                (s = i[2] + i[3]),
                {
                  container: {
                    width: t.clientWidth,
                    height: t.clientHeight,
                  },
                  content: {
                    width: e.offsetWidth - e.clientWidth + e.scrollWidth + s,
                    height:
                      e.offsetHeight - e.clientHeight + e.scrollHeight + r,
                  },
                }
              );
              var t, e, n, i, r, s;
            }),
            (e.prototype.update = function () {
              var t, e, n, i, r;
              (e = (t = this).getSize()),
                (n = {
                  x: Math.max(e.content.width - e.container.width, 0),
                  y: Math.max(e.content.height - e.container.height, 0),
                }),
                (i = t.containerEl.getBoundingClientRect()),
                (r = {
                  top: Math.max(i.top, 0),
                  right: Math.min(i.right, window.innerWidth),
                  bottom: Math.min(i.bottom, window.innerHeight),
                  left: Math.max(i.left, 0),
                }),
                (t.size = e),
                (t.limit = n),
                (t.bounding = r),
                t.track.update(),
                t.setPosition(),
                this._plugins.forEach(function (t) {
                  t.onUpdate();
                });
            }),
            (e.prototype.isVisible = function (t) {
              return (function (t, e) {
                var n = t.bounding,
                  i = e.getBoundingClientRect(),
                  r = Math.max(n.top, i.top),
                  s = Math.max(n.left, i.left),
                  o = Math.min(n.right, i.right);
                return r < Math.min(n.bottom, i.bottom) && s < o;
              })(this, t);
            }),
            (e.prototype.setPosition = function (t, e, n) {
              var i = this;
              void 0 === t && (t = this.offset.x),
                void 0 === e && (e = this.offset.y),
                void 0 === n && (n = {});
              var r = (function (t, e, n) {
                var i = t.options,
                  r = t.offset,
                  s = t.limit,
                  o = t.track,
                  a = t.contentEl;
                return (
                  i.renderByPixels &&
                    ((e = Math.round(e)), (n = Math.round(n))),
                  (e = Va(e, 0, s.x)),
                  (n = Va(n, 0, s.y)),
                  e !== r.x && o.xAxis.show(),
                  n !== r.y && o.yAxis.show(),
                  i.alwaysShowTracks || o.autoHideOnIdle(),
                  e === r.x && n === r.y
                    ? null
                    : ((r.x = e),
                      (r.y = n),
                      za(a, {
                        "-transform":
                          "translate3d(" + -e + "px, " + -n + "px, 0)",
                      }),
                      o.update(),
                      {
                        offset: Aa({}, r),
                        limit: Aa({}, s),
                      })
                );
              })(this, t, e);
              r &&
                !n.withoutCallbacks &&
                this._listeners.forEach(function (t) {
                  t.call(i, r);
                });
            }),
            (e.prototype.scrollTo = function (t, e, n, i) {
              void 0 === t && (t = this.offset.x),
                void 0 === e && (e = this.offset.y),
                void 0 === n && (n = 0),
                void 0 === i && (i = {}),
                (function (t, e, n, i, r) {
                  void 0 === i && (i = 0);
                  var s = void 0 === r ? {} : r,
                    o = s.easing,
                    a = void 0 === o ? Qa : o,
                    l = s.callback,
                    c = t.options,
                    u = t.offset,
                    h = t.limit;
                  c.renderByPixels &&
                    ((e = Math.round(e)), (n = Math.round(n)));
                  var d = u.x,
                    p = u.y,
                    f = Va(e, 0, h.x) - d,
                    m = Va(n, 0, h.y) - p,
                    g = Date.now();
                  cancelAnimationFrame(Ja.get(t)),
                    (function e() {
                      var n = Date.now() - g,
                        r = i ? a(Math.min(n / i, 1)) : 1;
                      if ((t.setPosition(d + f * r, p + m * r), n >= i))
                        "function" == typeof l && l.call(t);
                      else {
                        var s = requestAnimationFrame(e);
                        Ja.set(t, s);
                      }
                    })();
                })(this, t, e, n, i);
            }),
            (e.prototype.scrollIntoView = function (t, e) {
              void 0 === e && (e = {}),
                (function (t, e, n) {
                  var i = void 0 === n ? {} : n,
                    r = i.alignToTop,
                    s = void 0 === r || r,
                    o = i.onlyScrollIfNeeded,
                    a = void 0 !== o && o,
                    l = i.offsetTop,
                    c = void 0 === l ? 0 : l,
                    u = i.offsetLeft,
                    h = void 0 === u ? 0 : u,
                    d = i.offsetBottom,
                    p = void 0 === d ? 0 : d,
                    f = t.containerEl,
                    m = t.bounding,
                    g = t.offset,
                    v = t.limit;
                  if (e && f.contains(e)) {
                    var _ = e.getBoundingClientRect();
                    if (!a || !t.isVisible(e)) {
                      var y = s ? _.top - m.top - c : _.bottom - m.bottom + p;
                      t.setMomentum(
                        _.left - m.left - h,
                        Va(y, -g.y, v.y - g.y)
                      );
                    }
                  }
                })(this, t, e);
            }),
            (e.prototype.addListener = function (t) {
              if ("function" != typeof t)
                throw new TypeError(
                  "[smooth-scrollbar] scrolling listener should be a function"
                );
              this._listeners.add(t);
            }),
            (e.prototype.removeListener = function (t) {
              this._listeners.delete(t);
            }),
            (e.prototype.addTransformableMomentum = function (t, e, n, i) {
              this._updateDebounced();
              var r = this._plugins.reduce(
                  function (t, e) {
                    return e.transformDelta(t, n) || t;
                  },
                  {
                    x: t,
                    y: e,
                  }
                ),
                s = !this._shouldPropagateMomentum(r.x, r.y);
              s && this.addMomentum(r.x, r.y), i && i.call(this, s);
            }),
            (e.prototype.addMomentum = function (t, e) {
              this.setMomentum(this._momentum.x + t, this._momentum.y + e);
            }),
            (e.prototype.setMomentum = function (t, e) {
              0 === this.limit.x && (t = 0),
                0 === this.limit.y && (e = 0),
                this.options.renderByPixels &&
                  ((t = Math.round(t)), (e = Math.round(e))),
                (this._momentum.x = t),
                (this._momentum.y = e);
            }),
            (e.prototype.updatePluginOptions = function (t, e) {
              this._plugins.forEach(function (n) {
                n.name === t && Object.assign(n.options, e);
              });
            }),
            (e.prototype.destroy = function () {
              var t,
                e = this.containerEl,
                n = this.contentEl;
              (t = La.get(this)) &&
                (t.forEach(function (t) {
                  var e = t.elem,
                    n = t.eventName,
                    i = t.handler;
                  e.removeEventListener(n, i, Oa());
                }),
                La.delete(this)),
                this._listeners.clear(),
                this.setMomentum(0, 0),
                cancelAnimationFrame(this._renderID),
                this._observer && this._observer.disconnect(),
                ml.delete(this.containerEl);
              for (var i = Array.from(n.childNodes); e.firstChild; )
                e.removeChild(e.firstChild);
              i.forEach(function (t) {
                e.appendChild(t);
              }),
                za(e, {
                  overflow: "",
                }),
                (e.scrollTop = this.scrollTop),
                (e.scrollLeft = this.scrollLeft),
                this._plugins.forEach(function (t) {
                  t.onDestroy();
                }),
                (this._plugins.length = 0);
            }),
            (e.prototype._init = function () {
              var e = this;
              this.update(),
                Object.keys(t).forEach(function (n) {
                  t[n](e);
                }),
                this._plugins.forEach(function (t) {
                  t.onInit();
                }),
                this._render();
            }),
            (e.prototype._updateDebounced = function () {
              this.update();
            }),
            (e.prototype._shouldPropagateMomentum = function (t, e) {
              void 0 === t && (t = 0), void 0 === e && (e = 0);
              var n = this,
                i = n.options,
                r = n.offset,
                s = n.limit;
              if (!i.continuousScrolling) return !1;
              0 === s.x && 0 === s.y && this._updateDebounced();
              var o = Va(t + r.x, 0, s.x),
                a = Va(e + r.y, 0, s.y),
                l = !0;
              return (
                (l = (l = l && o === r.x) && a === r.y) &&
                (r.x === s.x || 0 === r.x || r.y === s.y || 0 === r.y)
              );
            }),
            (e.prototype._render = function () {
              var t = this._momentum;
              if (t.x || t.y) {
                var e = this._nextTick("x"),
                  n = this._nextTick("y");
                (t.x = e.momentum),
                  (t.y = n.momentum),
                  this.setPosition(e.position, n.position);
              }
              var i = Aa({}, this._momentum);
              this._plugins.forEach(function (t) {
                t.onRender(i);
              }),
                (this._renderID = requestAnimationFrame(
                  this._render.bind(this)
                ));
            }),
            (e.prototype._nextTick = function (t) {
              var e = this,
                n = e.options,
                i = e.offset,
                r = e._momentum,
                s = i[t],
                o = r[t];
              if (Math.abs(o) <= 0.1)
                return {
                  momentum: 0,
                  position: s + o,
                };
              var a = o * (1 - n.damping);
              return (
                n.renderByPixels && (a |= 0),
                {
                  momentum: a,
                  position: s + o - a,
                }
              );
            }),
            Ca([Xa(100, !0)], e.prototype, "_updateDebounced", null),
            e
          );
        })(),
        vl = "smooth-scrollbar-style",
        _l = !1;
      function yl() {
        if (!_l && "undefined" != typeof window) {
          var t = document.createElement("style");
          (t.id = vl),
            (t.textContent =
              "\n[data-scrollbar] {\n  display: block;\n  position: relative;\n}\n\n.scroll-content {\n  display: flow-root;\n  -webkit-transform: translate3d(0, 0, 0);\n          transform: translate3d(0, 0, 0);\n}\n\n.scrollbar-track {\n  position: absolute;\n  opacity: 0;\n  z-index: 1;\n  background: rgba(222, 222, 222, .75);\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  -webkit-transition: opacity 0.5s 0.5s ease-out;\n          transition: opacity 0.5s 0.5s ease-out;\n}\n.scrollbar-track.show,\n.scrollbar-track:hover {\n  opacity: 1;\n  -webkit-transition-delay: 0s;\n          transition-delay: 0s;\n}\n\n.scrollbar-track-x {\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  height: 8px;\n}\n.scrollbar-track-y {\n  top: 0;\n  right: 0;\n  width: 8px;\n  height: 100%;\n}\n.scrollbar-thumb {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 8px;\n  height: 8px;\n  background: rgba(0, 0, 0, .5);\n  border-radius: 4px;\n}\n"),
            document.head && document.head.appendChild(t),
            (_l = !0);
        }
      }
      var xl = (function (t) {
          function e() {
            return (null !== t && t.apply(this, arguments)) || this;
          }
          return (
            (function (t, e) {
              function n() {
                this.constructor = t;
              }
              Da(t, e),
                (t.prototype =
                  null === e
                    ? Object.create(e)
                    : ((n.prototype = e.prototype), new n()));
            })(e, t),
            (e.init = function (t, e) {
              if (!t || 1 !== t.nodeType)
                throw new TypeError(
                  "expect element to be DOM Element, but got " + t
                );
              return yl(), ml.has(t) ? ml.get(t) : new gl(t, e);
            }),
            (e.initAll = function (t) {
              return Array.from(
                document.querySelectorAll("[data-scrollbar]"),
                function (n) {
                  return e.init(n, t);
                }
              );
            }),
            (e.has = function (t) {
              return ml.has(t);
            }),
            (e.get = function (t) {
              return ml.get(t);
            }),
            (e.getAll = function () {
              return Array.from(ml.values());
            }),
            (e.destroy = function (t) {
              var e = ml.get(t);
              e && e.destroy();
            }),
            (e.destroyAll = function () {
              ml.forEach(function (t) {
                t.destroy();
              });
            }),
            (e.use = function () {
              for (var t = [], e = 0; e < arguments.length; e++)
                t[e] = arguments[e];
              return sl.apply(void 0, t);
            }),
            (e.attachStyle = function () {
              return yl();
            }),
            (e.detachStyle = function () {
              return (function () {
                if (_l && "undefined" != typeof window) {
                  var t = document.getElementById(vl);
                  t && t.parentNode && (t.parentNode.removeChild(t), (_l = !1));
                }
              })();
            }),
            (e.version = "8.8.4"),
            (e.ScrollbarPlugin = il),
            e
          );
        })(gl),
        bl = xl;
      function Sl(t, e) {
        return (
          (Sl = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          Sl(t, e)
        );
      }
      var El = (function (t) {
        var e, n;
        function i() {
          return t.apply(this, arguments) || this;
        }
        return (
          (n = t),
          ((e = i).prototype = Object.create(n.prototype)),
          (e.prototype.constructor = e),
          Sl(e, n),
          (i.prototype.transformDelta = function (t, e) {
            return this.options.disable
              ? {
                  x: 0,
                  y: 0,
                }
              : t;
          }),
          i
        );
      })(bl.ScrollbarPlugin);
      (El.pluginName = "Disable"),
        (El.defaultOptions = {
          disable: !1,
        });
      var Tl = El;
      function Ml(t, e) {
        return (
          (Ml = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          Ml(t, e)
        );
      }
      var wl = (function (t) {
        var e, n;
        function i() {
          return t.apply(this, arguments) || this;
        }
        (n = t),
          ((e = i).prototype = Object.create(n.prototype)),
          (e.prototype.constructor = e),
          Ml(e, n);
        var r = i.prototype;
        return (
          (r.transformDelta = function (t, e) {
            var n = t.x > 0 ? 1 : -1,
              i = t.y > 0 ? 1 : -1;
            return n === this.lockX || i === this.lockY
              ? {
                  x: 0,
                  y: 0,
                }
              : ((this.lockX = null), (this.lockY = null), t);
          }),
          (r.onRender = function (t) {
            var e = t.x,
              n = t.y;
            n < 0 &&
              !this.lockY &&
              Math.abs(n) >= this.scrollbar.scrollTop &&
              (this.scrollbar.setMomentum(0, -this.scrollbar.scrollTop),
              (this.lockY = -1)),
              e < 0 &&
                !this.lockX &&
                Math.abs(e) >= this.scrollbar.scrollLeft &&
                (this.scrollbar.setMomentum(-this.scrollbar.scrollLeft, 0),
                (this.lockX = -1)),
              e > 0 &&
                !this.lockX &&
                Math.abs(e) >=
                  this.scrollbar.limit.x - this.scrollbar.scrollLeft &&
                (this.scrollbar.setMomentum(
                  this.scrollbar.limit.x - this.scrollbar.scrollLeft,
                  0
                ),
                (this.lockX = 1)),
              n > 0 &&
                !this.lockY &&
                Math.abs(n) >=
                  this.scrollbar.limit.y - this.scrollbar.scrollTop &&
                (this.scrollbar.setMomentum(
                  0,
                  this.scrollbar.limit.y - this.scrollbar.scrollTop
                ),
                (this.lockY = 1)),
              0 === n && (this.lockY = null),
              0 === e && (this.lockX = null);
          }),
          i
        );
      })(bl.ScrollbarPlugin);
      wl.pluginName = "SoftScroll";
      var Dl = wl;
      function Al(t, e) {
        return (
          (Al = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          Al(t, e)
        );
      }
      Zi.registerPlugin(ta);
      var Cl = {
          el: document.body,
          vars: {
            scrollTop: function (t) {
              return (
                arguments.length && (Cl.scrollbar.scrollTop = t),
                Cl.scrollbar.scrollTop
              );
            },
            scrollLeft: function (t) {
              return (
                arguments.length && (Cl.scrollbar.scrollLeft = t),
                Cl.scrollbar.scrollLeft
              );
            },
            getBoundingClientRect: function () {
              return {
                top: 0,
                left: 0,
                width: window.innerWidth,
                height: window.innerHeight,
              };
            },
            pinType: "transform",
          },
        },
        Pl = (function (t) {
          var e, n;
          function i(e, n) {
            var i;
            return (
              (i = t.call(this, e, n) || this),
              (Cl.scrollbar = e),
              ta.scrollerProxy(Cl.el, Cl.vars),
              ta.defaults({
                pinType: "transform",
              }),
              e.addListener(ta.update),
              i
            );
          }
          return (
            (n = t),
            ((e = i).prototype = Object.create(n.prototype)),
            (e.prototype.constructor = e),
            Al(e, n),
            i
          );
        })(bl.ScrollbarPlugin);
      Pl.pluginName = "ScrollTrigger";
      var Rl = Pl;
      function Ll(t, e) {
        return (
          (Ll = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          Ll(t, e)
        );
      }
      Zi.registerPlugin(wa), bl.use(Tl, Dl, Rl);
      var Ol = (function (t) {
          var e, n;
          function i() {
            var e;
            return (
              (e = t.apply(this, arguments) || this).bindNativeScrolling(),
              e.initSmoothScrolling(),
              (e.hideTl = e.tlHide()),
              e
            );
          }
          (n = t),
            ((e = i).prototype = Object.create(n.prototype)),
            (e.prototype.constructor = e),
            Ll(e, n);
          var r = i.prototype;
          return (
            (r.onEnter = function () {
              try {
                return this.scrollToHash(), Promise.resolve();
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (r.onComplete = function () {
              try {
                var t = this;
                return (
                  setTimeout(function () {
                    return t.loadLazyImages();
                  }, 3e3),
                  Promise.resolve()
                );
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (r.onLeave = function () {
              try {
                return (
                  this.hideTl.play(0),
                  ta && (ta.killAll(), ta.clearScrollMemory()),
                  Promise.resolve()
                );
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (r.onDestroy = function () {
              try {
                var t = this;
                return (
                  t.ssb && t.destroySmoothScrolling(),
                  window.removeEventListener("scroll", t.nativeScrollEvent),
                  Promise.resolve()
                );
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (r.tlHide = function () {
              var t = new Zi.timeline({
                paused: !0,
              });
              return (
                this.ssb
                  ? (t.set(this.el, {
                      willChange: "transform",
                      transformOrigin: "bottom center",
                      immediateRender: !1,
                    }),
                    t.to(this.el, {
                      scale: this.ssb ? 0.96 : 1,
                      opacity: this.ssb ? 0.94 : 0.8,
                      duration: 0.6,
                      ease: "expo.out",
                      immediateRender: !1,
                    }))
                  : t.to(this.el, {
                      opacity: 0.7,
                      duration: 0.4,
                      immediateRender: !1,
                    }),
                t
              );
            }),
            (r.bindNativeScrolling = function () {
              var t = this;
              (this.nativeScrollEvent = function () {
                return t.app.trigger(
                  "scrolling",
                  window.pageYOffset,
                  window.pageXOffset
                );
              }),
                window.addEventListener("scroll", this.nativeScrollEvent);
            }),
            (r.initSmoothScrolling = function () {
              var t = this;
              window.matchMedia("(pointer:fine)").matches &&
                ((this.ssb = bl.init(this.el, {
                  continuousScrolling: !1,
                  renderByPixels: !0,
                  damping: 0.08,
                })),
                this.ssb.addListener(function (e) {
                  return t.app.trigger("scrolling", e.offset.y, e.offset.x);
                }),
                document.documentElement.classList.add("smooth"));
            }),
            (r.destroySmoothScrolling = function () {
              this.ssb.destroy(),
                (this.ssb = null),
                document.documentElement.classList.remove("smooth");
            }),
            (r.scrollEnable = function () {
              document.documentElement.classList.remove("no-scroll"),
                this.ssb &&
                  this.ssb.updatePluginOptions("Disable", {
                    disable: !1,
                  });
            }),
            (r.scrollDisable = function () {
              document.documentElement.classList.add("no-scroll"),
                this.ssb &&
                  this.ssb.updatePluginOptions("Disable", {
                    disable: !0,
                  });
            }),
            (r.scrollTop = function () {
              return this.ssb ? this.ssb.scrollTop : window.pageYOffset;
            }),
            (r.scrollLeft = function () {
              return this.ssb ? this.ssb.scrollLeft : window.pageXOffset;
            }),
            (r.scrollHeight = function () {
              return this.ssb
                ? this.ssb.limit.y
                : document.documentElement.scrollHeight;
            }),
            (r.scrollWidth = function () {
              return this.ssb
                ? this.ssb.limit.x
                : document.documentElement.scrollWidth;
            }),
            (r.scrollTo = function (t, e, n) {
              void 0 === e && (e = 0),
                void 0 === n && (n = {}),
                (t += (n = Object.assign(
                  {},
                  {
                    offsetY: 0,
                    offsetX: 0,
                    duration: 0.3,
                    callback: null,
                    ease: null,
                  },
                  n
                )).offsetY),
                (e += n.offsetX),
                this.ssb
                  ? this.ssb.scrollTo(e, t, 1e3 * n.duration, {
                      callback: n.callback,
                      easing: n.ease,
                    })
                  : wa
                  ? Zi.to(window, {
                      scrollTo: {
                        y: t,
                        x: e,
                        autoKill: !1,
                      },
                      ease: n.ease,
                      duration: n.duration,
                      onComplete: n.callback,
                    })
                  : window.scrollTo({
                      top: t,
                      left: e,
                      behavior: n.duration ? "smooth" : "instant",
                    });
            }),
            (r.scrollToTarget = function (t, e) {
              var n = this.app.query(t);
              if (n) {
                var i = n.getBoundingClientRect(),
                  r = i.top + this.scrollTop(),
                  s = i.left + this.scrollLeft();
                this.scrollTo(r, s, e);
              }
            }),
            (r.scrollToHash = function () {
              window.location.hash &&
                (this.ssb && this.ssb.update(),
                this.scrollToTarget(
                  "#section-" + window.location.hash.substr(1),
                  {
                    duration: 0,
                  }
                ));
            }),
            (r.loadLazyImages = function () {
              this.el
                .querySelectorAll("img[loading=lazy]")
                .forEach(function (t) {
                  t.setAttribute("loading", "eager");
                });
            }),
            i
          );
        })(o),
        Il = (function () {
          function t(e) {
            void 0 === e && (e = {}),
              (this.options = Object.assign(
                {},
                {
                  el: null,
                  container: document.body,
                  className: "mf-cursor",
                  innerClassName: "mf-cursor-inner",
                  textClassName: "mf-cursor-text",
                  mediaClassName: "mf-cursor-media",
                  mediaBoxClassName: "mf-cursor-media-box",
                  iconSvgClassName: "mf-svgsprite",
                  iconSvgNamePrefix: "-",
                  iconSvgSrc: "",
                  dataAttr: "cursor",
                  hiddenState: "-hidden",
                  textState: "-text",
                  iconState: "-icon",
                  activeState: "-active",
                  mediaState: "-media",
                  stateDetection: {
                    "-pointer": "a,button",
                  },
                  visible: !0,
                  visibleOnState: !1,
                  speed: 0.55,
                  ease: "expo.out",
                  overwrite: !0,
                  skewing: 0,
                  skewingText: 2,
                  skewingIcon: 2,
                  skewingMedia: 2,
                  skewingDelta: 0.001,
                  skewingDeltaMax: 0.15,
                  stickDelta: 0.15,
                  showTimeout: 0,
                  hideOnLeave: !0,
                  hideTimeout: 300,
                  hideMediaTimeout: 300,
                  initialPos: [-window.innerWidth, -window.innerHeight],
                },
                e
              )),
              this.options.visible &&
                null == e.stateDetection &&
                (this.options.stateDetection["-hidden"] = "iframe"),
              (this.gsap = t.gsap || window.gsap),
              (this.el =
                "string" == typeof this.options.el
                  ? document.querySelector(this.options.el)
                  : this.options.el),
              (this.container =
                "string" == typeof this.options.container
                  ? document.querySelector(this.options.container)
                  : this.options.container),
              (this.skewing = this.options.skewing),
              (this.pos = {
                x: this.options.initialPos[0],
                y: this.options.initialPos[1],
              }),
              (this.vel = {
                x: 0,
                y: 0,
              }),
              (this.event = {}),
              (this.events = []),
              this.init();
          }
          t.registerGSAP = function (e) {
            t.gsap = e;
          };
          var e = t.prototype;
          return (
            (e.init = function () {
              this.el || this.create(),
                this.createSetter(),
                this.bind(),
                this.render(!0),
                (this.ticker = this.render.bind(this, !1)),
                this.gsap.ticker.add(this.ticker);
            }),
            (e.create = function () {
              (this.el = document.createElement("div")),
                (this.el.className = this.options.className),
                this.el.classList.add(this.options.hiddenState),
                (this.inner = document.createElement("div")),
                (this.inner.className = this.options.innerClassName),
                (this.text = document.createElement("div")),
                (this.text.className = this.options.textClassName),
                (this.media = document.createElement("div")),
                (this.media.className = this.options.mediaClassName),
                (this.mediaBox = document.createElement("div")),
                (this.mediaBox.className = this.options.mediaBoxClassName),
                this.media.appendChild(this.mediaBox),
                this.inner.appendChild(this.media),
                this.inner.appendChild(this.text),
                this.el.appendChild(this.inner),
                this.container.appendChild(this.el);
            }),
            (e.createSetter = function () {
              this.setter = {
                x: this.gsap.quickSetter(this.el, "x", "px"),
                y: this.gsap.quickSetter(this.el, "y", "px"),
                rotation: this.gsap.quickSetter(this.el, "rotation", "deg"),
                scaleX: this.gsap.quickSetter(this.el, "scaleX"),
                scaleY: this.gsap.quickSetter(this.el, "scaleY"),
                wc: this.gsap.quickSetter(this.el, "willChange"),
                inner: {
                  rotation: this.gsap.quickSetter(
                    this.inner,
                    "rotation",
                    "deg"
                  ),
                },
              };
            }),
            (e.bind = function () {
              var t = this;
              (this.event.mouseleave = function () {
                return t.hide();
              }),
                (this.event.mouseenter = function () {
                  return t.show();
                }),
                (this.event.mousedown = function () {
                  return t.addState(t.options.activeState);
                }),
                (this.event.mouseup = function () {
                  return t.removeState(t.options.activeState);
                }),
                (this.event.mousemoveOnce = function () {
                  return t.show();
                }),
                (this.event.mousemove = function (e) {
                  t.gsap.to(t.pos, {
                    x: t.stick
                      ? t.stick.x -
                        (t.stick.x - e.clientX) * t.options.stickDelta
                      : e.clientX,
                    y: t.stick
                      ? t.stick.y -
                        (t.stick.y - e.clientY) * t.options.stickDelta
                      : e.clientY,
                    overwrite: t.options.overwrite,
                    ease: t.options.ease,
                    duration: t.visible ? t.options.speed : 0,
                    onUpdate: function () {
                      return (t.vel = {
                        x: e.clientX - t.pos.x,
                        y: e.clientY - t.pos.y,
                      });
                    },
                  });
                }),
                (this.event.mouseover = function (e) {
                  for (
                    var n = e.target;
                    n &&
                    n !== t.container &&
                    (!e.relatedTarget || !n.contains(e.relatedTarget));
                    n = n.parentNode
                  ) {
                    for (var i in t.options.stateDetection)
                      n.matches(t.options.stateDetection[i]) && t.addState(i);
                    if (t.options.dataAttr) {
                      var r = t.getFromDataset(n);
                      r.state && t.addState(r.state),
                        r.text && t.setText(r.text),
                        r.icon && t.setIcon(r.icon),
                        r.img && t.setImg(r.img),
                        r.video && t.setVideo(r.video),
                        void 0 !== r.show && t.show(),
                        void 0 !== r.stick && t.setStick(r.stick || n);
                    }
                  }
                }),
                (this.event.mouseout = function (e) {
                  for (
                    var n = e.target;
                    n &&
                    n !== t.container &&
                    (!e.relatedTarget || !n.contains(e.relatedTarget));
                    n = n.parentNode
                  ) {
                    for (var i in t.options.stateDetection)
                      n.matches(t.options.stateDetection[i]) &&
                        t.removeState(i);
                    if (t.options.dataAttr) {
                      var r = t.getFromDataset(n);
                      r.state && t.removeState(r.state),
                        r.text && t.removeText(),
                        r.icon && t.removeIcon(),
                        r.img && t.removeImg(),
                        r.video && t.removeVideo(),
                        void 0 !== r.show && t.hide(),
                        void 0 !== r.stick && t.removeStick();
                    }
                  }
                }),
                this.options.hideOnLeave &&
                  this.container.addEventListener(
                    "mouseleave",
                    this.event.mouseleave,
                    {
                      passive: !0,
                    }
                  ),
                this.options.visible &&
                  this.container.addEventListener(
                    "mouseenter",
                    this.event.mouseenter,
                    {
                      passive: !0,
                    }
                  ),
                this.options.activeState &&
                  (this.container.addEventListener(
                    "mousedown",
                    this.event.mousedown,
                    {
                      passive: !0,
                    }
                  ),
                  this.container.addEventListener(
                    "mouseup",
                    this.event.mouseup,
                    {
                      passive: !0,
                    }
                  )),
                this.container.addEventListener(
                  "mousemove",
                  this.event.mousemove,
                  {
                    passive: !0,
                  }
                ),
                this.options.visible &&
                  this.container.addEventListener(
                    "mousemove",
                    this.event.mousemoveOnce,
                    {
                      passive: !0,
                      once: !0,
                    }
                  ),
                (this.options.stateDetection || this.options.dataAttr) &&
                  (this.container.addEventListener(
                    "mouseover",
                    this.event.mouseover,
                    {
                      passive: !0,
                    }
                  ),
                  this.container.addEventListener(
                    "mouseout",
                    this.event.mouseout,
                    {
                      passive: !0,
                    }
                  ));
            }),
            (e.render = function (t) {
              if (!0 === t || (0 !== this.vel.y && 0 !== this.vel.x)) {
                if (
                  (this.trigger("render"),
                  this.setter.wc("transform"),
                  this.setter.x(this.pos.x),
                  this.setter.y(this.pos.y),
                  this.skewing)
                ) {
                  var e = Math.sqrt(
                      Math.pow(this.vel.x, 2) + Math.pow(this.vel.y, 2)
                    ),
                    n =
                      Math.min(
                        e * this.options.skewingDelta,
                        this.options.skewingDeltaMax
                      ) * this.skewing,
                    i = (180 * Math.atan2(this.vel.y, this.vel.x)) / Math.PI;
                  this.setter.rotation(i),
                    this.setter.scaleX(1 + n),
                    this.setter.scaleY(1 - n),
                    this.setter.inner.rotation(-i);
                }
              } else this.setter.wc("auto");
            }),
            (e.show = function () {
              var t = this;
              this.trigger("show"),
                clearInterval(this.visibleInt),
                (this.visibleInt = setTimeout(function () {
                  t.el.classList.remove(t.options.hiddenState),
                    (t.visible = !0),
                    t.render(!0);
                }, this.options.showTimeout));
            }),
            (e.hide = function () {
              var t = this;
              this.trigger("hide"),
                clearInterval(this.visibleInt),
                this.el.classList.add(this.options.hiddenState),
                (this.visibleInt = setTimeout(function () {
                  return (t.visible = !1);
                }, this.options.hideTimeout));
            }),
            (e.toggle = function (t) {
              !0 === t || (!1 !== t && !this.visible)
                ? this.show()
                : this.hide();
            }),
            (e.addState = function (t) {
              var e;
              if ((this.trigger("addState", t), t === this.options.hiddenState))
                return this.hide();
              (e = this.el.classList).add.apply(e, t.split(" ")),
                this.options.visibleOnState && this.show();
            }),
            (e.removeState = function (t) {
              var e;
              if (
                (this.trigger("removeState", t), t === this.options.hiddenState)
              )
                return this.show();
              (e = this.el.classList).remove.apply(e, t.split(" ")),
                this.options.visibleOnState &&
                  this.el.className === this.options.className &&
                  this.hide();
            }),
            (e.toggleState = function (t, e) {
              !0 === e || (!1 !== e && !this.el.classList.contains(t))
                ? this.addState(t)
                : this.removeState(t);
            }),
            (e.setSkewing = function (t) {
              this.gsap.to(this, {
                skewing: t,
              });
            }),
            (e.removeSkewing = function () {
              this.gsap.to(this, {
                skewing: this.options.skewing,
              });
            }),
            (e.setStick = function (t) {
              var e = (
                "string" == typeof t ? document.querySelector(t) : t
              ).getBoundingClientRect();
              this.stick = {
                y: e.top + e.height / 2,
                x: e.left + e.width / 2,
              };
            }),
            (e.removeStick = function () {
              this.stick = !1;
            }),
            (e.setText = function (t) {
              (this.text.innerHTML = t),
                this.addState(this.options.textState),
                this.setSkewing(this.options.skewingText);
            }),
            (e.removeText = function () {
              this.removeState(this.options.textState), this.removeSkewing();
            }),
            (e.setIcon = function (t, e) {
              void 0 === e && (e = ""),
                (this.text.innerHTML =
                  "<svg class='" +
                  this.options.iconSvgClassName +
                  " " +
                  this.options.iconSvgNamePrefix +
                  t +
                  "' style='" +
                  e +
                  "'><use xlink:href='" +
                  this.options.iconSvgSrc +
                  "#" +
                  t +
                  "'></use></svg>"),
                this.addState(this.options.iconState),
                this.setSkewing(this.options.skewingIcon);
            }),
            (e.removeIcon = function () {
              this.removeState(this.options.iconState), this.removeSkewing();
            }),
            (e.setMedia = function (t) {
              var e = this;
              clearTimeout(this.mediaInt),
                t &&
                  ((this.mediaBox.innerHTML = ""),
                  this.mediaBox.appendChild(t)),
                (this.mediaInt = setTimeout(function () {
                  return e.addState(e.options.mediaState);
                }, 20)),
                this.setSkewing(this.options.skewingMedia);
            }),
            (e.removeMedia = function () {
              var t = this;
              clearTimeout(this.mediaInt),
                this.removeState(this.options.mediaState),
                (this.mediaInt = setTimeout(function () {
                  return (t.mediaBox.innerHTML = "");
                }, this.options.hideMediaTimeout)),
                this.removeSkewing();
            }),
            (e.setImg = function (t) {
              this.mediaImg || (this.mediaImg = new Image()),
                this.mediaImg.src !== t && (this.mediaImg.src = t),
                this.setMedia(this.mediaImg);
            }),
            (e.removeImg = function () {
              this.removeMedia();
            }),
            (e.setVideo = function (t) {
              this.mediaVideo ||
                ((this.mediaVideo = document.createElement("video")),
                (this.mediaVideo.muted = !0),
                (this.mediaVideo.loop = !0),
                (this.mediaVideo.autoplay = !0)),
                this.mediaVideo.src !== t &&
                  ((this.mediaVideo.src = t), this.mediaVideo.load()),
                this.mediaVideo.play(),
                this.setMedia(this.mediaVideo);
            }),
            (e.removeVideo = function () {
              this.mediaVideo &&
                this.mediaVideo.readyState > 2 &&
                this.mediaVideo.pause(),
                this.removeMedia();
            }),
            (e.on = function (t, e) {
              this.events[t] instanceof Array || this.off(t),
                this.events[t].push(e);
            }),
            (e.off = function (t, e) {
              this.events[t] = e
                ? this.events[t].filter(function (t) {
                    return t !== e;
                  })
                : [];
            }),
            (e.trigger = function (t) {
              var e = arguments,
                n = this;
              this.events[t] &&
                this.events[t].forEach(function (t) {
                  return t.call.apply(t, [n, n].concat([].slice.call(e, 1)));
                });
            }),
            (e.getFromDataset = function (t) {
              var e = t.dataset;
              return {
                state: e[this.options.dataAttr],
                show: e[this.options.dataAttr + "Show"],
                text: e[this.options.dataAttr + "Text"],
                icon: e[this.options.dataAttr + "Icon"],
                img: e[this.options.dataAttr + "Img"],
                video: e[this.options.dataAttr + "Video"],
                stick: e[this.options.dataAttr + "Stick"],
              };
            }),
            (e.destroy = function () {
              this.trigger("destroy"),
                this.gsap.ticker.remove(this.ticker),
                this.container.removeEventListener(
                  "mouseleave",
                  this.event.mouseleave
                ),
                this.container.removeEventListener(
                  "mouseenter",
                  this.event.mouseenter
                ),
                this.container.removeEventListener(
                  "mousedown",
                  this.event.mousedown
                ),
                this.container.removeEventListener(
                  "mouseup",
                  this.event.mouseup
                ),
                this.container.removeEventListener(
                  "mousemove",
                  this.event.mousemove
                ),
                this.container.removeEventListener(
                  "mousemove",
                  this.event.mousemoveOnce
                ),
                this.container.removeEventListener(
                  "mouseover",
                  this.event.mouseover
                ),
                this.container.removeEventListener(
                  "mouseout",
                  this.event.mouseout
                ),
                this.el &&
                  (this.container.removeChild(this.el),
                  (this.el = null),
                  (this.mediaImg = null),
                  (this.mediaVideo = null));
            }),
            t
          );
        })();
      function Fl(t, e) {
        return (
          (Fl = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          Fl(t, e)
        );
      }
      Il.registerGSAP(Zi);
      var Nl = (function (t) {
        var e, n;
        function i() {
          var e;
          return (e = t.apply(this, arguments) || this).initFollower(), e;
        }
        (n = t),
          ((e = i).prototype = Object.create(n.prototype)),
          (e.prototype.constructor = e),
          Fl(e, n);
        var r = i.prototype;
        return (
          (r.onLeave = function () {
            try {
              var t = this;
              return t.follower
                ? (t.follower.removeIcon(),
                  t.follower.removeText(),
                  t.follower.removeImg(),
                  t.follower.removeVideo(),
                  t.follower.removeState("-pointer"),
                  t.follower.removeState("-inverse"),
                  t.follower.removeState("-opaque"),
                  Promise.resolve())
                : Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.initFollower = function () {
            window.matchMedia("(pointer:fine)").matches &&
              (this.follower = new Il({
                className: "cb-cursor",
                innerClassName: "cb-cursor-inner",
                textClassName: "cb-cursor-text",
                mediaClassName: "cb-cursor-media",
                mediaBoxClassName: "cb-cursor-media-box",
                iconSvgClassName: "cb-svgsprite",
                iconSvgSrc: "/assets/sprites/svgsprites.svg",
                skewing: 1.5,
                skewingMedia: 0.5,
              }));
          }),
          i
        );
      })(o);
      function Ul(t, e) {
        return (
          (Ul = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          Ul(t, e)
        );
      }
      var kl = (function (t) {
          var e, n;
          function i() {
            var e;
            return (
              ((e = t.apply(this, arguments) || this).showTl = e.tlShow()),
              (e.hideTl = e.tlHide()),
              e
            );
          }
          (n = t),
            ((e = i).prototype = Object.create(n.prototype)),
            (e.prototype.constructor = e),
            Ul(e, n);
          var r = i.prototype;
          return (
            (r.onInit = function () {
              try {
                return Promise.resolve(
                  new Promise(function (t) {
                    return setTimeout(t, 300);
                  })
                ).then(function () {});
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (r.onEnter = function () {
              try {
                var t = this;
                return Promise.resolve(
                  new Promise(function (t) {
                    return setTimeout(t, 100);
                  })
                ).then(function () {
                  return Promise.resolve(t.hide()).then(function () {});
                });
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (r.onRefresh = function () {
              return Promise.resolve();
            }),
            (r.onLeave = function () {
              try {
                return Promise.resolve(this.show()).then(function () {});
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (r.show = function () {
              try {
                return (
                  document.documentElement.classList.add("loader"),
                  Promise.resolve(this.showTl.play(0)).then(function () {})
                );
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (r.hide = function () {
              try {
                return (
                  document.documentElement.classList.remove("loader"),
                  Promise.resolve(this.hideTl.play(0)).then(function () {})
                );
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (r.tlShow = function () {
              var t = new Zi.timeline({
                paused: !0,
              });
              return (
                t.set(this.el, {
                  opacity: 1,
                  transformOrigin: "bottom center",
                  display: "block",
                  pointerEvents: "auto",
                  willChange: "transform",
                  immediateRender: !1,
                }),
                t.fromTo(
                  this.el,
                  {
                    scaleY: 0,
                  },
                  {
                    scaleY: 1,
                    duration: 0.6,
                    ease: "power4.inOut",
                    immediateRender: !1,
                  }
                ),
                t
              );
            }),
            (r.tlHide = function () {
              var t = new Zi.timeline({
                paused: !0,
              });
              return (
                t.set(this.el, {
                  scaleY: 1,
                  pointerEvents: "none",
                  willChange: "transform",
                }),
                t.to(this.el, {
                  opacity: 0,
                  duration: 0.7,
                  display: "none",
                }),
                t.set(this.el, {
                  willChange: "auto",
                }),
                t
              );
            }),
            i
          );
        })(o),
        zl = function (t) {
          var e = typeof t;
          return null != t && ("object" == e || "function" == e);
        },
        Bl =
          "object" == typeof global &&
          global &&
          global.Object === Object &&
          global,
        Hl = "object" == typeof self && self && self.Object === Object && self,
        Vl = Bl || Hl || Function("return this")(),
        Gl = function () {
          return Vl.Date.now();
        },
        Wl = /\s/,
        jl = /^\s+/,
        Xl = function (t) {
          return t
            ? t
                .slice(
                  0,
                  (function (t) {
                    for (var e = t.length; e-- && Wl.test(t.charAt(e)); );
                    return e;
                  })(t) + 1
                )
                .replace(jl, "")
            : t;
        },
        ql = Vl.Symbol,
        Yl = Object.prototype,
        Kl = Yl.hasOwnProperty,
        Zl = Yl.toString,
        $l = ql ? ql.toStringTag : void 0,
        Jl = Object.prototype.toString,
        Ql = ql ? ql.toStringTag : void 0,
        tc = function (t) {
          return null == t
            ? void 0 === t
              ? "[object Undefined]"
              : "[object Null]"
            : Ql && Ql in Object(t)
            ? (function (t) {
                var e = Kl.call(t, $l),
                  n = t[$l];
                try {
                  t[$l] = void 0;
                  var i = !0;
                } catch (t) {}
                var r = Zl.call(t);
                return i && (e ? (t[$l] = n) : delete t[$l]), r;
              })(t)
            : (function (t) {
                return Jl.call(t);
              })(t);
        },
        ec = /^[-+]0x[0-9a-f]+$/i,
        nc = /^0b[01]+$/i,
        ic = /^0o[0-7]+$/i,
        rc = parseInt,
        sc = function (t) {
          if ("number" == typeof t) return t;
          if (
            (function (t) {
              return (
                "symbol" == typeof t ||
                ((function (t) {
                  return null != t && "object" == typeof t;
                })(t) &&
                  "[object Symbol]" == tc(t))
              );
            })(t)
          )
            return NaN;
          if (zl(t)) {
            var e = "function" == typeof t.valueOf ? t.valueOf() : t;
            t = zl(e) ? e + "" : e;
          }
          if ("string" != typeof t) return 0 === t ? t : +t;
          t = Xl(t);
          var n = nc.test(t);
          return n || ic.test(t)
            ? rc(t.slice(2), n ? 2 : 8)
            : ec.test(t)
            ? NaN
            : +t;
        },
        oc = Math.max,
        ac = Math.min;
      function lc(t, e) {
        return (
          (lc = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          lc(t, e)
        );
      }
      var cc = (function (t) {
        var e, n;
        function i() {
          var e;
          return (
            (e = t.apply(this, arguments) || this).injectSvg(),
            e.bindMouseMove(),
            e.bindResizeObserver(),
            e
          );
        }
        (n = t),
          ((e = i).prototype = Object.create(n.prototype)),
          (e.prototype.constructor = e),
          lc(e, n);
        var r = i.prototype;
        return (
          (r.onInit = function () {
            try {
              var t = this;
              return Promise.resolve(t.app.wait("loader")).then(function () {
                t.magicShow();
              });
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.magicShow = function () {
            ta.create({
              trigger: this.el,
              animation: this.tlShow(),
            });
          }),
          (r.tlShow = function () {
            var t = new Zi.timeline();
            return (
              t.set(this.svg, {
                transformOrigin: "left center",
              }),
              t.from(this.svg, {
                scaleX: 0,
                duration: 3,
                ease: "expo.out",
              }),
              t
            );
          }),
          (r.getPathD = function (t, e, n) {
            return (
              t || (t = this.el.offsetWidth / 2),
              e || (e = 100),
              void 0 === n && (n = this.el.offsetWidth),
              "M0,100 Q" + t + "," + e + " " + n + ",100"
            );
          }),
          (r.injectSvg = function () {
            (this.el.innerHTML =
              "<svg><path d='" + this.getPathD() + "'/></svg>"),
              (this.svg = this.el.querySelector("svg")),
              (this.path = this.el.querySelector("path"));
          }),
          (r.update = function () {
            Zi.killTweensOf(this.path),
              this.path.setAttribute("d", this.getPathD());
          }),
          (r.bindMouseMove = function () {
            var t = this;
            if (!ta.isTouch) {
              var e = 0;
              this.el.addEventListener("mousemove", function (n) {
                var i = t.svg.getBoundingClientRect(),
                  r = n.pageX - i.left,
                  s = n.pageY - i.top;
                e || (e = s < 100 ? 50 : -50);
                var o = r,
                  a = 2 * s - 100 + e;
                Zi.to(t.path, {
                  attr: {
                    d: t.getPathD(o, a),
                  },
                  duration: 0.2,
                  overwrite: !0,
                });
              }),
                this.el.addEventListener("mouseleave", function () {
                  (e = 0),
                    Zi.to(t.path, {
                      attr: {
                        d: t.getPathD(),
                      },
                      duration: 2,
                      ease: "elastic.out(1, 0.2)",
                    });
                });
            }
          }),
          (r.bindResizeObserver = function () {
            var t = this;
            (this.updateDebounced = (function (t, e, n) {
              var i,
                r,
                s,
                o,
                a,
                l,
                c = 0,
                u = !1,
                h = !1,
                d = !0;
              if ("function" != typeof t)
                throw new TypeError("Expected a function");
              function p(e) {
                var n = i,
                  s = r;
                return (i = r = void 0), (c = e), (o = t.apply(s, n));
              }
              function f(t) {
                var n = t - l;
                return void 0 === l || n >= e || n < 0 || (h && t - c >= s);
              }
              function m() {
                var t = Gl();
                if (f(t)) return g(t);
                a = setTimeout(
                  m,
                  (function (t) {
                    var n = e - (t - l);
                    return h ? ac(n, s - (t - c)) : n;
                  })(t)
                );
              }
              function g(t) {
                return (a = void 0), d && i ? p(t) : ((i = r = void 0), o);
              }
              function v() {
                var t = Gl(),
                  n = f(t);
                if (((i = arguments), (r = this), (l = t), n)) {
                  if (void 0 === a)
                    return (function (t) {
                      return (c = t), (a = setTimeout(m, e)), u ? p(t) : o;
                    })(l);
                  if (h) return clearTimeout(a), (a = setTimeout(m, e)), p(l);
                }
                return void 0 === a && (a = setTimeout(m, e)), o;
              }
              return (
                (e = sc(e) || 0),
                zl(n) &&
                  ((u = !!n.leading),
                  (s = (h = "maxWait" in n) ? oc(sc(n.maxWait) || 0, e) : s),
                  (d = "trailing" in n ? !!n.trailing : d)),
                (v.cancel = function () {
                  void 0 !== a && clearTimeout(a),
                    (c = 0),
                    (i = l = r = a = void 0);
                }),
                (v.flush = function () {
                  return void 0 === a ? o : g(Gl());
                }),
                v
              );
            })(this.update.bind(this), 30)),
              (this.resizeObserver = new ResizeObserver(function () {
                return t.updateDebounced();
              })),
              this.resizeObserver.observe(this.el);
          }),
          i
        );
      })(o);
      function uc(t, e) {
        return (
          (uc = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          uc(t, e)
        );
      }
      var hc = (function (t) {
          var e, n;
          function i() {
            var e;
            return (
              ((e = t.apply(this, arguments) || this).layout =
                e.app.get("layout")),
              e
            );
          }
          (n = t),
            ((e = i).prototype = Object.create(n.prototype)),
            (e.prototype.constructor = e),
            uc(e, n);
          var r = i.prototype;
          return (
            (r.bindModalOpen = function () {
              var t = this;
              this.el.dataset.modalOpen &&
                this.el.addEventListener("click", function (e) {
                  var n = t.app.find(t.el.dataset.modalOpen, "modal");
                  n && (e.preventDefault(), e.stopPropagation(), n.open());
                });
            }),
            (r.bindScrollTo = function () {
              var t = this;
              this.el.dataset.scrollTo ||
                this.el.addEventListener("click", function (e) {
                  e.preventDefault(),
                    e.stopPropagation(),
                    t.layout.scrollToTarget(t.el.dataset.scrollTo);
                });
            }),
            i
          );
        })(o),
        dc =
          /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;
      function pc(t) {
        var e = t.nodeType,
          n = "";
        if (1 === e || 9 === e || 11 === e) {
          if ("string" == typeof t.textContent) return t.textContent;
          for (t = t.firstChild; t; t = t.nextSibling) n += pc(t);
        } else if (3 === e || 4 === e) return t.nodeValue;
        return n;
      }
      var fc,
        mc,
        gc,
        vc = /(?:\r|\n|\t\t)/g,
        _c = /(?:\s\s+)/g,
        yc = function (t) {
          return mc.getComputedStyle(t);
        },
        xc = Array.isArray,
        bc = [].slice,
        Sc = function (t, e) {
          var n;
          return xc(t)
            ? t
            : "string" == (n = typeof t) && !e && t
            ? bc.call(fc.querySelectorAll(t), 0)
            : t && "object" === n && "length" in t
            ? bc.call(t, 0)
            : t
            ? [t]
            : [];
        },
        Ec = function (t) {
          return "absolute" === t.position || !0 === t.absolute;
        },
        Tc = function (t, e) {
          for (var n, i = e.length; --i > -1; )
            if (((n = e[i]), t.substr(0, n.length) === n)) return n.length;
        },
        Mc = function (t, e) {
          void 0 === t && (t = "");
          var n = ~t.indexOf("++"),
            i = 1;
          return (
            n && (t = t.split("++").join("")),
            function () {
              return (
                "<" +
                e +
                " style='position:relative;display:inline-block;'" +
                (t ? " class='" + t + (n ? i++ : "") + "'>" : ">")
              );
            }
          );
        },
        wc = function t(e, n, i) {
          var r = e.nodeType;
          if (1 === r || 9 === r || 11 === r)
            for (e = e.firstChild; e; e = e.nextSibling) t(e, n, i);
          else
            (3 !== r && 4 !== r) ||
              (e.nodeValue = e.nodeValue.split(n).join(i));
        },
        Dc = function (t, e) {
          for (var n = e.length; --n > -1; ) t.push(e[n]);
        },
        Ac = function (t, e, n) {
          for (var i; t && t !== e; ) {
            if ((i = t._next || t.nextSibling))
              return i.textContent.charAt(0) === n;
            t = t.parentNode || t._parent;
          }
        },
        Cc = function t(e) {
          var n,
            i,
            r = Sc(e.childNodes),
            s = r.length;
          for (n = 0; n < s; n++)
            (i = r[n])._isSplit
              ? t(i)
              : n && i.previousSibling && 3 === i.previousSibling.nodeType
              ? ((i.previousSibling.nodeValue +=
                  3 === i.nodeType ? i.nodeValue : i.firstChild.nodeValue),
                e.removeChild(i))
              : 3 !== i.nodeType &&
                (e.insertBefore(i.firstChild, i), e.removeChild(i));
        },
        Pc = function (t, e) {
          return parseFloat(e[t]) || 0;
        },
        Rc = function (t, e, n, i, r, s, o) {
          var a,
            l,
            c,
            u,
            h,
            d,
            p,
            f,
            m,
            g,
            v,
            _,
            y = yc(t),
            x = Pc("paddingLeft", y),
            b = -999,
            S = Pc("borderBottomWidth", y) + Pc("borderTopWidth", y),
            E = Pc("borderLeftWidth", y) + Pc("borderRightWidth", y),
            T = Pc("paddingTop", y) + Pc("paddingBottom", y),
            M = Pc("paddingLeft", y) + Pc("paddingRight", y),
            w = Pc("fontSize", y) * (e.lineThreshold || 0.2),
            D = y.textAlign,
            A = [],
            C = [],
            P = [],
            R = e.wordDelimiter || " ",
            L = e.tag ? e.tag : e.span ? "span" : "div",
            O = e.type || e.split || "chars,words,lines",
            I = r && ~O.indexOf("lines") ? [] : null,
            F = ~O.indexOf("words"),
            N = ~O.indexOf("chars"),
            U = Ec(e),
            k = e.linesClass,
            z = ~(k || "").indexOf("++"),
            B = [],
            H = "flex" === y.display,
            V = t.style.display;
          for (
            z && (k = k.split("++").join("")),
              H && (t.style.display = "block"),
              c = (l = t.getElementsByTagName("*")).length,
              h = [],
              a = 0;
            a < c;
            a++
          )
            h[a] = l[a];
          if (I || U)
            for (a = 0; a < c; a++)
              ((d = (u = h[a]).parentNode === t) || U || (N && !F)) &&
                ((_ = u.offsetTop),
                I &&
                  d &&
                  Math.abs(_ - b) > w &&
                  ("BR" !== u.nodeName || 0 === a) &&
                  ((p = []), I.push(p), (b = _)),
                U &&
                  ((u._x = u.offsetLeft),
                  (u._y = _),
                  (u._w = u.offsetWidth),
                  (u._h = u.offsetHeight)),
                I &&
                  (((u._isSplit && d) ||
                    (!N && d) ||
                    (F && d) ||
                    (!F &&
                      u.parentNode.parentNode === t &&
                      !u.parentNode._isSplit)) &&
                    (p.push(u), (u._x -= x), Ac(u, t, R) && (u._wordEnd = !0)),
                  "BR" === u.nodeName &&
                    ((u.nextSibling && "BR" === u.nextSibling.nodeName) ||
                      0 === a) &&
                    I.push([])));
          for (a = 0; a < c; a++)
            if (((d = (u = h[a]).parentNode === t), "BR" !== u.nodeName))
              if (
                (U &&
                  ((m = u.style),
                  F ||
                    d ||
                    ((u._x += u.parentNode._x), (u._y += u.parentNode._y)),
                  (m.left = u._x + "px"),
                  (m.top = u._y + "px"),
                  (m.position = "absolute"),
                  (m.display = "block"),
                  (m.width = u._w + 1 + "px"),
                  (m.height = u._h + "px")),
                !F && N)
              )
                if (u._isSplit)
                  for (
                    u._next = l = u.nextSibling, u.parentNode.appendChild(u);
                    l && 3 === l.nodeType && " " === l.textContent;

                  )
                    (u._next = l.nextSibling),
                      u.parentNode.appendChild(l),
                      (l = l.nextSibling);
                else
                  u.parentNode._isSplit
                    ? ((u._parent = u.parentNode),
                      !u.previousSibling &&
                        u.firstChild &&
                        (u.firstChild._isFirst = !0),
                      u.nextSibling &&
                        " " === u.nextSibling.textContent &&
                        !u.nextSibling.nextSibling &&
                        B.push(u.nextSibling),
                      (u._next =
                        u.nextSibling && u.nextSibling._isFirst
                          ? null
                          : u.nextSibling),
                      u.parentNode.removeChild(u),
                      h.splice(a--, 1),
                      c--)
                    : d ||
                      ((_ = !u.nextSibling && Ac(u.parentNode, t, R)),
                      u.parentNode._parent &&
                        u.parentNode._parent.appendChild(u),
                      _ && u.parentNode.appendChild(fc.createTextNode(" ")),
                      "span" === L && (u.style.display = "inline"),
                      A.push(u));
              else
                u.parentNode._isSplit && !u._isSplit && "" !== u.innerHTML
                  ? C.push(u)
                  : N &&
                    !u._isSplit &&
                    ("span" === L && (u.style.display = "inline"), A.push(u));
            else
              I || U
                ? (u.parentNode && u.parentNode.removeChild(u),
                  h.splice(a--, 1),
                  c--)
                : F || t.appendChild(u);
          for (a = B.length; --a > -1; ) B[a].parentNode.removeChild(B[a]);
          if (I) {
            for (
              U &&
                ((g = fc.createElement(L)),
                t.appendChild(g),
                (v = g.offsetWidth + "px"),
                (_ = g.offsetParent === t ? 0 : t.offsetLeft),
                t.removeChild(g)),
                m = t.style.cssText,
                t.style.cssText = "display:none;";
              t.firstChild;

            )
              t.removeChild(t.firstChild);
            for (
              f = " " === R && (!U || (!F && !N)), a = 0;
              a < I.length;
              a++
            ) {
              for (
                p = I[a],
                  (g = fc.createElement(L)).style.cssText =
                    "display:block;text-align:" +
                    D +
                    ";position:" +
                    (U ? "absolute;" : "relative;"),
                  k && (g.className = k + (z ? a + 1 : "")),
                  P.push(g),
                  c = p.length,
                  l = 0;
                l < c;
                l++
              )
                "BR" !== p[l].nodeName &&
                  ((u = p[l]),
                  g.appendChild(u),
                  f && u._wordEnd && g.appendChild(fc.createTextNode(" ")),
                  U &&
                    (0 === l &&
                      ((g.style.top = u._y + "px"),
                      (g.style.left = x + _ + "px")),
                    (u.style.top = "0px"),
                    _ && (u.style.left = u._x - _ + "px")));
              0 === c
                ? (g.innerHTML = "&nbsp;")
                : F || N || (Cc(g), wc(g, String.fromCharCode(160), " ")),
                U && ((g.style.width = v), (g.style.height = u._h + "px")),
                t.appendChild(g);
            }
            t.style.cssText = m;
          }
          U &&
            (o > t.clientHeight &&
              ((t.style.height = o - T + "px"),
              t.clientHeight < o && (t.style.height = o + S + "px")),
            s > t.clientWidth &&
              ((t.style.width = s - M + "px"),
              t.clientWidth < s && (t.style.width = s + E + "px"))),
            H &&
              (V ? (t.style.display = V) : t.style.removeProperty("display")),
            Dc(n, A),
            F && Dc(i, C),
            Dc(r, P);
        },
        Lc = function (t, e, n, i) {
          var r,
            s,
            o,
            a,
            l,
            c,
            u,
            h,
            d = e.tag ? e.tag : e.span ? "span" : "div",
            p = ~(e.type || e.split || "chars,words,lines").indexOf("chars"),
            f = Ec(e),
            m = e.wordDelimiter || " ",
            g = " " !== m ? "" : f ? "&#173; " : " ",
            v = "</" + d + ">",
            _ = 1,
            y = e.specialChars
              ? "function" == typeof e.specialChars
                ? e.specialChars
                : Tc
              : null,
            x = fc.createElement("div"),
            b = t.parentNode;
          for (
            b.insertBefore(x, t),
              x.textContent = t.nodeValue,
              b.removeChild(t),
              u = -1 !== (r = pc((t = x))).indexOf("<"),
              !1 !== e.reduceWhiteSpace &&
                (r = r.replace(_c, " ").replace(vc, "")),
              u && (r = r.split("<").join("{{LT}}")),
              l = r.length,
              s = (" " === r.charAt(0) ? g : "") + n(),
              o = 0;
            o < l;
            o++
          )
            if (((c = r.charAt(o)), y && (h = y(r.substr(o), e.specialChars))))
              (c = r.substr(o, h || 1)),
                (s += p && " " !== c ? i() + c + "</" + d + ">" : c),
                (o += h - 1);
            else if (c === m && r.charAt(o - 1) !== m && o) {
              for (s += _ ? v : "", _ = 0; r.charAt(o + 1) === m; )
                (s += g), o++;
              o === l - 1
                ? (s += g)
                : ")" !== r.charAt(o + 1) && ((s += g + n()), (_ = 1));
            } else
              "{" === c && "{{LT}}" === r.substr(o, 6)
                ? ((s += p ? i() + "{{LT}}</" + d + ">" : "{{LT}}"), (o += 5))
                : (c.charCodeAt(0) >= 55296 && c.charCodeAt(0) <= 56319) ||
                  (r.charCodeAt(o + 1) >= 65024 && r.charCodeAt(o + 1) <= 65039)
                ? ((a =
                    ((r.substr(o, 12).split(dc) || [])[1] || "").length || 2),
                  (s +=
                    p && " " !== c
                      ? i() + r.substr(o, a) + "</" + d + ">"
                      : r.substr(o, a)),
                  (o += a - 1))
                : (s += p && " " !== c ? i() + c + "</" + d + ">" : c);
          (t.outerHTML = s + (_ ? v : "")), u && wc(b, "{{LT}}", "<");
        },
        Oc = function t(e, n, i, r) {
          var s,
            o,
            a = Sc(e.childNodes),
            l = a.length,
            c = Ec(n);
          if (3 !== e.nodeType || l > 1) {
            for (n.absolute = !1, s = 0; s < l; s++)
              ((o = a[s])._next = o._isFirst = o._parent = o._wordEnd = null),
                (3 !== o.nodeType || /\S+/.test(o.nodeValue)) &&
                  (c &&
                    3 !== o.nodeType &&
                    "inline" === yc(o).display &&
                    ((o.style.display = "inline-block"),
                    (o.style.position = "relative")),
                  (o._isSplit = !0),
                  t(o, n, i, r));
            return (n.absolute = c), void (e._isSplit = !0);
          }
          Lc(e, n, i, r);
        },
        Ic = (function () {
          function t(t, e) {
            gc || ((fc = document), (mc = window), (gc = 1)),
              (this.elements = Sc(t)),
              (this.chars = []),
              (this.words = []),
              (this.lines = []),
              (this._originals = []),
              (this.vars = e || {}),
              this.split(e);
          }
          var e = t.prototype;
          return (
            (e.split = function (t) {
              this.isSplit && this.revert(),
                (this.vars = t = t || this.vars),
                (this._originals.length =
                  this.chars.length =
                  this.words.length =
                  this.lines.length =
                    0);
              for (
                var e,
                  n,
                  i,
                  r = this.elements.length,
                  s = t.tag ? t.tag : t.span ? "span" : "div",
                  o = Mc(t.wordsClass, s),
                  a = Mc(t.charsClass, s);
                --r > -1;

              )
                (i = this.elements[r]),
                  (this._originals[r] = i.innerHTML),
                  (e = i.clientHeight),
                  (n = i.clientWidth),
                  Oc(i, t, o, a),
                  Rc(i, t, this.chars, this.words, this.lines, n, e);
              return (
                this.chars.reverse(),
                this.words.reverse(),
                this.lines.reverse(),
                (this.isSplit = !0),
                this
              );
            }),
            (e.revert = function () {
              var t = this._originals;
              if (!t) throw "revert() call wasn't scoped properly.";
              return (
                this.elements.forEach(function (e, n) {
                  return (e.innerHTML = t[n]);
                }),
                (this.chars = []),
                (this.words = []),
                (this.lines = []),
                (this.isSplit = !1),
                this
              );
            }),
            (t.create = function (e, n) {
              return new t(e, n);
            }),
            t
          );
        })();
      function Fc() {
        return (
          (Fc = Object.assign
            ? Object.assign.bind()
            : function (t) {
                for (var e = 1; e < arguments.length; e++) {
                  var n = arguments[e];
                  for (var i in n)
                    Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
                }
                return t;
              }),
          Fc.apply(this, arguments)
        );
      }
      Ic.version = "3.11.1";
      var Nc = function (t, e) {
          var n,
            i = Fc(
              {
                box: t,
                xDelta: 0.1,
                yDelta: 0.1,
                moveSpeed: 0.3,
                leaveSpeed: 0.3,
                moveEase: "power1.out",
                leaveEase: "power1.out",
                overwrite: !0,
              },
              e
            ),
            r = function (e, n, r) {
              Zi.to(
                t,
                Fc(
                  {
                    x: e,
                    y: n,
                    overwrite: i.overwrite,
                    onStart: function () {
                      return Zi.set(t, {
                        willChange: "transform",
                      });
                    },
                    onComplete: function () {
                      return Zi.set(t, {
                        willChange: "auto",
                      });
                    },
                  },
                  r
                )
              );
            };
          i.box.addEventListener("mouseenter", function () {
            n = t.getBoundingClientRect();
          }),
            i.box.addEventListener("mousemove", function (t) {
              var e = (t.clientY - n.top - n.height / 2) * i.yDelta,
                s = (t.clientX - n.left - n.width / 2) * i.xDelta;
              r(s, e, {
                duration: i.moveSpeed,
                ease: i.moveEase,
              });
            }),
            i.box.addEventListener("mouseleave", function () {
              r(0, 0, {
                duration: i.leaveSpeed,
                ease: i.leaveEase,
              });
            });
        },
        Uc = function (t, e) {
          void 0 === e && (e = {});
          var n = Fc(
              {
                type: "words",
                duration: 1.7,
                stagger: {
                  amount: 0.6,
                },
                ease: "expo.out",
              },
              e
            ),
            i = new Zi.timeline(),
            r = t.querySelectorAll(".cb-coin, img, video"),
            s = new Ic(t, {
              type: n.type,
            }),
            o = new Ic(s[n.type], {
              type: n.type,
            });
          return (
            Zi.set(s[n.type], {
              overflow: "hidden",
              verticalAlign: "top",
              padding: "0.15em",
              margin: "-0.15em",
            }),
            Zi.set(o[n.type], {
              y: "120%",
            }),
            i.set(
              o[n.type],
              {
                willChange: "transform",
              },
              0
            ),
            i.fromTo(
              o[n.type],
              {
                y: "120%",
              },
              {
                y: "0%",
                duration: n.duration,
                stagger: n.stagger,
                ease: n.ease,
              },
              0
            ),
            r.length &&
              (Zi.set(r, {
                scale: 0,
              }),
              i.fromTo(
                r,
                {
                  scale: 0,
                },
                {
                  scale: 1,
                  duration: n.duration,
                  stagger: n.stagger,
                  ease: n.ease,
                },
                0.2
              )),
            i.set(o[n.type], {
              willChange: "auto",
            }),
            i
          );
        },
        kc = function (t, e) {
          return (
            void 0 === e && (e = {}),
            ta.create({
              trigger: t,
              animation: Uc(t, e),
              once: !0,
            })
          );
        },
        zc = function (t, e) {
          void 0 === e && (e = {});
          var n = Fc(
            {
              from: 0,
              fromOpacity: 1,
              to: 1,
              toOpacity: 1,
              duration: 2,
              stagger: 0.1,
              ease: "expo.out",
            },
            e
          );
          return (
            Zi.set(t, {
              scale: n.from,
              opacity: n.fromOpacity,
            }),
            Zi.fromTo(
              t,
              {
                scale: n.from,
                opacity: n.fromOpacity,
              },
              {
                scale: n.to,
                opacity: n.toOpacity,
                duration: n.duration,
                stagger: n.stagger,
                ease: n.ease,
              }
            )
          );
        },
        Bc = function (t, e) {
          return (
            void 0 === e && (e = {}),
            ta.create({
              trigger: t,
              animation: zc(t, e),
              once: !0,
            })
          );
        },
        Hc = function (t, e) {
          void 0 === e && (e = {});
          var n = Fc(
              {
                fromY: 70,
                toY: 0,
                fromX: 0,
                toX: 0,
                duration: 2,
                opacityDuration: 1,
                stagger: 0.1,
                ease: "expo.out",
              },
              e
            ),
            i = new Zi.timeline();
          return (
            Zi.set(t, {
              opacity: 0,
              y: n.fromY,
            }),
            i.set(t, {
              willChange: "transform",
            }),
            i.fromTo(
              t,
              {
                opacity: 0,
              },
              {
                opacity: 1,
                duration: n.opacityDuration,
                stagger: n.stagger,
              },
              0
            ),
            i.fromTo(
              t,
              {
                y: n.fromY,
                x: n.fromX,
              },
              {
                y: n.toY,
                x: n.toX,
                duration: n.duration,
                stagger: n.stagger,
                ease: n.ease,
              },
              0
            ),
            i.set(t, {
              willChange: "auto",
            }),
            i
          );
        },
        Vc = function (t, e) {
          return (
            void 0 === e && (e = {}),
            ta.create({
              trigger: t,
              animation: Hc(t, e),
              once: !0,
            })
          );
        },
        Gc = function (t, e, n) {
          return (
            void 0 === e && (e = {}),
            void 0 === n && (n = {}),
            Zi.set(t, {
              opacity: 0,
            }),
            ta.batch(
              t,
              Fc(
                {
                  onEnter: function (t) {
                    return Hc(t, e);
                  },
                  once: !0,
                },
                n
              )
            )
          );
        },
        Wc = function (t, e) {
          void 0 === e && (e = {});
          var n = Fc(
              {
                from: 0,
                to: 1,
                duration: 2,
                stagger: 0.1,
                ease: "expo.out",
              },
              e
            ),
            i = new Zi.timeline();
          return (
            Zi.set(t, {
              opacity: 0,
            }),
            i.fromTo(
              t,
              {
                opacity: n.from,
              },
              {
                opacity: n.to,
                duration: n.duration,
                stagger: n.stagger,
              },
              0
            ),
            i
          );
        },
        jc = function (t, e) {
          return (
            void 0 === e && (e = {}),
            ta.create({
              trigger: t,
              animation: Wc(t, e),
              once: !0,
            })
          );
        },
        Xc = function (t, e) {
          void 0 === e && (e = {}),
            Fc(
              {
                from: 0,
                to: 1,
                duration: 2,
                stagger: 0.1,
                ease: "expo.out",
              },
              e
            );
          var n = new Zi.timeline(),
            i = t.querySelector(".cb-btn_cta-border"),
            r = t.querySelector(".cb-btn_cta-title");
          return (
            Zi.set(t, {
              pointerEvents: "none",
            }),
            n.set([i, r], {
              willChange: "transform",
            }),
            n.fromTo(
              i,
              {
                scaleY: 0.5,
                scaleX: 0,
              },
              {
                scaleY: 1,
                scaleX: 1,
                duration: 1.5,
                ease: "expo.out",
              },
              0
            ),
            n.fromTo(
              r,
              {
                scaleY: 0.5,
                scaleX: 0.5,
              },
              {
                scaleY: 1,
                scaleX: 1,
                duration: 1.5,
                ease: "expo.out",
              },
              0
            ),
            n.from(
              r,
              {
                y: "110%",
                duration: 1.2,
                ease: "expo.out",
              },
              0.1
            ),
            n.fromTo(
              i,
              {
                opacity: 0,
              },
              {
                opacity: 1,
                duration: 0.4,
              },
              0.2
            ),
            n.set(
              t,
              {
                pointerEvents: "auto",
              },
              0.6
            ),
            n.set([i, r], {
              willChange: "auto",
            }),
            n
          );
        },
        qc = function (t, e) {
          return (
            void 0 === e && (e = {}),
            ta.create({
              trigger: t,
              animation: Xc(t, e),
              once: !0,
            })
          );
        };
      function Yc(t, e) {
        return (
          (Yc = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          Yc(t, e)
        );
      }
      var Kc = (function (t) {
          var e, n;
          function i() {
            var e;
            return (
              ((e = t.apply(this, arguments) || this).cursor =
                e.app.get("cursor")),
              (e.ripple = e.el.querySelector(".cb-checkbox_cta-ripple")),
              e.bindHover(),
              e
            );
          }
          return (
            (n = t),
            ((e = i).prototype = Object.create(n.prototype)),
            (e.prototype.constructor = e),
            Yc(e, n),
            (i.prototype.bindHover = function () {
              var t = this;
              this.cursor.follower &&
                (this.el.addEventListener("mouseenter", function () {
                  t.cursor.follower.addState("-opaque");
                }),
                this.el.addEventListener("mouseleave", function () {
                  t.cursor.follower.removeState("-opaque");
                }),
                Nc(this.el, {
                  xDelta: 0.2,
                  yDelta: 0.2,
                  leaveSpeed: 2,
                  leaveEase: "elastic.out(1,0.4)",
                }));
            }),
            i
          );
        })(o),
        Zc = new Map();
      function $c(t) {
        var e = Zc.get(t);
        e && e.destroy();
      }
      function Jc(t) {
        var e = Zc.get(t);
        e && e.update();
      }
      var Qc = null;
      "undefined" == typeof window
        ? (((Qc = function (t) {
            return t;
          }).destroy = function (t) {
            return t;
          }),
          (Qc.update = function (t) {
            return t;
          }))
        : (((Qc = function (t, e) {
            return (
              t &&
                Array.prototype.forEach.call(t.length ? t : [t], function (t) {
                  return (function (t) {
                    if (
                      t &&
                      t.nodeName &&
                      "TEXTAREA" === t.nodeName &&
                      !Zc.has(t)
                    ) {
                      var e,
                        n = null,
                        i = window.getComputedStyle(t),
                        r =
                          ((e = t.value),
                          function () {
                            o({
                              testForHeightReduction:
                                "" === e || !t.value.startsWith(e),
                              restoreTextAlign: null,
                            }),
                              (e = t.value);
                          }),
                        s = function (e) {
                          t.removeEventListener("autosize:destroy", s),
                            t.removeEventListener("autosize:update", a),
                            t.removeEventListener("input", r),
                            window.removeEventListener("resize", a),
                            Object.keys(e).forEach(function (n) {
                              return (t.style[n] = e[n]);
                            }),
                            Zc.delete(t);
                        }.bind(t, {
                          height: t.style.height,
                          resize: t.style.resize,
                          textAlign: t.style.textAlign,
                          overflowY: t.style.overflowY,
                          overflowX: t.style.overflowX,
                          wordWrap: t.style.wordWrap,
                        });
                      t.addEventListener("autosize:destroy", s),
                        t.addEventListener("autosize:update", a),
                        t.addEventListener("input", r),
                        window.addEventListener("resize", a),
                        (t.style.overflowX = "hidden"),
                        (t.style.wordWrap = "break-word"),
                        Zc.set(t, {
                          destroy: s,
                          update: a,
                        }),
                        a();
                    }
                    function o(e) {
                      var r,
                        s,
                        a = e.restoreTextAlign,
                        l = void 0 === a ? null : a,
                        c = e.testForHeightReduction,
                        u = void 0 === c || c,
                        h = i.overflowY;
                      if (
                        0 !== t.scrollHeight &&
                        ("vertical" === i.resize
                          ? (t.style.resize = "none")
                          : "both" === i.resize &&
                            (t.style.resize = "horizontal"),
                        u &&
                          ((r = (function (t) {
                            for (
                              var e = [];
                              t &&
                              t.parentNode &&
                              t.parentNode instanceof Element;

                            )
                              t.parentNode.scrollTop &&
                                e.push([t.parentNode, t.parentNode.scrollTop]),
                                (t = t.parentNode);
                            return function () {
                              return e.forEach(function (t) {
                                var e = t[0],
                                  n = t[1];
                                (e.style.scrollBehavior = "auto"),
                                  (e.scrollTop = n),
                                  (e.style.scrollBehavior = null);
                              });
                            };
                          })(t)),
                          (t.style.height = "")),
                        (s =
                          "content-box" === i.boxSizing
                            ? t.scrollHeight -
                              (parseFloat(i.paddingTop) +
                                parseFloat(i.paddingBottom))
                            : t.scrollHeight +
                              parseFloat(i.borderTopWidth) +
                              parseFloat(i.borderBottomWidth)),
                        "none" !== i.maxHeight && s > parseFloat(i.maxHeight)
                          ? ("hidden" === i.overflowY &&
                              (t.style.overflow = "scroll"),
                            (s = parseFloat(i.maxHeight)))
                          : "hidden" !== i.overflowY &&
                            (t.style.overflow = "hidden"),
                        (t.style.height = s + "px"),
                        l && (t.style.textAlign = l),
                        r && r(),
                        n !== s &&
                          (t.dispatchEvent(
                            new Event("autosize:resized", {
                              bubbles: !0,
                            })
                          ),
                          (n = s)),
                        h !== i.overflow && !l)
                      ) {
                        var d = i.textAlign;
                        "hidden" === i.overflow &&
                          (t.style.textAlign = "start" === d ? "end" : "start"),
                          o({
                            restoreTextAlign: d,
                            testForHeightReduction: !0,
                          });
                      }
                    }
                    function a() {
                      o({
                        testForHeightReduction: !0,
                        restoreTextAlign: null,
                      });
                    }
                  })(t);
                }),
              t
            );
          }).destroy = function (t) {
            return t && Array.prototype.forEach.call(t.length ? t : [t], $c), t;
          }),
          (Qc.update = function (t) {
            return t && Array.prototype.forEach.call(t.length ? t : [t], Jc), t;
          }));
      var tu = Qc;
      function eu(t, e) {
        (t.prototype = Object.create(e.prototype)),
          (t.prototype.constructor = t),
          nu(t, e);
      }
      function nu(t, e) {
        return (
          (nu = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          nu(t, e)
        );
      }
      var iu = (function (t) {
          function e() {
            var e, n, i;
            return (
              ((i = t.apply(this, arguments) || this).input =
                i.el.querySelector("input, textarea")),
              (i.isTextarea =
                "TEXTAREA" === (null == (e = i.input) ? void 0 : e.tagName)),
              (i.validityMsg = JSON.parse(
                null != (n = i.el.dataset.validityMsg) ? n : "null"
              )),
              (i.message = i.el.querySelector(".cb-input_light-message")),
              i.bindInput(),
              i.isTextarea && i.bindAutosize(),
              i
            );
          }
          eu(e, t);
          var n = e.prototype;
          return (
            (n.bindInput = function () {
              var t = this;
              this.input &&
                this.input.addEventListener("change", function () {
                  t.el.classList.toggle("-filled", !!t.input.value),
                    t.checkValidity();
                });
            }),
            (n.bindAutosize = function () {
              tu(this.input),
                this.input.addEventListener("change", function () {
                  return ta.refresh();
                });
            }),
            (n.checkValidity = function () {
              var t = this.input.validity;
              if (t && this.validityMsg) {
                if ((this.el.classList.toggle("-error", !t.valid), t.valid))
                  return (this.message.innerHTML = ""), !0;
                for (var e in t)
                  if (t[e] && this.validityMsg[e]) {
                    this.message.innerHTML = this.validityMsg[e];
                    break;
                  }
                return !1;
              }
            }),
            (n.reset = function () {
              this.el.classList.remove("-filled -error");
            }),
            e
          );
        })(o),
        ru = (function (t) {
          function e() {
            var e, n, i;
            return (
              ((i = t.apply(this, arguments) || this).files = []),
              (i.overallSize = 0),
              (i.error = !1),
              (i.validity = JSON.parse(
                null != (e = i.el.dataset.validity) ? e : "null"
              )),
              (i.validityMsg = JSON.parse(
                null != (n = i.el.dataset.validityMsg) ? n : "null"
              )),
              (i.input = i.el.querySelector("[type=file]")),
              (i.isMultiple = !!i.input.multiple),
              (i.btn = i.el.querySelector(".cb-input_file-btn")),
              (i.items = i.el.querySelector(".cb-input_file-items")),
              (i.message = i.el.querySelector(".cb-input_file-message")),
              i.bindChange(),
              i
            );
          }
          eu(e, t);
          var n = e.prototype;
          return (
            (n.bindChange = function () {
              var t = this;
              this.btn.addEventListener("click", function () {
                return t.input.click();
              }),
                this.input.addEventListener("change", function () {
                  t.suppressAdd || t.addFiles(), (t.suppressAdd = !1);
                });
            }),
            (n.checkValidity = function () {
              this.validity &&
                this.validityMsg &&
                ((this.error = !1),
                this.files.length > this.validity.limit &&
                  (this.error = "limit"),
                this.overallSize > this.validity.size && (this.error = "size"),
                this.error
                  ? this.setError(this.validityMsg[this.error])
                  : this.removeError());
            }),
            (n.reset = function () {
              (this.input.innerHTML = ""),
                (this.files = []),
                this.updateFiles();
            }),
            (n.setError = function (t) {
              void 0 === t && (t = ""),
                this.el.classList.add("-error"),
                t && (this.message.innerHTML = t),
                this.input.setCustomValidity(t || "error");
            }),
            (n.removeError = function () {
              this.el.classList.remove("-error"),
                (this.message.innerHTML = ""),
                this.input.setCustomValidity("");
            }),
            (n.addFiles = function () {
              (this.files = this.isMultiple
                ? this.files.concat(Array.from(this.input.files))
                : this.input.files),
                this.updateFiles();
            }),
            (n.updateFiles = function () {
              var t = this,
                e = new DataTransfer(),
                n = document.createDocumentFragment();
              (this.overallSize = 0),
                this.files.forEach(function (i, r) {
                  var s = document.createElement("div");
                  (s.className = "cb-input_file-item"),
                    (s.innerHTML = "<i></i><b>" + i.name + "</b>"),
                    s.addEventListener("click", function () {
                      return t.removeFile(r);
                    }),
                    n.appendChild(s),
                    e.items.add(i),
                    (t.overallSize += i.size);
                }),
                (this.input.files = e.files),
                (this.items.innerHTML = ""),
                this.items.appendChild(n),
                this.checkValidity(),
                ta.refresh();
            }),
            (n.removeFile = function (t) {
              this.files.splice(t, 1),
                this.updateFiles(),
                (this.suppressAdd = !0),
                this.input.dispatchEvent(new Event("change"));
            }),
            e
          );
        })(o);
      function su(t, e) {
        return (
          (su = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          su(t, e)
        );
      }
      var ou = (function (t) {
        var e, n;
        function i() {
          var e;
          return (
            ((e = t.apply(this, arguments) || this).events = []),
            (e.autoDestroy = !1),
            (e.showTimeout = 30),
            (e.hideTimeout = 600),
            (e.dialog = e.el.querySelector("[data-modal-dialog]")),
            (e.closes = e.el.querySelectorAll("[data-modal-close]")),
            e.bindCloses(),
            e
          );
        }
        (n = t),
          ((e = i).prototype = Object.create(n.prototype)),
          (e.prototype.constructor = e),
          su(e, n);
        var r = i.prototype;
        return (
          (r.bindCloses = function () {
            var t = this;
            this.closes.forEach(function (e) {
              return e.addEventListener("click", function () {
                return t.hide();
              });
            });
          }),
          (r.open = function () {
            var t = this;
            this.trigger("show"),
              this.el.classList.add("-show"),
              document.documentElement.classList.add("modal"),
              clearInterval(this.visibleInt),
              (this.visibleInt = setTimeout(function () {
                t.el.classList.add("-visible"), t.trigger("showed");
              }, this.showTimeout));
          }),
          (r.hide = function () {
            var t = this;
            this.trigger("hide"),
              this.el.classList.remove("-visible"),
              document.documentElement.classList.remove("modal"),
              clearInterval(this.visibleInt),
              (this.visibleInt = setTimeout(function () {
                t.el.classList.remove("-show"),
                  t.trigger("hidden"),
                  t.autoDestroy && t.destroy();
              }, this.hideTimeout));
          }),
          (r.destroy = function () {
            this.el.parentNode.removeChild(this.el), this.trigger("destroy");
          }),
          (r.setContent = function (t) {
            this.dialog.innerHTML = t;
          }),
          (r.on = function (t, e) {
            this.events[t] instanceof Array || this.off(t),
              this.events[t].push(e);
          }),
          (r.off = function (t, e) {
            this.events[t] = e
              ? this.events[t].filter(function (t) {
                  return t !== e;
                })
              : [];
          }),
          (r.trigger = function (t) {
            for (
              var e = this,
                n = arguments.length,
                i = new Array(n > 1 ? n - 1 : 0),
                r = 1;
              r < n;
              r++
            )
              i[r - 1] = arguments[r];
            this.events[t] &&
              this.events[t].forEach(function (t) {
                return t.call.apply(t, [e, e].concat(i));
              });
          }),
          i
        );
      })(o);
      function au(t, e) {
        return (
          (au = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          au(t, e)
        );
      }
      var lu = (function (t) {
        var e, n;
        function i() {
          return t.apply(this, arguments) || this;
        }
        return (
          (n = t),
          ((e = i).prototype = Object.create(n.prototype)),
          (e.prototype.constructor = e),
          au(e, n),
          i
        );
      })(o);
      function cu(t, e) {
        return (
          (cu = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          cu(t, e)
        );
      }
      var uu = (function (t) {
        var e, n;
        function i() {
          var e;
          return (
            ((e = t.apply(this, arguments) || this).opened = !1),
            (e.toggleBtn = e.el.querySelector(".cb-menu-toggle button")),
            (e.box = e.el.querySelector(".cb-menu-box")),
            (e.backdrop = e.el.querySelector(".cb-menu-backdrop")),
            (e.fill = e.el.querySelector(".cb-menu-fill")),
            (e.content = e.el.querySelector(".cb-menu-content")),
            e
          );
        }
        (n = t),
          ((e = i).prototype = Object.create(n.prototype)),
          (e.prototype.constructor = e),
          cu(e, n);
        var r = i.prototype;
        return (
          (r.onInit = function () {
            try {
              var t = this;
              return (
                (t.tlClose = t.tlHide()),
                (t.tlOpen = t.tlShow()),
                t.bindToggle(),
                t.magicInverse(),
                Promise.resolve()
              );
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.onDestroy = function () {
            try {
              return (
                document.documentElement.classList.remove("menu-open"),
                Promise.resolve()
              );
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.bindToggle = function () {
            var t = this;
            this.toggleBtn.addEventListener("click", function () {
              return t.toggle();
            }),
              this.backdrop.addEventListener("click", function () {
                return t.hide();
              }),
              this.tlClose.eventCallback("onComplete", function () {
                t.box.classList.remove("-visible");
              }),
              this.el.addEventListener("mouseenter", function () {
                var e;
                t.el.classList.contains("-inverse") &&
                  (null == (e = t.app.get("cursor").follower) ||
                    e.addState("-inverse"));
              }),
              window.addEventListener("keyup", function (e) {
                "Escape" === e.key && t.toggle();
              }),
              ta.isTouch ||
                Nc(this.toggleBtn, {
                  leaveSpeed: 2,
                  leaveEase: "elastic.out(1,0.25)",
                });
          }),
          (r.toggle = function () {
            this.opened ? this.hide() : this.show();
          }),
          (r.show = function () {
            var t;
            (this.opened = !0),
              this.el.classList.add("-open"),
              document.documentElement.classList.add("menu-open"),
              this.tlClose.pause(),
              this.tlOpen.play(0),
              this.el.classList.contains("-inverse") &&
                (null == (t = this.app.get("cursor").follower) ||
                  t.removeState("-inverse"));
          }),
          (r.hide = function (t) {
            var e;
            void 0 === t && (t = !1),
              (this.opened = !1),
              this.el.classList.remove("-open"),
              document.documentElement.classList.remove("menu-open"),
              t
                ? (this.tlOpen.pause(0), this.tlClose.pause(0))
                : (this.tlOpen.pause(), this.tlClose.play(0)),
              this.el.classList.contains("-inverse") &&
                (null == (e = this.app.get("cursor").follower) ||
                  e.addState("-inverse"));
          }),
          (r.tlShow = function () {
            var t = new Zi.timeline({
              paused: !0,
            });
            return (
              t.set(
                this.box,
                {
                  display: "block",
                },
                0
              ),
              t.fromTo(
                this.backdrop,
                {
                  opacity: 0,
                },
                {
                  opacity: 1,
                  duration: 0.5,
                },
                0
              ),
              t.fromTo(
                this.fill,
                {
                  scaleX: 0,
                },
                {
                  scaleX: 1,
                  ease: "expo.out",
                  duration: 1,
                },
                0
              ),
              t.fromTo(
                this.content,
                {
                  xPercent: 50,
                },
                {
                  xPercent: 0,
                  ease: "expo.out",
                  duration: 1,
                },
                0
              ),
              t.fromTo(
                this.content,
                {
                  opacity: 0,
                },
                {
                  opacity: 1,
                  duration: 0.5,
                },
                0.15
              ),
              t
            );
          }),
          (r.tlHide = function () {
            var t = new Zi.timeline({
              paused: !0,
            });
            return (
              t.fromTo(
                this.backdrop,
                {
                  opacity: 1,
                },
                {
                  opacity: 0,
                  duration: 0.4,
                },
                0
              ),
              t.fromTo(
                this.fill,
                {
                  scaleX: 1,
                },
                {
                  scaleX: 0,
                  duration: 0.4,
                },
                0
              ),
              t.fromTo(
                this.content,
                {
                  xPercent: 0,
                },
                {
                  xPercent: 20,
                  duration: 0.4,
                },
                0
              ),
              t.fromTo(
                this.content,
                {
                  opacity: 1,
                },
                {
                  opacity: 0,
                  duration: 0.1,
                },
                0
              ),
              t.set(this.box, {
                display: "none",
              }),
              t
            );
          }),
          (r.magicInverse = function () {
            var t = this;
            document
              .querySelectorAll("[data-menu-inverse]")
              .forEach(function (e) {
                ta.create({
                  trigger: e,
                  start: "top top+=50px",
                  end: "bottom top+=70px",
                  toggleClass: {
                    targets: t.el,
                    className: "-inverse",
                  },
                  refreshPriority: -99999,
                });
              });
          }),
          i
        );
      })(o);
      function hu(t, e) {
        return (
          (hu = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          hu(t, e)
        );
      }
      var du = (function (t) {
        var e, n;
        function i() {
          var e;
          return (
            ((e = t.apply(this, arguments) || this).video =
              e.el.querySelector(".cb-intouch-video")),
            e
          );
        }
        (n = t),
          ((e = i).prototype = Object.create(n.prototype)),
          (e.prototype.constructor = e),
          hu(e, n);
        var r = i.prototype;
        return (
          (r.onInit = function () {
            try {
              return this.handleEnter(), this.initMagnetic(), Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.onEnter = function () {
            try {
              var t = this;
              return t.enterTl
                ? Promise.resolve(t.app.wait("loader", "enter")).then(
                    function () {
                      return Promise.resolve(t.enterTl.play(0)).then(
                        function () {}
                      );
                    }
                  )
                : Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.onRefresh = function () {
            try {
              return this.enterTl && this.enterTl.pause(0), Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.handleEnter = function () {
            this.el.offsetWidth && (this.enterTl = this.tlEnter());
          }),
          (r.tlEnter = function () {
            var t = new Zi.timeline({
              paused: !0,
            });
            return (
              t.from(this.el, {
                scale: 0,
                duration: 2,
                ease: "expo.out",
              }),
              t
            );
          }),
          (r.initMagnetic = function () {
            ta.isTouch ||
              Nc(this.video, {
                box: this.el,
                xDelta: 0.08,
                yDelta: 0.08,
                leaveSpeed: 2,
                leaveEase: "elastic.out(1,0.25)",
              });
          }),
          i
        );
      })(o);
      function pu(t, e) {
        return (
          (pu = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          pu(t, e)
        );
      }
      var fu = (function (t) {
        var e, n;
        function i() {
          var e;
          return (
            ((e = t.apply(this, arguments) || this).cursor =
              e.app.get("cursor")),
            (e.src = e.el.dataset.src),
            e.bindSwitch(),
            e.bindCursor(),
            e
          );
        }
        (n = t),
          ((e = i).prototype = Object.create(n.prototype)),
          (e.prototype.constructor = e),
          pu(e, n);
        var r = i.prototype;
        return (
          (r.bindSwitch = function () {
            var t = this;
            this.src &&
              this.el.addEventListener("click", function () {
                return t.injectFrame();
              });
          }),
          (r.bindCursor = function () {
            var t = this;
            this.cursor.follower &&
              (this.el.addEventListener("mouseenter", function () {
                return t.cursor.follower.hide();
              }),
              this.el.addEventListener("mouseleave", function () {
                return t.cursor.follower.show();
              }));
          }),
          (r.injectFrame = function () {
            this.el.innerHTML =
              "<iframe src='" +
              this.src +
              "' allow='accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture' allowfullscreen></iframe>";
          }),
          i
        );
      })(o);
      function mu(t, e) {
        return (
          (mu = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          mu(t, e)
        );
      }
      var gu = (function (t) {
          var e, n;
          function i() {
            var e;
            return (
              ((e = t.apply(this, arguments) || this).fill =
                e.el.querySelector(".cb-tophead-fill")),
              (e.header = e.el.querySelector(".cb-tophead-header")),
              (e.title = e.el.querySelector(".cb-tophead-title")),
              e
            );
          }
          (n = t),
            ((e = i).prototype = Object.create(n.prototype)),
            (e.prototype.constructor = e),
            mu(e, n);
          var r = i.prototype;
          return (
            (r.onInit = function () {
              try {
                return this.handleEnter(), Promise.resolve();
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (r.onEnter = function () {
              try {
                return this.enterTl && this.enterTl.play(), Promise.resolve();
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (r.handleEnter = function () {
              this.enterTl = this.tlEnter();
            }),
            (r.tlEnter = function () {
              var t = new Zi.timeline({
                paused: !0,
                delay: 0.4,
              });
              return (
                this.header &&
                  t.add(
                    Uc(this.header.firstElementChild, {
                      stagger: 0.1,
                    }),
                    0
                  ),
                this.title && t.add(Uc(this.title.firstElementChild), 0.1),
                this.fill &&
                  (t.set(this.fill, {
                    willChange: "transform",
                  }),
                  t.fromTo(
                    this.fill,
                    {
                      scaleY: window.innerHeight / this.el.offsetHeight,
                      transformOrigin: "top center",
                    },
                    {
                      scaleY: 1,
                      transformOrigin: "top center",
                      duration: 3,
                      ease: "expo.out",
                    },
                    0.5
                  ),
                  t.set(this.fill, {
                    willChange: "auto",
                  })),
                t
              );
            }),
            i
          );
        })(o),
        vu = !1;
      function _u(t, e) {
        return (
          (_u = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          _u(t, e)
        );
      }
      var yu = (function (t) {
        var e, n;
        function i() {
          var e, n;
          return (
            ((n = t.apply(this, arguments) || this).cursor =
              n.app.get("cursor")),
            (n.modalSuccess = n.app.find("#modal-contact-success", "modal")),
            (n.modalError = n.app.find("#modal-contact-error", "modal")),
            (n.modalErrorMessage =
              null == (e = n.modalError)
                ? void 0
                : e.el.querySelector(".cb-modal_box-message-message")),
            (n.header = n.el.querySelector(".cb-contact-header")),
            (n.form = n.el.querySelector(".cb-contact-form")),
            (n.input = n.form.querySelectorAll("input, select, textarea")),
            (n.submitBtn = n.el.querySelector("[type=submit]")),
            (n.attachments = n.app.get("input.file")),
            (function () {
              if (!vu) {
                var t = document.createElement("script");
                (t.async = !0),
                  (t.src =
                    "https://www.google.com/recaptcha/api.js?render=6Lewc_4ZAAAAAFQApM6YE6VtaTFKJgNHxePjQo7D"),
                  document.body.appendChild(t),
                  (vu = !0);
              }
            })(),
            n.bindForm(),
            n.bindInputs(),
            n.handleEnter(),
            n.checkValidity(),
            n
          );
        }
        (n = t),
          ((e = i).prototype = Object.create(n.prototype)),
          (e.prototype.constructor = e),
          _u(e, n);
        var r = i.prototype;
        return (
          (r.onEnter = function () {
            try {
              var t = this,
                e = (function () {
                  if (t.enterTl)
                    return Promise.resolve(t.enterTl.play()).then(
                      function () {}
                    );
                })();
              return Promise.resolve(
                e && e.then ? e.then(function () {}) : void 0
              );
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.handleEnter = function () {
            this.enterTl = this.tlEnter();
          }),
          (r.bindForm = function () {
            var t = this;
            this.form.addEventListener("submit", function (e) {
              try {
                return (
                  e.preventDefault(),
                  window.grecaptcha
                    ? window.grecaptcha.ready(function () {
                        window.grecaptcha
                          .execute("6Lewc_4ZAAAAAFQApM6YE6VtaTFKJgNHxePjQo7D", {
                            action: "submit",
                          })
                          .then(function (e) {
                            (t.reqRecaptchaToken = e), t.submit();
                          });
                      })
                    : t.submit(),
                  Promise.resolve()
                );
              } catch (e) {
                return Promise.reject(e);
              }
            });
          }),
          (r.bindInputs = function () {
            var t = this;
            this.input.forEach(function (e) {
              e.addEventListener("change", function () {
                return t.checkValidity();
              });
            });
          }),
          (r.checkValidity = function () {
            this.submitBtn.disabled = !this.form.checkValidity();
          }),
          (r.submit = function () {
            var t = this;
            (this.data = new FormData(this.form)),
              window.fbq && window.fbq("track", "Lead"),
              window.ym && window.ym(window.ymID, "reachGoal", "order"),
              this.reqRecaptchaToken &&
                this.data.append(
                  "g-recaptcha-response",
                  this.reqRecaptchaToken
                ),
              this.setLoadingState(),
              fetch(this.form.action, {
                method: "POST",
                body: this.data,
                cache: "no-cache",
              })
                .then(function (e) {
                  if (!e.ok) return t.setErrorState(e.statusText), !1;
                  t.setSuccessState();
                })
                .catch(function () {
                  t.setErrorState();
                });
          }),
          (r.reset = function () {
            this.form.reset(),
              this.attachments.reset(),
              this.submitBtn.setAttribute("disabled", !0);
          }),
          (r.setLoadingState = function () {
            var t, e;
            this.submitBtn.setAttribute("disabled", !0),
              null == (t = this.cursor) || t.follower.removeState("-opaque"),
              null == (e = this.cursor) || e.follower.addState("-loading");
          }),
          (r.removeLoadingState = function () {
            var t;
            this.submitBtn.removeAttribute("disabled"),
              null == (t = this.cursor) || t.follower.removeState("-loading");
          }),
          (r.setSuccessState = function () {
            this.removeLoadingState(), this.reset(), this.modalSuccess.open();
          }),
          (r.setErrorState = function (t) {
            this.removeLoadingState(),
              (this.modalErrorMessage.innerHTML = null != t ? t : ""),
              this.modalError.open();
          }),
          (r.tlEnter = function () {
            var t = new Zi.timeline({
                paused: !0,
                delay: 0.4,
              }),
              e = Array.from(
                this.el.querySelectorAll(
                  ".cb-contact-label, .cb-checkbox, .cb-contact-group"
                )
              ).filter(function (t) {
                return ta.isInViewport(t);
              });
            return (
              this.header && t.add(Uc(this.header.firstElementChild), 0),
              t.set(
                e,
                {
                  willChange: "transform",
                },
                0
              ),
              t.fromTo(
                e,
                {
                  y: window.innerWidth > 1e3 ? 50 : 30,
                  opacity: 0,
                },
                {
                  y: 0,
                  opacity: 1,
                  ease: "power3.out",
                  duration: 1,
                  stagger: 0.04,
                },
                0.2
              ),
              t.set(e, {
                willChange: "auto",
              }),
              t
            );
          }),
          i
        );
      })(o);
      function xu(t, e) {
        return (
          (xu = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          xu(t, e)
        );
      }
      var bu = (function (t) {
        var e, n;
        function i() {
          var e;
          return (
            ((e = t.apply(this, arguments) || this).cursor =
              e.app.get("cursor")),
            (e.filterModal = e.app.find("#modal-work-filters", "modal")),
            (e.filter = e.el.querySelector(".cb-work-filter")),
            (e.filterTitle = e.el.querySelector(".cb-work-filter-title")),
            (e.filterActive = e.filter.querySelector(".cb-work-filter-active")),
            (e.gridLeft = e.el.querySelector(".cb-work-col.-left")),
            (e.gridRight = e.el.querySelector(".cb-work-col.-right")),
            (e.itemLeft = Array.from(
              e.gridLeft.querySelectorAll(".cb-work-item")
            )),
            (e.itemRight = Array.from(
              e.gridRight.querySelectorAll(".cb-work-item")
            )),
            (e.itemLength = e.itemLeft.length + e.itemRight.length),
            (e.item = new Array(e.itemLength).fill(void 0).map(function (t, n) {
              return n % 2 == 0
                ? e.itemLeft[Math.floor(n / 2)]
                : n % 2 == 1
                ? e.itemRight[Math.floor(n / 2)]
                : void 0;
            })),
            e.bindFilter(),
            e
          );
        }
        (n = t),
          ((e = i).prototype = Object.create(n.prototype)),
          (e.prototype.constructor = e),
          xu(e, n);
        var r = i.prototype;
        return (
          (r.onInit = function () {
            try {
              var t = this;
              return Promise.resolve(document.fonts.ready).then(function () {
                t.handleEnter();
              });
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.onEnter = function () {
            try {
              return this.enterTl && this.enterTl.play(), Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.handleEnter = function () {
            this.enterTl = this.tlEnter();
          }),
          (r.bindFilter = function () {
            var t = this,
              e = this.filterModal.el.querySelectorAll(
                ".cb-modal_box-nav-item a"
              );
            this.cursor.follower &&
              this.filterModal.on("hide", function () {
                return t.cursor.follower.removeIcon();
              }),
              this.filterActive.addEventListener("click", function () {
                return t.openFilters();
              }),
              e.forEach(function (e) {
                e.addEventListener("click", function () {
                  t.filterSelect(e.dataset.filterTarget, e.innerText),
                    t.hideFilters();
                });
              });
          }),
          (r.filterSelect = function (t, e) {
            var n = this.item.filter(function (e) {
                return "all" === t || e.dataset.cat.indexOf(t) > -1;
              }),
              i = document.createDocumentFragment(),
              r = document.createDocumentFragment();
            n.forEach(function (t, e) {
              e % 2 == 0 && i.appendChild(t),
                e % 2 == 1 && r.appendChild(t),
                (t.style.display = "block");
            }),
              (this.filterActive.querySelector("span").innerHTML = e),
              (this.gridLeft.innerHTML = ""),
              this.gridLeft.appendChild(i),
              (this.gridRight.innerHTML = ""),
              this.gridRight.appendChild(r),
              ta.refresh();
          }),
          (r.openFilters = function () {
            this.filterModal.open();
          }),
          (r.hideFilters = function () {
            this.filterModal.hide();
          }),
          (r.tlEnter = function () {
            var t = this,
              e = new Zi.timeline({
                paused: !0,
                delay: 0.4,
              });
            return (
              Zi.set(this.item, {
                opacity: 0,
              }),
              this.filter &&
                e.add(Hc([this.filterTitle, this.filterActive]), 0),
              e.add(function () {
                return t.magicShow();
              }, 0.1),
              e
            );
          }),
          (r.magicShow = function () {
            this.item.length &&
              Gc(this.item, null, {
                interval: 0.2,
              });
          }),
          i
        );
      })(o);
      function Su(t, e) {
        return (
          (Su = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          Su(t, e)
        );
      }
      var Eu = (function (t) {
        var e, n;
        function i() {
          var e;
          return (
            ((e = t.apply(this, arguments) || this).header = e.el.querySelector(
              ".cb-entrylist-header"
            )),
            (e.filter = e.el.querySelectorAll(".cb-entrylist-filter")),
            (e.items = e.el.querySelector(".cb-entrylist-items")),
            (e.item = Array.from(e.el.querySelectorAll(".cb-entrylist-item"))),
            e
          );
        }
        (n = t),
          ((e = i).prototype = Object.create(n.prototype)),
          (e.prototype.constructor = e),
          Su(e, n);
        var r = i.prototype;
        return (
          (r.onInit = function () {
            try {
              return this.bindFilters(), this.handleEnter(), Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.onEnter = function () {
            try {
              var t = this,
                e = (function () {
                  if (t.enterTl)
                    return Promise.resolve(t.enterTl.play(0)).then(
                      function () {}
                    );
                })();
              return Promise.resolve(
                e && e.then ? e.then(function () {}) : void 0
              );
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.bindFilters = function () {
            var t = this;
            this.filter.forEach(function (e) {
              e.addEventListener("click", function () {
                t.smoothChangeCategory(e.dataset.filterId),
                  t.filter.forEach(function (t) {
                    t.classList.toggle("-active", t === e);
                  });
              });
            });
          }),
          (r.setCategoryFilter = function (t) {
            this.item.forEach(function (e) {
              e.toggleAttribute("hidden", !!t && t !== e.dataset.catId);
            });
          }),
          (r.smoothChangeCategory = function (t) {
            this.stItemShow &&
              this.stItemShow.forEach(function (t) {
                t.kill();
              }),
              this.setCategoryFilter(t),
              Zi.killTweensOf(this.item),
              Zi.set(this.item, {
                opacity: 1,
              });
          }),
          (r.handleEnter = function () {
            this.enterTl = this.tlEnter();
          }),
          (r.tlEnter = function () {
            var t = this,
              e = new Zi.timeline({
                paused: !0,
                delay: 0.4,
              });
            return (
              Zi.set(this.item, {
                opacity: 0,
              }),
              this.header &&
                e.add(
                  Uc(this.header.firstElementChild, {
                    stagger: 0.1,
                  }),
                  0
                ),
              this.filter.length &&
                e.fromTo(
                  this.filter,
                  {
                    y: window.innerWidth > 1e3 ? 50 : 30,
                    opacity: 0,
                  },
                  {
                    y: 0,
                    opacity: 1,
                    ease: "power3.out",
                    duration: 1,
                    stagger: 0.04,
                  },
                  0.2
                ),
              e.add(function () {
                return t.magicShow();
              }, 0.45),
              e
            );
          }),
          (r.magicShow = function () {
            this.item.length && (this.stItemShow = Gc(this.item));
          }),
          i
        );
      })(o);
      function Tu(t, e) {
        return (
          (Tu = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          Tu(t, e)
        );
      }
      var Mu = (function (t) {
        var e, n;
        function i() {
          var e;
          return (
            ((e = t.apply(this, arguments) || this).header = e.el.querySelector(
              ".cb-featured-header"
            )),
            (e.item = e.el.querySelectorAll(".cb-featured-item")),
            e
          );
        }
        (n = t),
          ((e = i).prototype = Object.create(n.prototype)),
          (e.prototype.constructor = e),
          Tu(e, n);
        var r = i.prototype;
        return (
          (r.onInit = function () {
            try {
              var t = this;
              return Promise.resolve(document.fonts.ready).then(function () {
                t.bindVideoPlay(), t.magicShow();
              });
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.bindVideoPlay = function () {
            ta.isTouch ||
              this.item.forEach(function (t) {
                var e = t.querySelector("video");
                t.addEventListener("mouseenter", function () {
                  return e.play();
                }),
                  t.addEventListener("mouseleave", function () {
                    return e.pause();
                  });
              });
          }),
          (r.magicShow = function () {
            this.header &&
              kc(this.header.firstElementChild, {
                type: "lines",
                stagger: 0.2,
              }),
              this.item.length && Gc(this.item);
          }),
          i
        );
      })(o);
      function wu(t) {
        return (
          null !== t &&
          "object" == typeof t &&
          "constructor" in t &&
          t.constructor === Object
        );
      }
      function Du(t = {}, e = {}) {
        Object.keys(e).forEach((n) => {
          void 0 === t[n]
            ? (t[n] = e[n])
            : wu(e[n]) &&
              wu(t[n]) &&
              Object.keys(e[n]).length > 0 &&
              Du(t[n], e[n]);
        });
      }
      const Au = {
        body: {},
        addEventListener() {},
        removeEventListener() {},
        activeElement: {
          blur() {},
          nodeName: "",
        },
        querySelector() {
          return null;
        },
        querySelectorAll() {
          return [];
        },
        getElementById() {
          return null;
        },
        createEvent() {
          return {
            initEvent() {},
          };
        },
        createElement() {
          return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute() {},
            getElementsByTagName() {
              return [];
            },
          };
        },
        createElementNS() {
          return {};
        },
        importNode() {
          return null;
        },
        location: {
          hash: "",
          host: "",
          hostname: "",
          href: "",
          origin: "",
          pathname: "",
          protocol: "",
          search: "",
        },
      };
      function Cu() {
        const t = "undefined" != typeof document ? document : {};
        return Du(t, Au), t;
      }
      const Pu = {
        document: Au,
        navigator: {
          userAgent: "",
        },
        location: {
          hash: "",
          host: "",
          hostname: "",
          href: "",
          origin: "",
          pathname: "",
          protocol: "",
          search: "",
        },
        history: {
          replaceState() {},
          pushState() {},
          go() {},
          back() {},
        },
        CustomEvent: function () {
          return this;
        },
        addEventListener() {},
        removeEventListener() {},
        getComputedStyle() {
          return {
            getPropertyValue() {
              return "";
            },
          };
        },
        Image() {},
        Date() {},
        screen: {},
        setTimeout() {},
        clearTimeout() {},
        matchMedia() {
          return {};
        },
        requestAnimationFrame(t) {
          return "undefined" == typeof setTimeout
            ? (t(), null)
            : setTimeout(t, 0);
        },
        cancelAnimationFrame(t) {
          "undefined" != typeof setTimeout && clearTimeout(t);
        },
      };
      function Ru() {
        const t = "undefined" != typeof window ? window : {};
        return Du(t, Pu), t;
      }
      function Lu(t, e = 0) {
        return setTimeout(t, e);
      }
      function Ou() {
        return Date.now();
      }
      function Iu(t) {
        return (
          "object" == typeof t &&
          null !== t &&
          t.constructor &&
          "Object" === Object.prototype.toString.call(t).slice(8, -1)
        );
      }
      function Fu(...t) {
        const e = Object(t[0]),
          n = ["__proto__", "constructor", "prototype"];
        for (let r = 1; r < t.length; r += 1) {
          const s = t[r];
          if (
            null != s &&
            ((i = s),
            !("undefined" != typeof window && void 0 !== window.HTMLElement
              ? i instanceof HTMLElement
              : i && (1 === i.nodeType || 11 === i.nodeType)))
          ) {
            const t = Object.keys(Object(s)).filter((t) => n.indexOf(t) < 0);
            for (let n = 0, i = t.length; n < i; n += 1) {
              const i = t[n],
                r = Object.getOwnPropertyDescriptor(s, i);
              void 0 !== r &&
                r.enumerable &&
                (Iu(e[i]) && Iu(s[i])
                  ? s[i].__swiper__
                    ? (e[i] = s[i])
                    : Fu(e[i], s[i])
                  : !Iu(e[i]) && Iu(s[i])
                  ? ((e[i] = {}),
                    s[i].__swiper__ ? (e[i] = s[i]) : Fu(e[i], s[i]))
                  : (e[i] = s[i]));
            }
          }
        }
        var i;
        return e;
      }
      function Nu(t, e, n) {
        t.style.setProperty(e, n);
      }
      function Uu({ swiper: t, targetPosition: e, side: n }) {
        const i = Ru(),
          r = -t.translate;
        let s,
          o = null;
        const a = t.params.speed;
        (t.wrapperEl.style.scrollSnapType = "none"),
          i.cancelAnimationFrame(t.cssModeFrameID);
        const l = e > r ? "next" : "prev",
          c = (t, e) => ("next" === l && t >= e) || ("prev" === l && t <= e),
          u = () => {
            (s = new Date().getTime()), null === o && (o = s);
            const l = Math.max(Math.min((s - o) / a, 1), 0),
              h = 0.5 - Math.cos(l * Math.PI) / 2;
            let d = r + h * (e - r);
            if (
              (c(d, e) && (d = e),
              t.wrapperEl.scrollTo({
                [n]: d,
              }),
              c(d, e))
            )
              return (
                (t.wrapperEl.style.overflow = "hidden"),
                (t.wrapperEl.style.scrollSnapType = ""),
                setTimeout(() => {
                  (t.wrapperEl.style.overflow = ""),
                    t.wrapperEl.scrollTo({
                      [n]: d,
                    });
                }),
                void i.cancelAnimationFrame(t.cssModeFrameID)
              );
            t.cssModeFrameID = i.requestAnimationFrame(u);
          };
        u();
      }
      function ku(t, e = "") {
        return [...t.children].filter((t) => t.matches(e));
      }
      function zu(t, e) {
        return Ru().getComputedStyle(t, null).getPropertyValue(e);
      }
      function Bu(t) {
        let e,
          n = t;
        if (n) {
          for (e = 0; null !== (n = n.previousSibling); )
            1 === n.nodeType && (e += 1);
          return e;
        }
      }
      function Hu(t, e, n) {
        const i = Ru();
        return n
          ? t["width" === e ? "offsetWidth" : "offsetHeight"] +
              parseFloat(
                i
                  .getComputedStyle(t, null)
                  .getPropertyValue(
                    "width" === e ? "margin-right" : "margin-top"
                  )
              ) +
              parseFloat(
                i
                  .getComputedStyle(t, null)
                  .getPropertyValue(
                    "width" === e ? "margin-left" : "margin-bottom"
                  )
              )
          : t.offsetWidth;
      }
      let Vu, Gu, Wu;
      function ju() {
        return (
          Vu ||
            (Vu = (function () {
              const t = Ru(),
                e = Cu();
              return {
                smoothScroll:
                  e.documentElement &&
                  "scrollBehavior" in e.documentElement.style,
                touch: !!(
                  "ontouchstart" in t ||
                  (t.DocumentTouch && e instanceof t.DocumentTouch)
                ),
              };
            })()),
          Vu
        );
      }
      var Xu = {
        on(t, e, n) {
          const i = this;
          if (!i.eventsListeners || i.destroyed) return i;
          if ("function" != typeof e) return i;
          const r = n ? "unshift" : "push";
          return (
            t.split(" ").forEach((t) => {
              i.eventsListeners[t] || (i.eventsListeners[t] = []),
                i.eventsListeners[t][r](e);
            }),
            i
          );
        },
        once(t, e, n) {
          const i = this;
          if (!i.eventsListeners || i.destroyed) return i;
          if ("function" != typeof e) return i;
          function r(...n) {
            i.off(t, r),
              r.__emitterProxy && delete r.__emitterProxy,
              e.apply(i, n);
          }
          return (r.__emitterProxy = e), i.on(t, r, n);
        },
        onAny(t, e) {
          const n = this;
          if (!n.eventsListeners || n.destroyed) return n;
          if ("function" != typeof t) return n;
          const i = e ? "unshift" : "push";
          return (
            n.eventsAnyListeners.indexOf(t) < 0 && n.eventsAnyListeners[i](t), n
          );
        },
        offAny(t) {
          const e = this;
          if (!e.eventsListeners || e.destroyed) return e;
          if (!e.eventsAnyListeners) return e;
          const n = e.eventsAnyListeners.indexOf(t);
          return n >= 0 && e.eventsAnyListeners.splice(n, 1), e;
        },
        off(t, e) {
          const n = this;
          return !n.eventsListeners || n.destroyed
            ? n
            : n.eventsListeners
            ? (t.split(" ").forEach((t) => {
                void 0 === e
                  ? (n.eventsListeners[t] = [])
                  : n.eventsListeners[t] &&
                    n.eventsListeners[t].forEach((i, r) => {
                      (i === e ||
                        (i.__emitterProxy && i.__emitterProxy === e)) &&
                        n.eventsListeners[t].splice(r, 1);
                    });
              }),
              n)
            : n;
        },
        emit(...t) {
          const e = this;
          if (!e.eventsListeners || e.destroyed) return e;
          if (!e.eventsListeners) return e;
          let n, i, r;
          return (
            "string" == typeof t[0] || Array.isArray(t[0])
              ? ((n = t[0]), (i = t.slice(1, t.length)), (r = e))
              : ((n = t[0].events), (i = t[0].data), (r = t[0].context || e)),
            i.unshift(r),
            (Array.isArray(n) ? n : n.split(" ")).forEach((t) => {
              e.eventsAnyListeners &&
                e.eventsAnyListeners.length &&
                e.eventsAnyListeners.forEach((e) => {
                  e.apply(r, [t, ...i]);
                }),
                e.eventsListeners &&
                  e.eventsListeners[t] &&
                  e.eventsListeners[t].forEach((t) => {
                    t.apply(r, i);
                  });
            }),
            e
          );
        },
      };
      const qu = (t, e) => {
          if (!t || t.destroyed || !t.params) return;
          const n = e.closest(
            t.isElement ? "swiper-slide" : `.${t.params.slideClass}`
          );
          if (n) {
            const e = n.querySelector(`.${t.params.lazyPreloaderClass}`);
            e && e.remove();
          }
        },
        Yu = (t, e) => {
          if (!t.slides[e]) return;
          const n = t.slides[e].querySelector('[loading="lazy"]');
          n && n.removeAttribute("loading");
        },
        Ku = (t) => {
          if (!t || t.destroyed || !t.params) return;
          let e = t.params.lazyPreloadPrevNext;
          const n = t.slides.length;
          if (!n || !e || e < 0) return;
          e = Math.min(e, n);
          const i =
              "auto" === t.params.slidesPerView
                ? t.slidesPerViewDynamic()
                : Math.ceil(t.params.slidesPerView),
            r = t.activeIndex,
            s = r + i - 1;
          if (t.params.rewind)
            for (let i = r - e; i <= s + e; i += 1) {
              const e = ((i % n) + n) % n;
              e !== r && e > s && Yu(t, e);
            }
          else
            for (
              let i = Math.max(s - e, 0);
              i <= Math.min(s + e, n - 1);
              i += 1
            )
              i !== r && i > s && Yu(t, i);
        };
      var Zu = {
          updateSize: function () {
            const t = this;
            let e, n;
            const i = t.el;
            (e =
              void 0 !== t.params.width && null !== t.params.width
                ? t.params.width
                : i.clientWidth),
              (n =
                void 0 !== t.params.height && null !== t.params.height
                  ? t.params.height
                  : i.clientHeight),
              (0 === e && t.isHorizontal()) ||
                (0 === n && t.isVertical()) ||
                ((e =
                  e -
                  parseInt(zu(i, "padding-left") || 0, 10) -
                  parseInt(zu(i, "padding-right") || 0, 10)),
                (n =
                  n -
                  parseInt(zu(i, "padding-top") || 0, 10) -
                  parseInt(zu(i, "padding-bottom") || 0, 10)),
                Number.isNaN(e) && (e = 0),
                Number.isNaN(n) && (n = 0),
                Object.assign(t, {
                  width: e,
                  height: n,
                  size: t.isHorizontal() ? e : n,
                }));
          },
          updateSlides: function () {
            const t = this;
            function e(e) {
              return t.isHorizontal()
                ? e
                : {
                    width: "height",
                    "margin-top": "margin-left",
                    "margin-bottom ": "margin-right",
                    "margin-left": "margin-top",
                    "margin-right": "margin-bottom",
                    "padding-left": "padding-top",
                    "padding-right": "padding-bottom",
                    marginRight: "marginBottom",
                  }[e];
            }
            function n(t, n) {
              return parseFloat(t.getPropertyValue(e(n)) || 0);
            }
            const i = t.params,
              {
                wrapperEl: r,
                slidesEl: s,
                size: o,
                rtlTranslate: a,
                wrongRTL: l,
              } = t,
              c = t.virtual && i.virtual.enabled,
              u = c ? t.virtual.slides.length : t.slides.length,
              h = ku(s, `.${t.params.slideClass}, swiper-slide`),
              d = c ? t.virtual.slides.length : h.length;
            let p = [];
            const f = [],
              m = [];
            let g = i.slidesOffsetBefore;
            "function" == typeof g && (g = i.slidesOffsetBefore.call(t));
            let v = i.slidesOffsetAfter;
            "function" == typeof v && (v = i.slidesOffsetAfter.call(t));
            const _ = t.snapGrid.length,
              y = t.slidesGrid.length;
            let x = i.spaceBetween,
              b = -g,
              S = 0,
              E = 0;
            if (void 0 === o) return;
            "string" == typeof x && x.indexOf("%") >= 0
              ? (x = (parseFloat(x.replace("%", "")) / 100) * o)
              : "string" == typeof x && (x = parseFloat(x)),
              (t.virtualSize = -x),
              h.forEach((t) => {
                a ? (t.style.marginLeft = "") : (t.style.marginRight = ""),
                  (t.style.marginBottom = ""),
                  (t.style.marginTop = "");
              }),
              i.centeredSlides &&
                i.cssMode &&
                (Nu(r, "--swiper-centered-offset-before", ""),
                Nu(r, "--swiper-centered-offset-after", ""));
            const T = i.grid && i.grid.rows > 1 && t.grid;
            let M;
            T && t.grid.initSlides(d);
            const w =
              "auto" === i.slidesPerView &&
              i.breakpoints &&
              Object.keys(i.breakpoints).filter(
                (t) => void 0 !== i.breakpoints[t].slidesPerView
              ).length > 0;
            for (let r = 0; r < d; r += 1) {
              let s;
              if (
                ((M = 0),
                h[r] && (s = h[r]),
                T && t.grid.updateSlide(r, s, d, e),
                !h[r] || "none" !== zu(s, "display"))
              ) {
                if ("auto" === i.slidesPerView) {
                  w && (h[r].style[e("width")] = "");
                  const o = getComputedStyle(s),
                    a = s.style.transform,
                    l = s.style.webkitTransform;
                  if (
                    (a && (s.style.transform = "none"),
                    l && (s.style.webkitTransform = "none"),
                    i.roundLengths)
                  )
                    M = t.isHorizontal()
                      ? Hu(s, "width", !0)
                      : Hu(s, "height", !0);
                  else {
                    const t = n(o, "width"),
                      e = n(o, "padding-left"),
                      i = n(o, "padding-right"),
                      r = n(o, "margin-left"),
                      a = n(o, "margin-right"),
                      l = o.getPropertyValue("box-sizing");
                    if (l && "border-box" === l) M = t + r + a;
                    else {
                      const { clientWidth: n, offsetWidth: o } = s;
                      M = t + e + i + r + a + (o - n);
                    }
                  }
                  a && (s.style.transform = a),
                    l && (s.style.webkitTransform = l),
                    i.roundLengths && (M = Math.floor(M));
                } else
                  (M = (o - (i.slidesPerView - 1) * x) / i.slidesPerView),
                    i.roundLengths && (M = Math.floor(M)),
                    h[r] && (h[r].style[e("width")] = `${M}px`);
                h[r] && (h[r].swiperSlideSize = M),
                  m.push(M),
                  i.centeredSlides
                    ? ((b = b + M / 2 + S / 2 + x),
                      0 === S && 0 !== r && (b = b - o / 2 - x),
                      0 === r && (b = b - o / 2 - x),
                      Math.abs(b) < 0.001 && (b = 0),
                      i.roundLengths && (b = Math.floor(b)),
                      E % i.slidesPerGroup == 0 && p.push(b),
                      f.push(b))
                    : (i.roundLengths && (b = Math.floor(b)),
                      (E - Math.min(t.params.slidesPerGroupSkip, E)) %
                        t.params.slidesPerGroup ==
                        0 && p.push(b),
                      f.push(b),
                      (b = b + M + x)),
                  (t.virtualSize += M + x),
                  (S = M),
                  (E += 1);
              }
            }
            if (
              ((t.virtualSize = Math.max(t.virtualSize, o) + v),
              a &&
                l &&
                ("slide" === i.effect || "coverflow" === i.effect) &&
                (r.style.width = `${t.virtualSize + x}px`),
              i.setWrapperSize &&
                (r.style[e("width")] = `${t.virtualSize + x}px`),
              T && t.grid.updateWrapperSize(M, p, e),
              !i.centeredSlides)
            ) {
              const e = [];
              for (let n = 0; n < p.length; n += 1) {
                let r = p[n];
                i.roundLengths && (r = Math.floor(r)),
                  p[n] <= t.virtualSize - o && e.push(r);
              }
              (p = e),
                Math.floor(t.virtualSize - o) - Math.floor(p[p.length - 1]) >
                  1 && p.push(t.virtualSize - o);
            }
            if (c && i.loop) {
              const e = m[0] + x;
              if (i.slidesPerGroup > 1) {
                const n = Math.ceil(
                    (t.virtual.slidesBefore + t.virtual.slidesAfter) /
                      i.slidesPerGroup
                  ),
                  r = e * i.slidesPerGroup;
                for (let t = 0; t < n; t += 1) p.push(p[p.length - 1] + r);
              }
              for (
                let n = 0;
                n < t.virtual.slidesBefore + t.virtual.slidesAfter;
                n += 1
              )
                1 === i.slidesPerGroup && p.push(p[p.length - 1] + e),
                  f.push(f[f.length - 1] + e),
                  (t.virtualSize += e);
            }
            if ((0 === p.length && (p = [0]), 0 !== x)) {
              const n = t.isHorizontal() && a ? "marginLeft" : e("marginRight");
              h.filter(
                (t, e) => !(i.cssMode && !i.loop) || e !== h.length - 1
              ).forEach((t) => {
                t.style[n] = `${x}px`;
              });
            }
            if (i.centeredSlides && i.centeredSlidesBounds) {
              let t = 0;
              m.forEach((e) => {
                t += e + (x || 0);
              }),
                (t -= x);
              const e = t - o;
              p = p.map((t) => (t < 0 ? -g : t > e ? e + v : t));
            }
            if (i.centerInsufficientSlides) {
              let t = 0;
              if (
                (m.forEach((e) => {
                  t += e + (x || 0);
                }),
                (t -= x),
                t < o)
              ) {
                const e = (o - t) / 2;
                p.forEach((t, n) => {
                  p[n] = t - e;
                }),
                  f.forEach((t, n) => {
                    f[n] = t + e;
                  });
              }
            }
            if (
              (Object.assign(t, {
                slides: h,
                snapGrid: p,
                slidesGrid: f,
                slidesSizesGrid: m,
              }),
              i.centeredSlides && i.cssMode && !i.centeredSlidesBounds)
            ) {
              Nu(r, "--swiper-centered-offset-before", -p[0] + "px"),
                Nu(
                  r,
                  "--swiper-centered-offset-after",
                  t.size / 2 - m[m.length - 1] / 2 + "px"
                );
              const e = -t.snapGrid[0],
                n = -t.slidesGrid[0];
              (t.snapGrid = t.snapGrid.map((t) => t + e)),
                (t.slidesGrid = t.slidesGrid.map((t) => t + n));
            }
            if (
              (d !== u && t.emit("slidesLengthChange"),
              p.length !== _ &&
                (t.params.watchOverflow && t.checkOverflow(),
                t.emit("snapGridLengthChange")),
              f.length !== y && t.emit("slidesGridLengthChange"),
              i.watchSlidesProgress && t.updateSlidesOffset(),
              !(
                c ||
                i.cssMode ||
                ("slide" !== i.effect && "fade" !== i.effect)
              ))
            ) {
              const e = `${i.containerModifierClass}backface-hidden`,
                n = t.el.classList.contains(e);
              d <= i.maxBackfaceHiddenSlides
                ? n || t.el.classList.add(e)
                : n && t.el.classList.remove(e);
            }
          },
          updateAutoHeight: function (t) {
            const e = this,
              n = [],
              i = e.virtual && e.params.virtual.enabled;
            let r,
              s = 0;
            "number" == typeof t
              ? e.setTransition(t)
              : !0 === t && e.setTransition(e.params.speed);
            const o = (t) =>
              i ? e.slides[e.getSlideIndexByData(t)] : e.slides[t];
            if ("auto" !== e.params.slidesPerView && e.params.slidesPerView > 1)
              if (e.params.centeredSlides)
                (e.visibleSlides || []).forEach((t) => {
                  n.push(t);
                });
              else
                for (r = 0; r < Math.ceil(e.params.slidesPerView); r += 1) {
                  const t = e.activeIndex + r;
                  if (t > e.slides.length && !i) break;
                  n.push(o(t));
                }
            else n.push(o(e.activeIndex));
            for (r = 0; r < n.length; r += 1)
              if (void 0 !== n[r]) {
                const t = n[r].offsetHeight;
                s = t > s ? t : s;
              }
            (s || 0 === s) && (e.wrapperEl.style.height = `${s}px`);
          },
          updateSlidesOffset: function () {
            const t = this,
              e = t.slides,
              n = t.isElement
                ? t.isHorizontal()
                  ? t.wrapperEl.offsetLeft
                  : t.wrapperEl.offsetTop
                : 0;
            for (let i = 0; i < e.length; i += 1)
              e[i].swiperSlideOffset =
                (t.isHorizontal() ? e[i].offsetLeft : e[i].offsetTop) -
                n -
                t.cssOverflowAdjustment();
          },
          updateSlidesProgress: function (t = (this && this.translate) || 0) {
            const e = this,
              n = e.params,
              { slides: i, rtlTranslate: r, snapGrid: s } = e;
            if (0 === i.length) return;
            void 0 === i[0].swiperSlideOffset && e.updateSlidesOffset();
            let o = -t;
            r && (o = t),
              i.forEach((t) => {
                t.classList.remove(n.slideVisibleClass);
              }),
              (e.visibleSlidesIndexes = []),
              (e.visibleSlides = []);
            let a = n.spaceBetween;
            "string" == typeof a && a.indexOf("%") >= 0
              ? (a = (parseFloat(a.replace("%", "")) / 100) * e.size)
              : "string" == typeof a && (a = parseFloat(a));
            for (let t = 0; t < i.length; t += 1) {
              const l = i[t];
              let c = l.swiperSlideOffset;
              n.cssMode && n.centeredSlides && (c -= i[0].swiperSlideOffset);
              const u =
                  (o + (n.centeredSlides ? e.minTranslate() : 0) - c) /
                  (l.swiperSlideSize + a),
                h =
                  (o - s[0] + (n.centeredSlides ? e.minTranslate() : 0) - c) /
                  (l.swiperSlideSize + a),
                d = -(o - c),
                p = d + e.slidesSizesGrid[t];
              ((d >= 0 && d < e.size - 1) ||
                (p > 1 && p <= e.size) ||
                (d <= 0 && p >= e.size)) &&
                (e.visibleSlides.push(l),
                e.visibleSlidesIndexes.push(t),
                i[t].classList.add(n.slideVisibleClass)),
                (l.progress = r ? -u : u),
                (l.originalProgress = r ? -h : h);
            }
          },
          updateProgress: function (t) {
            const e = this;
            if (void 0 === t) {
              const n = e.rtlTranslate ? -1 : 1;
              t = (e && e.translate && e.translate * n) || 0;
            }
            const n = e.params,
              i = e.maxTranslate() - e.minTranslate();
            let { progress: r, isBeginning: s, isEnd: o, progressLoop: a } = e;
            const l = s,
              c = o;
            if (0 === i) (r = 0), (s = !0), (o = !0);
            else {
              r = (t - e.minTranslate()) / i;
              const n = Math.abs(t - e.minTranslate()) < 1,
                a = Math.abs(t - e.maxTranslate()) < 1;
              (s = n || r <= 0), (o = a || r >= 1), n && (r = 0), a && (r = 1);
            }
            if (n.loop) {
              const n = e.getSlideIndexByData(0),
                i = e.getSlideIndexByData(e.slides.length - 1),
                r = e.slidesGrid[n],
                s = e.slidesGrid[i],
                o = e.slidesGrid[e.slidesGrid.length - 1],
                l = Math.abs(t);
              (a = l >= r ? (l - r) / o : (l + o - s) / o), a > 1 && (a -= 1);
            }
            Object.assign(e, {
              progress: r,
              progressLoop: a,
              isBeginning: s,
              isEnd: o,
            }),
              (n.watchSlidesProgress || (n.centeredSlides && n.autoHeight)) &&
                e.updateSlidesProgress(t),
              s && !l && e.emit("reachBeginning toEdge"),
              o && !c && e.emit("reachEnd toEdge"),
              ((l && !s) || (c && !o)) && e.emit("fromEdge"),
              e.emit("progress", r);
          },
          updateSlidesClasses: function () {
            const t = this,
              { slides: e, params: n, slidesEl: i, activeIndex: r } = t,
              s = t.virtual && n.virtual.enabled,
              o = (t) => ku(i, `.${n.slideClass}${t}, swiper-slide${t}`)[0];
            let a;
            if (
              (e.forEach((t) => {
                t.classList.remove(
                  n.slideActiveClass,
                  n.slideNextClass,
                  n.slidePrevClass
                );
              }),
              s)
            )
              if (n.loop) {
                let e = r - t.virtual.slidesBefore;
                e < 0 && (e = t.virtual.slides.length + e),
                  e >= t.virtual.slides.length &&
                    (e -= t.virtual.slides.length),
                  (a = o(`[data-swiper-slide-index="${e}"]`));
              } else a = o(`[data-swiper-slide-index="${r}"]`);
            else a = e[r];
            if (a) {
              a.classList.add(n.slideActiveClass);
              let t = (function (t, e) {
                const n = [];
                for (; t.nextElementSibling; ) {
                  const i = t.nextElementSibling;
                  e ? i.matches(e) && n.push(i) : n.push(i), (t = i);
                }
                return n;
              })(a, `.${n.slideClass}, swiper-slide`)[0];
              n.loop && !t && (t = e[0]),
                t && t.classList.add(n.slideNextClass);
              let i = (function (t, e) {
                const n = [];
                for (; t.previousElementSibling; ) {
                  const i = t.previousElementSibling;
                  e ? i.matches(e) && n.push(i) : n.push(i), (t = i);
                }
                return n;
              })(a, `.${n.slideClass}, swiper-slide`)[0];
              n.loop && 0 === !i && (i = e[e.length - 1]),
                i && i.classList.add(n.slidePrevClass);
            }
            t.emitSlidesClasses();
          },
          updateActiveIndex: function (t) {
            const e = this,
              n = e.rtlTranslate ? e.translate : -e.translate,
              {
                snapGrid: i,
                params: r,
                activeIndex: s,
                realIndex: o,
                snapIndex: a,
              } = e;
            let l,
              c = t;
            const u = (t) => {
              let n = t - e.virtual.slidesBefore;
              return (
                n < 0 && (n = e.virtual.slides.length + n),
                n >= e.virtual.slides.length && (n -= e.virtual.slides.length),
                n
              );
            };
            if (
              (void 0 === c &&
                (c = (function (t) {
                  const { slidesGrid: e, params: n } = t,
                    i = t.rtlTranslate ? t.translate : -t.translate;
                  let r;
                  for (let t = 0; t < e.length; t += 1)
                    void 0 !== e[t + 1]
                      ? i >= e[t] && i < e[t + 1] - (e[t + 1] - e[t]) / 2
                        ? (r = t)
                        : i >= e[t] && i < e[t + 1] && (r = t + 1)
                      : i >= e[t] && (r = t);
                  return (
                    n.normalizeSlideIndex && (r < 0 || void 0 === r) && (r = 0),
                    r
                  );
                })(e)),
              i.indexOf(n) >= 0)
            )
              l = i.indexOf(n);
            else {
              const t = Math.min(r.slidesPerGroupSkip, c);
              l = t + Math.floor((c - t) / r.slidesPerGroup);
            }
            if ((l >= i.length && (l = i.length - 1), c === s))
              return (
                l !== a && ((e.snapIndex = l), e.emit("snapIndexChange")),
                void (
                  e.params.loop &&
                  e.virtual &&
                  e.params.virtual.enabled &&
                  (e.realIndex = u(c))
                )
              );
            let h;
            (h =
              e.virtual && r.virtual.enabled && r.loop
                ? u(c)
                : e.slides[c]
                ? parseInt(
                    e.slides[c].getAttribute("data-swiper-slide-index") || c,
                    10
                  )
                : c),
              Object.assign(e, {
                previousSnapIndex: a,
                snapIndex: l,
                previousRealIndex: o,
                realIndex: h,
                previousIndex: s,
                activeIndex: c,
              }),
              e.initialized && Ku(e),
              e.emit("activeIndexChange"),
              e.emit("snapIndexChange"),
              o !== h && e.emit("realIndexChange"),
              (e.initialized || e.params.runCallbacksOnInit) &&
                e.emit("slideChange");
          },
          updateClickedSlide: function (t) {
            const e = this,
              n = e.params,
              i = t.closest(`.${n.slideClass}, swiper-slide`);
            let r,
              s = !1;
            if (i)
              for (let t = 0; t < e.slides.length; t += 1)
                if (e.slides[t] === i) {
                  (s = !0), (r = t);
                  break;
                }
            if (!i || !s)
              return (e.clickedSlide = void 0), void (e.clickedIndex = void 0);
            (e.clickedSlide = i),
              e.virtual && e.params.virtual.enabled
                ? (e.clickedIndex = parseInt(
                    i.getAttribute("data-swiper-slide-index"),
                    10
                  ))
                : (e.clickedIndex = r),
              n.slideToClickedSlide &&
                void 0 !== e.clickedIndex &&
                e.clickedIndex !== e.activeIndex &&
                e.slideToClickedSlide();
          },
        },
        $u = {
          getTranslate: function (t = this.isHorizontal() ? "x" : "y") {
            const {
              params: e,
              rtlTranslate: n,
              translate: i,
              wrapperEl: r,
            } = this;
            if (e.virtualTranslate) return n ? -i : i;
            if (e.cssMode) return i;
            let s = (function (t, e = "x") {
              const n = Ru();
              let i, r, s;
              const o = (function (t) {
                const e = Ru();
                let n;
                return (
                  e.getComputedStyle && (n = e.getComputedStyle(t, null)),
                  !n && t.currentStyle && (n = t.currentStyle),
                  n || (n = t.style),
                  n
                );
              })(t);
              return (
                n.WebKitCSSMatrix
                  ? ((r = o.transform || o.webkitTransform),
                    r.split(",").length > 6 &&
                      (r = r
                        .split(", ")
                        .map((t) => t.replace(",", "."))
                        .join(", ")),
                    (s = new n.WebKitCSSMatrix("none" === r ? "" : r)))
                  : ((s =
                      o.MozTransform ||
                      o.OTransform ||
                      o.MsTransform ||
                      o.msTransform ||
                      o.transform ||
                      o
                        .getPropertyValue("transform")
                        .replace("translate(", "matrix(1, 0, 0, 1,")),
                    (i = s.toString().split(","))),
                "x" === e &&
                  (r = n.WebKitCSSMatrix
                    ? s.m41
                    : 16 === i.length
                    ? parseFloat(i[12])
                    : parseFloat(i[4])),
                "y" === e &&
                  (r = n.WebKitCSSMatrix
                    ? s.m42
                    : 16 === i.length
                    ? parseFloat(i[13])
                    : parseFloat(i[5])),
                r || 0
              );
            })(r, t);
            return (s += this.cssOverflowAdjustment()), n && (s = -s), s || 0;
          },
          setTranslate: function (t, e) {
            const n = this,
              { rtlTranslate: i, params: r, wrapperEl: s, progress: o } = n;
            let a,
              l = 0,
              c = 0;
            n.isHorizontal() ? (l = i ? -t : t) : (c = t),
              r.roundLengths && ((l = Math.floor(l)), (c = Math.floor(c))),
              (n.previousTranslate = n.translate),
              (n.translate = n.isHorizontal() ? l : c),
              r.cssMode
                ? (s[n.isHorizontal() ? "scrollLeft" : "scrollTop"] =
                    n.isHorizontal() ? -l : -c)
                : r.virtualTranslate ||
                  (n.isHorizontal()
                    ? (l -= n.cssOverflowAdjustment())
                    : (c -= n.cssOverflowAdjustment()),
                  (s.style.transform = `translate3d(${l}px, ${c}px, 0px)`));
            const u = n.maxTranslate() - n.minTranslate();
            (a = 0 === u ? 0 : (t - n.minTranslate()) / u),
              a !== o && n.updateProgress(t),
              n.emit("setTranslate", n.translate, e);
          },
          minTranslate: function () {
            return -this.snapGrid[0];
          },
          maxTranslate: function () {
            return -this.snapGrid[this.snapGrid.length - 1];
          },
          translateTo: function (
            t = 0,
            e = this.params.speed,
            n = !0,
            i = !0,
            r
          ) {
            const s = this,
              { params: o, wrapperEl: a } = s;
            if (s.animating && o.preventInteractionOnTransition) return !1;
            const l = s.minTranslate(),
              c = s.maxTranslate();
            let u;
            if (
              ((u = i && t > l ? l : i && t < c ? c : t),
              s.updateProgress(u),
              o.cssMode)
            ) {
              const t = s.isHorizontal();
              if (0 === e) a[t ? "scrollLeft" : "scrollTop"] = -u;
              else {
                if (!s.support.smoothScroll)
                  return (
                    Uu({
                      swiper: s,
                      targetPosition: -u,
                      side: t ? "left" : "top",
                    }),
                    !0
                  );
                a.scrollTo({
                  [t ? "left" : "top"]: -u,
                  behavior: "smooth",
                });
              }
              return !0;
            }
            return (
              0 === e
                ? (s.setTransition(0),
                  s.setTranslate(u),
                  n &&
                    (s.emit("beforeTransitionStart", e, r),
                    s.emit("transitionEnd")))
                : (s.setTransition(e),
                  s.setTranslate(u),
                  n &&
                    (s.emit("beforeTransitionStart", e, r),
                    s.emit("transitionStart")),
                  s.animating ||
                    ((s.animating = !0),
                    s.onTranslateToWrapperTransitionEnd ||
                      (s.onTranslateToWrapperTransitionEnd = function (t) {
                        s &&
                          !s.destroyed &&
                          t.target === this &&
                          (s.wrapperEl.removeEventListener(
                            "transitionend",
                            s.onTranslateToWrapperTransitionEnd
                          ),
                          (s.onTranslateToWrapperTransitionEnd = null),
                          delete s.onTranslateToWrapperTransitionEnd,
                          n && s.emit("transitionEnd"));
                      }),
                    s.wrapperEl.addEventListener(
                      "transitionend",
                      s.onTranslateToWrapperTransitionEnd
                    ))),
              !0
            );
          },
        };
      function Ju({ swiper: t, runCallbacks: e, direction: n, step: i }) {
        const { activeIndex: r, previousIndex: s } = t;
        let o = n;
        if (
          (o || (o = r > s ? "next" : r < s ? "prev" : "reset"),
          t.emit(`transition${i}`),
          e && r !== s)
        ) {
          if ("reset" === o) return void t.emit(`slideResetTransition${i}`);
          t.emit(`slideChangeTransition${i}`),
            "next" === o
              ? t.emit(`slideNextTransition${i}`)
              : t.emit(`slidePrevTransition${i}`);
        }
      }
      var Qu = {
          slideTo: function (t = 0, e = this.params.speed, n = !0, i, r) {
            "string" == typeof t && (t = parseInt(t, 10));
            const s = this;
            let o = t;
            o < 0 && (o = 0);
            const {
              params: a,
              snapGrid: l,
              slidesGrid: c,
              previousIndex: u,
              activeIndex: h,
              rtlTranslate: d,
              wrapperEl: p,
              enabled: f,
            } = s;
            if (
              (s.animating && a.preventInteractionOnTransition) ||
              (!f && !i && !r)
            )
              return !1;
            const m = Math.min(s.params.slidesPerGroupSkip, o);
            let g = m + Math.floor((o - m) / s.params.slidesPerGroup);
            g >= l.length && (g = l.length - 1);
            const v = -l[g];
            if (a.normalizeSlideIndex)
              for (let t = 0; t < c.length; t += 1) {
                const e = -Math.floor(100 * v),
                  n = Math.floor(100 * c[t]),
                  i = Math.floor(100 * c[t + 1]);
                void 0 !== c[t + 1]
                  ? e >= n && e < i - (i - n) / 2
                    ? (o = t)
                    : e >= n && e < i && (o = t + 1)
                  : e >= n && (o = t);
              }
            if (s.initialized && o !== h) {
              if (!s.allowSlideNext && v < s.translate && v < s.minTranslate())
                return !1;
              if (
                !s.allowSlidePrev &&
                v > s.translate &&
                v > s.maxTranslate() &&
                (h || 0) !== o
              )
                return !1;
            }
            let _;
            if (
              (o !== (u || 0) && n && s.emit("beforeSlideChangeStart"),
              s.updateProgress(v),
              (_ = o > h ? "next" : o < h ? "prev" : "reset"),
              (d && -v === s.translate) || (!d && v === s.translate))
            )
              return (
                s.updateActiveIndex(o),
                a.autoHeight && s.updateAutoHeight(),
                s.updateSlidesClasses(),
                "slide" !== a.effect && s.setTranslate(v),
                "reset" !== _ &&
                  (s.transitionStart(n, _), s.transitionEnd(n, _)),
                !1
              );
            if (a.cssMode) {
              const t = s.isHorizontal(),
                n = d ? v : -v;
              if (0 === e) {
                const e = s.virtual && s.params.virtual.enabled;
                e &&
                  ((s.wrapperEl.style.scrollSnapType = "none"),
                  (s._immediateVirtual = !0)),
                  e && !s._cssModeVirtualInitialSet && s.params.initialSlide > 0
                    ? ((s._cssModeVirtualInitialSet = !0),
                      requestAnimationFrame(() => {
                        p[t ? "scrollLeft" : "scrollTop"] = n;
                      }))
                    : (p[t ? "scrollLeft" : "scrollTop"] = n),
                  e &&
                    requestAnimationFrame(() => {
                      (s.wrapperEl.style.scrollSnapType = ""),
                        (s._immediateVirtual = !1);
                    });
              } else {
                if (!s.support.smoothScroll)
                  return (
                    Uu({
                      swiper: s,
                      targetPosition: n,
                      side: t ? "left" : "top",
                    }),
                    !0
                  );
                p.scrollTo({
                  [t ? "left" : "top"]: n,
                  behavior: "smooth",
                });
              }
              return !0;
            }
            return (
              s.setTransition(e),
              s.setTranslate(v),
              s.updateActiveIndex(o),
              s.updateSlidesClasses(),
              s.emit("beforeTransitionStart", e, i),
              s.transitionStart(n, _),
              0 === e
                ? s.transitionEnd(n, _)
                : s.animating ||
                  ((s.animating = !0),
                  s.onSlideToWrapperTransitionEnd ||
                    (s.onSlideToWrapperTransitionEnd = function (t) {
                      s &&
                        !s.destroyed &&
                        t.target === this &&
                        (s.wrapperEl.removeEventListener(
                          "transitionend",
                          s.onSlideToWrapperTransitionEnd
                        ),
                        (s.onSlideToWrapperTransitionEnd = null),
                        delete s.onSlideToWrapperTransitionEnd,
                        s.transitionEnd(n, _));
                    }),
                  s.wrapperEl.addEventListener(
                    "transitionend",
                    s.onSlideToWrapperTransitionEnd
                  )),
              !0
            );
          },
          slideToLoop: function (t = 0, e = this.params.speed, n = !0, i) {
            "string" == typeof t && (t = parseInt(t, 10));
            const r = this;
            let s = t;
            return (
              r.params.loop &&
                (r.virtual && r.params.virtual.enabled
                  ? (s += r.virtual.slidesBefore)
                  : (s = r.getSlideIndexByData(s))),
              r.slideTo(s, e, n, i)
            );
          },
          slideNext: function (t = this.params.speed, e = !0, n) {
            const i = this,
              { enabled: r, params: s, animating: o } = i;
            if (!r) return i;
            let a = s.slidesPerGroup;
            "auto" === s.slidesPerView &&
              1 === s.slidesPerGroup &&
              s.slidesPerGroupAuto &&
              (a = Math.max(i.slidesPerViewDynamic("current", !0), 1));
            const l = i.activeIndex < s.slidesPerGroupSkip ? 1 : a,
              c = i.virtual && s.virtual.enabled;
            if (s.loop) {
              if (o && !c && s.loopPreventsSliding) return !1;
              i.loopFix({
                direction: "next",
              }),
                (i._clientLeft = i.wrapperEl.clientLeft);
            }
            return s.rewind && i.isEnd
              ? i.slideTo(0, t, e, n)
              : i.slideTo(i.activeIndex + l, t, e, n);
          },
          slidePrev: function (t = this.params.speed, e = !0, n) {
            const i = this,
              {
                params: r,
                snapGrid: s,
                slidesGrid: o,
                rtlTranslate: a,
                enabled: l,
                animating: c,
              } = i;
            if (!l) return i;
            const u = i.virtual && r.virtual.enabled;
            if (r.loop) {
              if (c && !u && r.loopPreventsSliding) return !1;
              i.loopFix({
                direction: "prev",
              }),
                (i._clientLeft = i.wrapperEl.clientLeft);
            }
            function h(t) {
              return t < 0 ? -Math.floor(Math.abs(t)) : Math.floor(t);
            }
            const d = h(a ? i.translate : -i.translate),
              p = s.map((t) => h(t));
            let f = s[p.indexOf(d) - 1];
            if (void 0 === f && r.cssMode) {
              let t;
              s.forEach((e, n) => {
                d >= e && (t = n);
              }),
                void 0 !== t && (f = s[t > 0 ? t - 1 : t]);
            }
            let m = 0;
            if (
              (void 0 !== f &&
                ((m = o.indexOf(f)),
                m < 0 && (m = i.activeIndex - 1),
                "auto" === r.slidesPerView &&
                  1 === r.slidesPerGroup &&
                  r.slidesPerGroupAuto &&
                  ((m = m - i.slidesPerViewDynamic("previous", !0) + 1),
                  (m = Math.max(m, 0)))),
              r.rewind && i.isBeginning)
            ) {
              const r =
                i.params.virtual && i.params.virtual.enabled && i.virtual
                  ? i.virtual.slides.length - 1
                  : i.slides.length - 1;
              return i.slideTo(r, t, e, n);
            }
            return i.slideTo(m, t, e, n);
          },
          slideReset: function (t = this.params.speed, e = !0, n) {
            return this.slideTo(this.activeIndex, t, e, n);
          },
          slideToClosest: function (t = this.params.speed, e = !0, n, i = 0.5) {
            const r = this;
            let s = r.activeIndex;
            const o = Math.min(r.params.slidesPerGroupSkip, s),
              a = o + Math.floor((s - o) / r.params.slidesPerGroup),
              l = r.rtlTranslate ? r.translate : -r.translate;
            if (l >= r.snapGrid[a]) {
              const t = r.snapGrid[a];
              l - t > (r.snapGrid[a + 1] - t) * i &&
                (s += r.params.slidesPerGroup);
            } else {
              const t = r.snapGrid[a - 1];
              l - t <= (r.snapGrid[a] - t) * i &&
                (s -= r.params.slidesPerGroup);
            }
            return (
              (s = Math.max(s, 0)),
              (s = Math.min(s, r.slidesGrid.length - 1)),
              r.slideTo(s, t, e, n)
            );
          },
          slideToClickedSlide: function () {
            const t = this,
              { params: e, slidesEl: n } = t,
              i =
                "auto" === e.slidesPerView
                  ? t.slidesPerViewDynamic()
                  : e.slidesPerView;
            let r,
              s = t.clickedIndex;
            const o = t.isElement ? "swiper-slide" : `.${e.slideClass}`;
            if (e.loop) {
              if (t.animating) return;
              (r = parseInt(
                t.clickedSlide.getAttribute("data-swiper-slide-index"),
                10
              )),
                e.centeredSlides
                  ? s < t.loopedSlides - i / 2 ||
                    s > t.slides.length - t.loopedSlides + i / 2
                    ? (t.loopFix(),
                      (s = t.getSlideIndex(
                        ku(n, `${o}[data-swiper-slide-index="${r}"]`)[0]
                      )),
                      Lu(() => {
                        t.slideTo(s);
                      }))
                    : t.slideTo(s)
                  : s > t.slides.length - i
                  ? (t.loopFix(),
                    (s = t.getSlideIndex(
                      ku(n, `${o}[data-swiper-slide-index="${r}"]`)[0]
                    )),
                    Lu(() => {
                      t.slideTo(s);
                    }))
                  : t.slideTo(s);
            } else t.slideTo(s);
          },
        },
        th = {
          loopCreate: function (t) {
            const e = this,
              { params: n, slidesEl: i } = e;
            !n.loop ||
              (e.virtual && e.params.virtual.enabled) ||
              (ku(i, `.${n.slideClass}, swiper-slide`).forEach((t, e) => {
                t.setAttribute("data-swiper-slide-index", e);
              }),
              e.loopFix({
                slideRealIndex: t,
                direction: n.centeredSlides ? void 0 : "next",
              }));
          },
          loopFix: function ({
            slideRealIndex: t,
            slideTo: e = !0,
            direction: n,
            setTranslate: i,
            activeSlideIndex: r,
            byController: s,
            byMousewheel: o,
          } = {}) {
            const a = this;
            if (!a.params.loop) return;
            a.emit("beforeLoopFix");
            const {
              slides: l,
              allowSlidePrev: c,
              allowSlideNext: u,
              slidesEl: h,
              params: d,
            } = a;
            if (
              ((a.allowSlidePrev = !0),
              (a.allowSlideNext = !0),
              a.virtual && d.virtual.enabled)
            )
              return (
                e &&
                  (d.centeredSlides || 0 !== a.snapIndex
                    ? d.centeredSlides && a.snapIndex < d.slidesPerView
                      ? a.slideTo(
                          a.virtual.slides.length + a.snapIndex,
                          0,
                          !1,
                          !0
                        )
                      : a.snapIndex === a.snapGrid.length - 1 &&
                        a.slideTo(a.virtual.slidesBefore, 0, !1, !0)
                    : a.slideTo(a.virtual.slides.length, 0, !1, !0)),
                (a.allowSlidePrev = c),
                (a.allowSlideNext = u),
                void a.emit("loopFix")
              );
            const p =
              "auto" === d.slidesPerView
                ? a.slidesPerViewDynamic()
                : Math.ceil(parseFloat(d.slidesPerView, 10));
            let f = d.loopedSlides || p;
            f % d.slidesPerGroup != 0 &&
              (f += d.slidesPerGroup - (f % d.slidesPerGroup)),
              (a.loopedSlides = f);
            const m = [],
              g = [];
            let v = a.activeIndex;
            void 0 === r
              ? (r = a.getSlideIndex(
                  a.slides.filter((t) =>
                    t.classList.contains(d.slideActiveClass)
                  )[0]
                ))
              : (v = r);
            const _ = "next" === n || !n,
              y = "prev" === n || !n;
            let x = 0,
              b = 0;
            if (r < f) {
              x = Math.max(f - r, d.slidesPerGroup);
              for (let t = 0; t < f - r; t += 1) {
                const e = t - Math.floor(t / l.length) * l.length;
                m.push(l.length - e - 1);
              }
            } else if (r > a.slides.length - 2 * f) {
              b = Math.max(r - (a.slides.length - 2 * f), d.slidesPerGroup);
              for (let t = 0; t < b; t += 1) {
                const e = t - Math.floor(t / l.length) * l.length;
                g.push(e);
              }
            }
            if (
              (y &&
                m.forEach((t) => {
                  (a.slides[t].swiperLoopMoveDOM = !0),
                    h.prepend(a.slides[t]),
                    (a.slides[t].swiperLoopMoveDOM = !1);
                }),
              _ &&
                g.forEach((t) => {
                  (a.slides[t].swiperLoopMoveDOM = !0),
                    h.append(a.slides[t]),
                    (a.slides[t].swiperLoopMoveDOM = !1);
                }),
              a.recalcSlides(),
              "auto" === d.slidesPerView && a.updateSlides(),
              d.watchSlidesProgress && a.updateSlidesOffset(),
              e)
            )
              if (m.length > 0 && y)
                if (void 0 === t) {
                  const t = a.slidesGrid[v],
                    e = a.slidesGrid[v + x] - t;
                  o
                    ? a.setTranslate(a.translate - e)
                    : (a.slideTo(v + x, 0, !1, !0),
                      i &&
                        (a.touches[a.isHorizontal() ? "startX" : "startY"] +=
                          e));
                } else i && a.slideToLoop(t, 0, !1, !0);
              else if (g.length > 0 && _)
                if (void 0 === t) {
                  const t = a.slidesGrid[v],
                    e = a.slidesGrid[v - b] - t;
                  o
                    ? a.setTranslate(a.translate - e)
                    : (a.slideTo(v - b, 0, !1, !0),
                      i &&
                        (a.touches[a.isHorizontal() ? "startX" : "startY"] +=
                          e));
                } else a.slideToLoop(t, 0, !1, !0);
            if (
              ((a.allowSlidePrev = c),
              (a.allowSlideNext = u),
              a.controller && a.controller.control && !s)
            ) {
              const e = {
                slideRealIndex: t,
                slideTo: !1,
                direction: n,
                setTranslate: i,
                activeSlideIndex: r,
                byController: !0,
              };
              Array.isArray(a.controller.control)
                ? a.controller.control.forEach((t) => {
                    !t.destroyed && t.params.loop && t.loopFix(e);
                  })
                : a.controller.control instanceof a.constructor &&
                  a.controller.control.params.loop &&
                  a.controller.control.loopFix(e);
            }
            a.emit("loopFix");
          },
          loopDestroy: function () {
            const t = this,
              { params: e, slidesEl: n } = t;
            if (!e.loop || (t.virtual && t.params.virtual.enabled)) return;
            t.recalcSlides();
            const i = [];
            t.slides.forEach((t) => {
              const e =
                void 0 === t.swiperSlideIndex
                  ? 1 * t.getAttribute("data-swiper-slide-index")
                  : t.swiperSlideIndex;
              i[e] = t;
            }),
              t.slides.forEach((t) => {
                t.removeAttribute("data-swiper-slide-index");
              }),
              i.forEach((t) => {
                n.append(t);
              }),
              t.recalcSlides(),
              t.slideTo(t.realIndex, 0);
          },
        };
      function eh(t) {
        const e = this,
          n = Cu(),
          i = Ru(),
          r = e.touchEventsData;
        r.evCache.push(t);
        const { params: s, touches: o, enabled: a } = e;
        if (!a) return;
        if (!s.simulateTouch && "mouse" === t.pointerType) return;
        if (e.animating && s.preventInteractionOnTransition) return;
        !e.animating && s.cssMode && s.loop && e.loopFix();
        let l = t;
        l.originalEvent && (l = l.originalEvent);
        let c = l.target;
        if ("wrapper" === s.touchEventsTarget && !e.wrapperEl.contains(c))
          return;
        if ("which" in l && 3 === l.which) return;
        if ("button" in l && l.button > 0) return;
        if (r.isTouched && r.isMoved) return;
        const u = !!s.noSwipingClass && "" !== s.noSwipingClass,
          h = t.composedPath ? t.composedPath() : t.path;
        u && l.target && l.target.shadowRoot && h && (c = h[0]);
        const d = s.noSwipingSelector
            ? s.noSwipingSelector
            : `.${s.noSwipingClass}`,
          p = !(!l.target || !l.target.shadowRoot);
        if (
          s.noSwiping &&
          (p
            ? (function (t, e = this) {
                return (function e(n) {
                  if (!n || n === Cu() || n === Ru()) return null;
                  n.assignedSlot && (n = n.assignedSlot);
                  const i = n.closest(t);
                  return i || n.getRootNode
                    ? i || e(n.getRootNode().host)
                    : null;
                })(e);
              })(d, c)
            : c.closest(d))
        )
          return void (e.allowClick = !0);
        if (s.swipeHandler && !c.closest(s.swipeHandler)) return;
        (o.currentX = l.pageX), (o.currentY = l.pageY);
        const f = o.currentX,
          m = o.currentY,
          g = s.edgeSwipeDetection || s.iOSEdgeSwipeDetection,
          v = s.edgeSwipeThreshold || s.iOSEdgeSwipeThreshold;
        if (g && (f <= v || f >= i.innerWidth - v)) {
          if ("prevent" !== g) return;
          t.preventDefault();
        }
        Object.assign(r, {
          isTouched: !0,
          isMoved: !1,
          allowTouchCallbacks: !0,
          isScrolling: void 0,
          startMoving: void 0,
        }),
          (o.startX = f),
          (o.startY = m),
          (r.touchStartTime = Ou()),
          (e.allowClick = !0),
          e.updateSize(),
          (e.swipeDirection = void 0),
          s.threshold > 0 && (r.allowThresholdMove = !1);
        let _ = !0;
        c.matches(r.focusableElements) &&
          ((_ = !1), "SELECT" === c.nodeName && (r.isTouched = !1)),
          n.activeElement &&
            n.activeElement.matches(r.focusableElements) &&
            n.activeElement !== c &&
            n.activeElement.blur();
        const y = _ && e.allowTouchMove && s.touchStartPreventDefault;
        (!s.touchStartForcePreventDefault && !y) ||
          c.isContentEditable ||
          l.preventDefault(),
          e.params.freeMode &&
            e.params.freeMode.enabled &&
            e.freeMode &&
            e.animating &&
            !s.cssMode &&
            e.freeMode.onTouchStart(),
          e.emit("touchStart", l);
      }
      function nh(t) {
        const e = Cu(),
          n = this,
          i = n.touchEventsData,
          { params: r, touches: s, rtlTranslate: o, enabled: a } = n;
        if (!a) return;
        if (!r.simulateTouch && "mouse" === t.pointerType) return;
        let l = t;
        if ((l.originalEvent && (l = l.originalEvent), !i.isTouched))
          return void (
            i.startMoving &&
            i.isScrolling &&
            n.emit("touchMoveOpposite", l)
          );
        const c = i.evCache.findIndex((t) => t.pointerId === l.pointerId);
        c >= 0 && (i.evCache[c] = l);
        const u = i.evCache.length > 1 ? i.evCache[0] : l,
          h = u.pageX,
          d = u.pageY;
        if (l.preventedByNestedSwiper)
          return (s.startX = h), void (s.startY = d);
        if (!n.allowTouchMove)
          return (
            l.target.matches(i.focusableElements) || (n.allowClick = !1),
            void (
              i.isTouched &&
              (Object.assign(s, {
                startX: h,
                startY: d,
                prevX: n.touches.currentX,
                prevY: n.touches.currentY,
                currentX: h,
                currentY: d,
              }),
              (i.touchStartTime = Ou()))
            )
          );
        if (r.touchReleaseOnEdges && !r.loop)
          if (n.isVertical()) {
            if (
              (d < s.startY && n.translate <= n.maxTranslate()) ||
              (d > s.startY && n.translate >= n.minTranslate())
            )
              return (i.isTouched = !1), void (i.isMoved = !1);
          } else if (
            (h < s.startX && n.translate <= n.maxTranslate()) ||
            (h > s.startX && n.translate >= n.minTranslate())
          )
            return;
        if (
          e.activeElement &&
          l.target === e.activeElement &&
          l.target.matches(i.focusableElements)
        )
          return (i.isMoved = !0), void (n.allowClick = !1);
        if (
          (i.allowTouchCallbacks && n.emit("touchMove", l),
          l.targetTouches && l.targetTouches.length > 1)
        )
          return;
        (s.currentX = h), (s.currentY = d);
        const p = s.currentX - s.startX,
          f = s.currentY - s.startY;
        if (
          n.params.threshold &&
          Math.sqrt(p ** 2 + f ** 2) < n.params.threshold
        )
          return;
        if (void 0 === i.isScrolling) {
          let t;
          (n.isHorizontal() && s.currentY === s.startY) ||
          (n.isVertical() && s.currentX === s.startX)
            ? (i.isScrolling = !1)
            : p * p + f * f >= 25 &&
              ((t = (180 * Math.atan2(Math.abs(f), Math.abs(p))) / Math.PI),
              (i.isScrolling = n.isHorizontal()
                ? t > r.touchAngle
                : 90 - t > r.touchAngle));
        }
        if (
          (i.isScrolling && n.emit("touchMoveOpposite", l),
          void 0 === i.startMoving &&
            ((s.currentX === s.startX && s.currentY === s.startY) ||
              (i.startMoving = !0)),
          i.isScrolling ||
            (n.zoom &&
              n.params.zoom &&
              n.params.zoom.enabled &&
              i.evCache.length > 1))
        )
          return void (i.isTouched = !1);
        if (!i.startMoving) return;
        (n.allowClick = !1),
          !r.cssMode && l.cancelable && l.preventDefault(),
          r.touchMoveStopPropagation && !r.nested && l.stopPropagation();
        let m = n.isHorizontal() ? p : f,
          g = n.isHorizontal()
            ? s.currentX - s.previousX
            : s.currentY - s.previousY;
        r.oneWayMovement &&
          ((m = Math.abs(m) * (o ? 1 : -1)), (g = Math.abs(g) * (o ? 1 : -1))),
          (s.diff = m),
          (m *= r.touchRatio),
          o && ((m = -m), (g = -g));
        const v = n.touchesDirection;
        (n.swipeDirection = m > 0 ? "prev" : "next"),
          (n.touchesDirection = g > 0 ? "prev" : "next");
        const _ = n.params.loop && !r.cssMode;
        if (!i.isMoved) {
          if (
            (_ &&
              n.loopFix({
                direction: n.swipeDirection,
              }),
            (i.startTranslate = n.getTranslate()),
            n.setTransition(0),
            n.animating)
          ) {
            const t = new window.CustomEvent("transitionend", {
              bubbles: !0,
              cancelable: !0,
            });
            n.wrapperEl.dispatchEvent(t);
          }
          (i.allowMomentumBounce = !1),
            !r.grabCursor ||
              (!0 !== n.allowSlideNext && !0 !== n.allowSlidePrev) ||
              n.setGrabCursor(!0),
            n.emit("sliderFirstMove", l);
        }
        let y;
        i.isMoved &&
          v !== n.touchesDirection &&
          _ &&
          Math.abs(m) >= 1 &&
          (n.loopFix({
            direction: n.swipeDirection,
            setTranslate: !0,
          }),
          (y = !0)),
          n.emit("sliderMove", l),
          (i.isMoved = !0),
          (i.currentTranslate = m + i.startTranslate);
        let x = !0,
          b = r.resistanceRatio;
        if (
          (r.touchReleaseOnEdges && (b = 0),
          m > 0
            ? (_ &&
                !y &&
                i.currentTranslate >
                  (r.centeredSlides
                    ? n.minTranslate() - n.size / 2
                    : n.minTranslate()) &&
                n.loopFix({
                  direction: "prev",
                  setTranslate: !0,
                  activeSlideIndex: 0,
                }),
              i.currentTranslate > n.minTranslate() &&
                ((x = !1),
                r.resistance &&
                  (i.currentTranslate =
                    n.minTranslate() -
                    1 +
                    (-n.minTranslate() + i.startTranslate + m) ** b)))
            : m < 0 &&
              (_ &&
                !y &&
                i.currentTranslate <
                  (r.centeredSlides
                    ? n.maxTranslate() + n.size / 2
                    : n.maxTranslate()) &&
                n.loopFix({
                  direction: "next",
                  setTranslate: !0,
                  activeSlideIndex:
                    n.slides.length -
                    ("auto" === r.slidesPerView
                      ? n.slidesPerViewDynamic()
                      : Math.ceil(parseFloat(r.slidesPerView, 10))),
                }),
              i.currentTranslate < n.maxTranslate() &&
                ((x = !1),
                r.resistance &&
                  (i.currentTranslate =
                    n.maxTranslate() +
                    1 -
                    (n.maxTranslate() - i.startTranslate - m) ** b))),
          x && (l.preventedByNestedSwiper = !0),
          !n.allowSlideNext &&
            "next" === n.swipeDirection &&
            i.currentTranslate < i.startTranslate &&
            (i.currentTranslate = i.startTranslate),
          !n.allowSlidePrev &&
            "prev" === n.swipeDirection &&
            i.currentTranslate > i.startTranslate &&
            (i.currentTranslate = i.startTranslate),
          n.allowSlidePrev ||
            n.allowSlideNext ||
            (i.currentTranslate = i.startTranslate),
          r.threshold > 0)
        ) {
          if (!(Math.abs(m) > r.threshold || i.allowThresholdMove))
            return void (i.currentTranslate = i.startTranslate);
          if (!i.allowThresholdMove)
            return (
              (i.allowThresholdMove = !0),
              (s.startX = s.currentX),
              (s.startY = s.currentY),
              (i.currentTranslate = i.startTranslate),
              void (s.diff = n.isHorizontal()
                ? s.currentX - s.startX
                : s.currentY - s.startY)
            );
        }
        r.followFinger &&
          !r.cssMode &&
          (((r.freeMode && r.freeMode.enabled && n.freeMode) ||
            r.watchSlidesProgress) &&
            (n.updateActiveIndex(), n.updateSlidesClasses()),
          n.params.freeMode &&
            r.freeMode.enabled &&
            n.freeMode &&
            n.freeMode.onTouchMove(),
          n.updateProgress(i.currentTranslate),
          n.setTranslate(i.currentTranslate));
      }
      function ih(t) {
        const e = this,
          n = e.touchEventsData,
          i = n.evCache.findIndex((e) => e.pointerId === t.pointerId);
        if (
          (i >= 0 && n.evCache.splice(i, 1),
          ["pointercancel", "pointerout", "pointerleave"].includes(t.type) &&
            ("pointercancel" !== t.type ||
              (!e.browser.isSafari && !e.browser.isWebView)))
        )
          return;
        const {
          params: r,
          touches: s,
          rtlTranslate: o,
          slidesGrid: a,
          enabled: l,
        } = e;
        if (!l) return;
        if (!r.simulateTouch && "mouse" === t.pointerType) return;
        let c = t;
        if (
          (c.originalEvent && (c = c.originalEvent),
          n.allowTouchCallbacks && e.emit("touchEnd", c),
          (n.allowTouchCallbacks = !1),
          !n.isTouched)
        )
          return (
            n.isMoved && r.grabCursor && e.setGrabCursor(!1),
            (n.isMoved = !1),
            void (n.startMoving = !1)
          );
        r.grabCursor &&
          n.isMoved &&
          n.isTouched &&
          (!0 === e.allowSlideNext || !0 === e.allowSlidePrev) &&
          e.setGrabCursor(!1);
        const u = Ou(),
          h = u - n.touchStartTime;
        if (e.allowClick) {
          const t = c.path || (c.composedPath && c.composedPath());
          e.updateClickedSlide((t && t[0]) || c.target),
            e.emit("tap click", c),
            h < 300 &&
              u - n.lastClickTime < 300 &&
              e.emit("doubleTap doubleClick", c);
        }
        if (
          ((n.lastClickTime = Ou()),
          Lu(() => {
            e.destroyed || (e.allowClick = !0);
          }),
          !n.isTouched ||
            !n.isMoved ||
            !e.swipeDirection ||
            0 === s.diff ||
            n.currentTranslate === n.startTranslate)
        )
          return (
            (n.isTouched = !1), (n.isMoved = !1), void (n.startMoving = !1)
          );
        let d;
        if (
          ((n.isTouched = !1),
          (n.isMoved = !1),
          (n.startMoving = !1),
          (d = r.followFinger
            ? o
              ? e.translate
              : -e.translate
            : -n.currentTranslate),
          r.cssMode)
        )
          return;
        if (e.params.freeMode && r.freeMode.enabled)
          return void e.freeMode.onTouchEnd({
            currentPos: d,
          });
        let p = 0,
          f = e.slidesSizesGrid[0];
        for (
          let t = 0;
          t < a.length;
          t += t < r.slidesPerGroupSkip ? 1 : r.slidesPerGroup
        ) {
          const e = t < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup;
          void 0 !== a[t + e]
            ? d >= a[t] && d < a[t + e] && ((p = t), (f = a[t + e] - a[t]))
            : d >= a[t] && ((p = t), (f = a[a.length - 1] - a[a.length - 2]));
        }
        let m = null,
          g = null;
        r.rewind &&
          (e.isBeginning
            ? (g =
                e.params.virtual && e.params.virtual.enabled && e.virtual
                  ? e.virtual.slides.length - 1
                  : e.slides.length - 1)
            : e.isEnd && (m = 0));
        const v = (d - a[p]) / f,
          _ = p < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup;
        if (h > r.longSwipesMs) {
          if (!r.longSwipes) return void e.slideTo(e.activeIndex);
          "next" === e.swipeDirection &&
            (v >= r.longSwipesRatio
              ? e.slideTo(r.rewind && e.isEnd ? m : p + _)
              : e.slideTo(p)),
            "prev" === e.swipeDirection &&
              (v > 1 - r.longSwipesRatio
                ? e.slideTo(p + _)
                : null !== g && v < 0 && Math.abs(v) > r.longSwipesRatio
                ? e.slideTo(g)
                : e.slideTo(p));
        } else {
          if (!r.shortSwipes) return void e.slideTo(e.activeIndex);
          !e.navigation ||
          (c.target !== e.navigation.nextEl && c.target !== e.navigation.prevEl)
            ? ("next" === e.swipeDirection && e.slideTo(null !== m ? m : p + _),
              "prev" === e.swipeDirection && e.slideTo(null !== g ? g : p))
            : c.target === e.navigation.nextEl
            ? e.slideTo(p + _)
            : e.slideTo(p);
        }
      }
      function rh() {
        const t = this,
          { params: e, el: n } = t;
        if (n && 0 === n.offsetWidth) return;
        e.breakpoints && t.setBreakpoint();
        const { allowSlideNext: i, allowSlidePrev: r, snapGrid: s } = t,
          o = t.virtual && t.params.virtual.enabled;
        (t.allowSlideNext = !0),
          (t.allowSlidePrev = !0),
          t.updateSize(),
          t.updateSlides(),
          t.updateSlidesClasses();
        const a = o && e.loop;
        !("auto" === e.slidesPerView || e.slidesPerView > 1) ||
        !t.isEnd ||
        t.isBeginning ||
        t.params.centeredSlides ||
        a
          ? t.params.loop && !o
            ? t.slideToLoop(t.realIndex, 0, !1, !0)
            : t.slideTo(t.activeIndex, 0, !1, !0)
          : t.slideTo(t.slides.length - 1, 0, !1, !0),
          t.autoplay &&
            t.autoplay.running &&
            t.autoplay.paused &&
            (clearTimeout(t.autoplay.resizeTimeout),
            (t.autoplay.resizeTimeout = setTimeout(() => {
              t.autoplay &&
                t.autoplay.running &&
                t.autoplay.paused &&
                t.autoplay.resume();
            }, 500))),
          (t.allowSlidePrev = r),
          (t.allowSlideNext = i),
          t.params.watchOverflow && s !== t.snapGrid && t.checkOverflow();
      }
      function sh(t) {
        const e = this;
        e.enabled &&
          (e.allowClick ||
            (e.params.preventClicks && t.preventDefault(),
            e.params.preventClicksPropagation &&
              e.animating &&
              (t.stopPropagation(), t.stopImmediatePropagation())));
      }
      function oh() {
        const t = this,
          { wrapperEl: e, rtlTranslate: n, enabled: i } = t;
        if (!i) return;
        let r;
        (t.previousTranslate = t.translate),
          t.isHorizontal()
            ? (t.translate = -e.scrollLeft)
            : (t.translate = -e.scrollTop),
          0 === t.translate && (t.translate = 0),
          t.updateActiveIndex(),
          t.updateSlidesClasses();
        const s = t.maxTranslate() - t.minTranslate();
        (r = 0 === s ? 0 : (t.translate - t.minTranslate()) / s),
          r !== t.progress && t.updateProgress(n ? -t.translate : t.translate),
          t.emit("setTranslate", t.translate, !1);
      }
      function ah(t) {
        qu(this, t.target), this.update();
      }
      let lh = !1;
      function ch() {}
      const uh = (t, e) => {
          const n = Cu(),
            { params: i, el: r, wrapperEl: s, device: o } = t,
            a = !!i.nested,
            l = "on" === e ? "addEventListener" : "removeEventListener",
            c = e;
          r[l]("pointerdown", t.onTouchStart, {
            passive: !1,
          }),
            n[l]("pointermove", t.onTouchMove, {
              passive: !1,
              capture: a,
            }),
            n[l]("pointerup", t.onTouchEnd, {
              passive: !0,
            }),
            n[l]("pointercancel", t.onTouchEnd, {
              passive: !0,
            }),
            n[l]("pointerout", t.onTouchEnd, {
              passive: !0,
            }),
            n[l]("pointerleave", t.onTouchEnd, {
              passive: !0,
            }),
            (i.preventClicks || i.preventClicksPropagation) &&
              r[l]("click", t.onClick, !0),
            i.cssMode && s[l]("scroll", t.onScroll),
            i.updateOnWindowResize
              ? t[c](
                  o.ios || o.android
                    ? "resize orientationchange observerUpdate"
                    : "resize observerUpdate",
                  rh,
                  !0
                )
              : t[c]("observerUpdate", rh, !0),
            r[l]("load", t.onLoad, {
              capture: !0,
            });
        },
        hh = (t, e) => t.grid && e.grid && e.grid.rows > 1;
      var dh = {
        init: !0,
        direction: "horizontal",
        oneWayMovement: !1,
        touchEventsTarget: "wrapper",
        initialSlide: 0,
        speed: 300,
        cssMode: !1,
        updateOnWindowResize: !0,
        resizeObserver: !0,
        nested: !1,
        createElements: !1,
        enabled: !0,
        focusableElements:
          "input, select, option, textarea, button, video, label",
        width: null,
        height: null,
        preventInteractionOnTransition: !1,
        userAgent: null,
        url: null,
        edgeSwipeDetection: !1,
        edgeSwipeThreshold: 20,
        autoHeight: !1,
        setWrapperSize: !1,
        virtualTranslate: !1,
        effect: "slide",
        breakpoints: void 0,
        breakpointsBase: "window",
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerGroup: 1,
        slidesPerGroupSkip: 0,
        slidesPerGroupAuto: !1,
        centeredSlides: !1,
        centeredSlidesBounds: !1,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: !0,
        centerInsufficientSlides: !1,
        watchOverflow: !0,
        roundLengths: !1,
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: !0,
        shortSwipes: !0,
        longSwipes: !0,
        longSwipesRatio: 0.5,
        longSwipesMs: 300,
        followFinger: !0,
        allowTouchMove: !0,
        threshold: 5,
        touchMoveStopPropagation: !1,
        touchStartPreventDefault: !0,
        touchStartForcePreventDefault: !1,
        touchReleaseOnEdges: !1,
        uniqueNavElements: !0,
        resistance: !0,
        resistanceRatio: 0.85,
        watchSlidesProgress: !1,
        grabCursor: !1,
        preventClicks: !0,
        preventClicksPropagation: !0,
        slideToClickedSlide: !1,
        loop: !1,
        loopedSlides: null,
        loopPreventsSliding: !0,
        rewind: !1,
        allowSlidePrev: !0,
        allowSlideNext: !0,
        swipeHandler: null,
        noSwiping: !0,
        noSwipingClass: "swiper-no-swiping",
        noSwipingSelector: null,
        passiveListeners: !0,
        maxBackfaceHiddenSlides: 10,
        containerModifierClass: "swiper-",
        slideClass: "swiper-slide",
        slideActiveClass: "swiper-slide-active",
        slideVisibleClass: "swiper-slide-visible",
        slideNextClass: "swiper-slide-next",
        slidePrevClass: "swiper-slide-prev",
        wrapperClass: "swiper-wrapper",
        lazyPreloaderClass: "swiper-lazy-preloader",
        lazyPreloadPrevNext: 0,
        runCallbacksOnInit: !0,
        _emitClasses: !1,
      };
      function ph(t, e) {
        return function (n = {}) {
          const i = Object.keys(n)[0],
            r = n[i];
          "object" == typeof r && null !== r
            ? (["navigation", "pagination", "scrollbar"].indexOf(i) >= 0 &&
                !0 === t[i] &&
                (t[i] = {
                  auto: !0,
                }),
              i in t && "enabled" in r
                ? (!0 === t[i] &&
                    (t[i] = {
                      enabled: !0,
                    }),
                  "object" != typeof t[i] ||
                    "enabled" in t[i] ||
                    (t[i].enabled = !0),
                  t[i] ||
                    (t[i] = {
                      enabled: !1,
                    }),
                  Fu(e, n))
                : Fu(e, n))
            : Fu(e, n);
        };
      }
      const fh = {
          eventsEmitter: Xu,
          update: Zu,
          translate: $u,
          transition: {
            setTransition: function (t, e) {
              const n = this;
              n.params.cssMode ||
                (n.wrapperEl.style.transitionDuration = `${t}ms`),
                n.emit("setTransition", t, e);
            },
            transitionStart: function (t = !0, e) {
              const n = this,
                { params: i } = n;
              i.cssMode ||
                (i.autoHeight && n.updateAutoHeight(),
                Ju({
                  swiper: n,
                  runCallbacks: t,
                  direction: e,
                  step: "Start",
                }));
            },
            transitionEnd: function (t = !0, e) {
              const n = this,
                { params: i } = n;
              (n.animating = !1),
                i.cssMode ||
                  (n.setTransition(0),
                  Ju({
                    swiper: n,
                    runCallbacks: t,
                    direction: e,
                    step: "End",
                  }));
            },
          },
          slide: Qu,
          loop: th,
          grabCursor: {
            setGrabCursor: function (t) {
              const e = this;
              if (
                !e.params.simulateTouch ||
                (e.params.watchOverflow && e.isLocked) ||
                e.params.cssMode
              )
                return;
              const n =
                "container" === e.params.touchEventsTarget ? e.el : e.wrapperEl;
              e.isElement && (e.__preventObserver__ = !0),
                (n.style.cursor = "move"),
                (n.style.cursor = t ? "grabbing" : "grab"),
                e.isElement &&
                  requestAnimationFrame(() => {
                    e.__preventObserver__ = !1;
                  });
            },
            unsetGrabCursor: function () {
              const t = this;
              (t.params.watchOverflow && t.isLocked) ||
                t.params.cssMode ||
                (t.isElement && (t.__preventObserver__ = !0),
                (t[
                  "container" === t.params.touchEventsTarget
                    ? "el"
                    : "wrapperEl"
                ].style.cursor = ""),
                t.isElement &&
                  requestAnimationFrame(() => {
                    t.__preventObserver__ = !1;
                  }));
            },
          },
          events: {
            attachEvents: function () {
              const t = this,
                e = Cu(),
                { params: n } = t;
              (t.onTouchStart = eh.bind(t)),
                (t.onTouchMove = nh.bind(t)),
                (t.onTouchEnd = ih.bind(t)),
                n.cssMode && (t.onScroll = oh.bind(t)),
                (t.onClick = sh.bind(t)),
                (t.onLoad = ah.bind(t)),
                lh || (e.addEventListener("touchstart", ch), (lh = !0)),
                uh(t, "on");
            },
            detachEvents: function () {
              uh(this, "off");
            },
          },
          breakpoints: {
            setBreakpoint: function () {
              const t = this,
                { realIndex: e, initialized: n, params: i, el: r } = t,
                s = i.breakpoints;
              if (!s || (s && 0 === Object.keys(s).length)) return;
              const o = t.getBreakpoint(s, t.params.breakpointsBase, t.el);
              if (!o || t.currentBreakpoint === o) return;
              const a = (o in s ? s[o] : void 0) || t.originalParams,
                l = hh(t, i),
                c = hh(t, a),
                u = i.enabled;
              l && !c
                ? (r.classList.remove(
                    `${i.containerModifierClass}grid`,
                    `${i.containerModifierClass}grid-column`
                  ),
                  t.emitContainerClasses())
                : !l &&
                  c &&
                  (r.classList.add(`${i.containerModifierClass}grid`),
                  ((a.grid.fill && "column" === a.grid.fill) ||
                    (!a.grid.fill && "column" === i.grid.fill)) &&
                    r.classList.add(`${i.containerModifierClass}grid-column`),
                  t.emitContainerClasses()),
                ["navigation", "pagination", "scrollbar"].forEach((e) => {
                  const n = i[e] && i[e].enabled,
                    r = a[e] && a[e].enabled;
                  n && !r && t[e].disable(), !n && r && t[e].enable();
                });
              const h = a.direction && a.direction !== i.direction,
                d = i.loop && (a.slidesPerView !== i.slidesPerView || h);
              h && n && t.changeDirection(), Fu(t.params, a);
              const p = t.params.enabled;
              Object.assign(t, {
                allowTouchMove: t.params.allowTouchMove,
                allowSlideNext: t.params.allowSlideNext,
                allowSlidePrev: t.params.allowSlidePrev,
              }),
                u && !p ? t.disable() : !u && p && t.enable(),
                (t.currentBreakpoint = o),
                t.emit("_beforeBreakpoint", a),
                d && n && (t.loopDestroy(), t.loopCreate(e), t.updateSlides()),
                t.emit("breakpoint", a);
            },
            getBreakpoint: function (t, e = "window", n) {
              if (!t || ("container" === e && !n)) return;
              let i = !1;
              const r = Ru(),
                s = "window" === e ? r.innerHeight : n.clientHeight,
                o = Object.keys(t).map((t) => {
                  if ("string" == typeof t && 0 === t.indexOf("@")) {
                    const e = parseFloat(t.substr(1));
                    return {
                      value: s * e,
                      point: t,
                    };
                  }
                  return {
                    value: t,
                    point: t,
                  };
                });
              o.sort((t, e) => parseInt(t.value, 10) - parseInt(e.value, 10));
              for (let t = 0; t < o.length; t += 1) {
                const { point: s, value: a } = o[t];
                "window" === e
                  ? r.matchMedia(`(min-width: ${a}px)`).matches && (i = s)
                  : a <= n.clientWidth && (i = s);
              }
              return i || "max";
            },
          },
          checkOverflow: {
            checkOverflow: function () {
              const t = this,
                { isLocked: e, params: n } = t,
                { slidesOffsetBefore: i } = n;
              if (i) {
                const e = t.slides.length - 1,
                  n = t.slidesGrid[e] + t.slidesSizesGrid[e] + 2 * i;
                t.isLocked = t.size > n;
              } else t.isLocked = 1 === t.snapGrid.length;
              !0 === n.allowSlideNext && (t.allowSlideNext = !t.isLocked),
                !0 === n.allowSlidePrev && (t.allowSlidePrev = !t.isLocked),
                e && e !== t.isLocked && (t.isEnd = !1),
                e !== t.isLocked && t.emit(t.isLocked ? "lock" : "unlock");
            },
          },
          classes: {
            addClasses: function () {
              const t = this,
                { classNames: e, params: n, rtl: i, el: r, device: s } = t,
                o = (function (t, e) {
                  const n = [];
                  return (
                    t.forEach((t) => {
                      "object" == typeof t
                        ? Object.keys(t).forEach((i) => {
                            t[i] && n.push(e + i);
                          })
                        : "string" == typeof t && n.push(e + t);
                    }),
                    n
                  );
                })(
                  [
                    "initialized",
                    n.direction,
                    {
                      "free-mode": t.params.freeMode && n.freeMode.enabled,
                    },
                    {
                      autoheight: n.autoHeight,
                    },
                    {
                      rtl: i,
                    },
                    {
                      grid: n.grid && n.grid.rows > 1,
                    },
                    {
                      "grid-column":
                        n.grid && n.grid.rows > 1 && "column" === n.grid.fill,
                    },
                    {
                      android: s.android,
                    },
                    {
                      ios: s.ios,
                    },
                    {
                      "css-mode": n.cssMode,
                    },
                    {
                      centered: n.cssMode && n.centeredSlides,
                    },
                    {
                      "watch-progress": n.watchSlidesProgress,
                    },
                  ],
                  n.containerModifierClass
                );
              e.push(...o), r.classList.add(...e), t.emitContainerClasses();
            },
            removeClasses: function () {
              const { el: t, classNames: e } = this;
              t.classList.remove(...e), this.emitContainerClasses();
            },
          },
        },
        mh = {};
      class gh {
        constructor(...t) {
          let e, n;
          1 === t.length &&
          t[0].constructor &&
          "Object" === Object.prototype.toString.call(t[0]).slice(8, -1)
            ? (n = t[0])
            : ([e, n] = t),
            n || (n = {}),
            (n = Fu({}, n)),
            e && !n.el && (n.el = e);
          const i = Cu();
          if (
            n.el &&
            "string" == typeof n.el &&
            i.querySelectorAll(n.el).length > 1
          ) {
            const t = [];
            return (
              i.querySelectorAll(n.el).forEach((e) => {
                const i = Fu({}, n, {
                  el: e,
                });
                t.push(new gh(i));
              }),
              t
            );
          }
          const r = this;
          (r.__swiper__ = !0),
            (r.support = ju()),
            (r.device = (function (t = {}) {
              return (
                Gu ||
                  (Gu = (function ({ userAgent: t } = {}) {
                    const e = ju(),
                      n = Ru(),
                      i = n.navigator.platform,
                      r = t || n.navigator.userAgent,
                      s = {
                        ios: !1,
                        android: !1,
                      },
                      o = n.screen.width,
                      a = n.screen.height,
                      l = r.match(/(Android);?[\s\/]+([\d.]+)?/);
                    let c = r.match(/(iPad).*OS\s([\d_]+)/);
                    const u = r.match(/(iPod)(.*OS\s([\d_]+))?/),
                      h = !c && r.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
                      d = "Win32" === i;
                    let p = "MacIntel" === i;
                    return (
                      !c &&
                        p &&
                        e.touch &&
                        [
                          "1024x1366",
                          "1366x1024",
                          "834x1194",
                          "1194x834",
                          "834x1112",
                          "1112x834",
                          "768x1024",
                          "1024x768",
                          "820x1180",
                          "1180x820",
                          "810x1080",
                          "1080x810",
                        ].indexOf(`${o}x${a}`) >= 0 &&
                        ((c = r.match(/(Version)\/([\d.]+)/)),
                        c || (c = [0, 1, "13_0_0"]),
                        (p = !1)),
                      l && !d && ((s.os = "android"), (s.android = !0)),
                      (c || h || u) && ((s.os = "ios"), (s.ios = !0)),
                      s
                    );
                  })(t)),
                Gu
              );
            })({
              userAgent: n.userAgent,
            })),
            (r.browser =
              (Wu ||
                (Wu = (function () {
                  const t = Ru();
                  let e = !1;
                  function n() {
                    const e = t.navigator.userAgent.toLowerCase();
                    return (
                      e.indexOf("safari") >= 0 &&
                      e.indexOf("chrome") < 0 &&
                      e.indexOf("android") < 0
                    );
                  }
                  if (n()) {
                    const n = String(t.navigator.userAgent);
                    if (n.includes("Version/")) {
                      const [t, i] = n
                        .split("Version/")[1]
                        .split(" ")[0]
                        .split(".")
                        .map((t) => Number(t));
                      e = t < 16 || (16 === t && i < 2);
                    }
                  }
                  return {
                    isSafari: e || n(),
                    needPerspectiveFix: e,
                    isWebView:
                      /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(
                        t.navigator.userAgent
                      ),
                  };
                })()),
              Wu)),
            (r.eventsListeners = {}),
            (r.eventsAnyListeners = []),
            (r.modules = [...r.__modules__]),
            n.modules &&
              Array.isArray(n.modules) &&
              r.modules.push(...n.modules);
          const s = {};
          r.modules.forEach((t) => {
            t({
              params: n,
              swiper: r,
              extendParams: ph(n, s),
              on: r.on.bind(r),
              once: r.once.bind(r),
              off: r.off.bind(r),
              emit: r.emit.bind(r),
            });
          });
          const o = Fu({}, dh, s);
          return (
            (r.params = Fu({}, o, mh, n)),
            (r.originalParams = Fu({}, r.params)),
            (r.passedParams = Fu({}, n)),
            r.params &&
              r.params.on &&
              Object.keys(r.params.on).forEach((t) => {
                r.on(t, r.params.on[t]);
              }),
            r.params && r.params.onAny && r.onAny(r.params.onAny),
            Object.assign(r, {
              enabled: r.params.enabled,
              el: e,
              classNames: [],
              slides: [],
              slidesGrid: [],
              snapGrid: [],
              slidesSizesGrid: [],
              isHorizontal() {
                return "horizontal" === r.params.direction;
              },
              isVertical() {
                return "vertical" === r.params.direction;
              },
              activeIndex: 0,
              realIndex: 0,
              isBeginning: !0,
              isEnd: !1,
              translate: 0,
              previousTranslate: 0,
              progress: 0,
              velocity: 0,
              animating: !1,
              cssOverflowAdjustment() {
                return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
              },
              allowSlideNext: r.params.allowSlideNext,
              allowSlidePrev: r.params.allowSlidePrev,
              touchEventsData: {
                isTouched: void 0,
                isMoved: void 0,
                allowTouchCallbacks: void 0,
                touchStartTime: void 0,
                isScrolling: void 0,
                currentTranslate: void 0,
                startTranslate: void 0,
                allowThresholdMove: void 0,
                focusableElements: r.params.focusableElements,
                lastClickTime: 0,
                clickTimeout: void 0,
                velocities: [],
                allowMomentumBounce: void 0,
                startMoving: void 0,
                evCache: [],
              },
              allowClick: !0,
              allowTouchMove: r.params.allowTouchMove,
              touches: {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0,
              },
              imagesToLoad: [],
              imagesLoaded: 0,
            }),
            r.emit("_swiper"),
            r.params.init && r.init(),
            r
          );
        }
        getSlideIndex(t) {
          const { slidesEl: e, params: n } = this,
            i = Bu(ku(e, `.${n.slideClass}, swiper-slide`)[0]);
          return Bu(t) - i;
        }
        getSlideIndexByData(t) {
          return this.getSlideIndex(
            this.slides.filter(
              (e) => 1 * e.getAttribute("data-swiper-slide-index") === t
            )[0]
          );
        }
        recalcSlides() {
          const { slidesEl: t, params: e } = this;
          this.slides = ku(t, `.${e.slideClass}, swiper-slide`);
        }
        enable() {
          const t = this;
          t.enabled ||
            ((t.enabled = !0),
            t.params.grabCursor && t.setGrabCursor(),
            t.emit("enable"));
        }
        disable() {
          const t = this;
          t.enabled &&
            ((t.enabled = !1),
            t.params.grabCursor && t.unsetGrabCursor(),
            t.emit("disable"));
        }
        setProgress(t, e) {
          const n = this;
          t = Math.min(Math.max(t, 0), 1);
          const i = n.minTranslate(),
            r = (n.maxTranslate() - i) * t + i;
          n.translateTo(r, void 0 === e ? 0 : e),
            n.updateActiveIndex(),
            n.updateSlidesClasses();
        }
        emitContainerClasses() {
          const t = this;
          if (!t.params._emitClasses || !t.el) return;
          const e = t.el.className
            .split(" ")
            .filter(
              (e) =>
                0 === e.indexOf("swiper") ||
                0 === e.indexOf(t.params.containerModifierClass)
            );
          t.emit("_containerClasses", e.join(" "));
        }
        getSlideClasses(t) {
          const e = this;
          return e.destroyed
            ? ""
            : t.className
                .split(" ")
                .filter(
                  (t) =>
                    0 === t.indexOf("swiper-slide") ||
                    0 === t.indexOf(e.params.slideClass)
                )
                .join(" ");
        }
        emitSlidesClasses() {
          const t = this;
          if (!t.params._emitClasses || !t.el) return;
          const e = [];
          t.slides.forEach((n) => {
            const i = t.getSlideClasses(n);
            e.push({
              slideEl: n,
              classNames: i,
            }),
              t.emit("_slideClass", n, i);
          }),
            t.emit("_slideClasses", e);
        }
        slidesPerViewDynamic(t = "current", e = !1) {
          const {
            params: n,
            slides: i,
            slidesGrid: r,
            slidesSizesGrid: s,
            size: o,
            activeIndex: a,
          } = this;
          let l = 1;
          if (n.centeredSlides) {
            let t,
              e = i[a].swiperSlideSize;
            for (let n = a + 1; n < i.length; n += 1)
              i[n] &&
                !t &&
                ((e += i[n].swiperSlideSize), (l += 1), e > o && (t = !0));
            for (let n = a - 1; n >= 0; n -= 1)
              i[n] &&
                !t &&
                ((e += i[n].swiperSlideSize), (l += 1), e > o && (t = !0));
          } else if ("current" === t)
            for (let t = a + 1; t < i.length; t += 1)
              (e ? r[t] + s[t] - r[a] < o : r[t] - r[a] < o) && (l += 1);
          else for (let t = a - 1; t >= 0; t -= 1) r[a] - r[t] < o && (l += 1);
          return l;
        }
        update() {
          const t = this;
          if (!t || t.destroyed) return;
          const { snapGrid: e, params: n } = t;
          function i() {
            const e = t.rtlTranslate ? -1 * t.translate : t.translate,
              n = Math.min(Math.max(e, t.maxTranslate()), t.minTranslate());
            t.setTranslate(n), t.updateActiveIndex(), t.updateSlidesClasses();
          }
          let r;
          if (
            (n.breakpoints && t.setBreakpoint(),
            [...t.el.querySelectorAll('[loading="lazy"]')].forEach((e) => {
              e.complete && qu(t, e);
            }),
            t.updateSize(),
            t.updateSlides(),
            t.updateProgress(),
            t.updateSlidesClasses(),
            t.params.freeMode && t.params.freeMode.enabled)
          )
            i(), t.params.autoHeight && t.updateAutoHeight();
          else {
            if (
              ("auto" === t.params.slidesPerView ||
                t.params.slidesPerView > 1) &&
              t.isEnd &&
              !t.params.centeredSlides
            ) {
              const e =
                t.virtual && t.params.virtual.enabled
                  ? t.virtual.slides
                  : t.slides;
              r = t.slideTo(e.length - 1, 0, !1, !0);
            } else r = t.slideTo(t.activeIndex, 0, !1, !0);
            r || i();
          }
          n.watchOverflow && e !== t.snapGrid && t.checkOverflow(),
            t.emit("update");
        }
        changeDirection(t, e = !0) {
          const n = this,
            i = n.params.direction;
          return (
            t || (t = "horizontal" === i ? "vertical" : "horizontal"),
            t === i ||
              ("horizontal" !== t && "vertical" !== t) ||
              (n.el.classList.remove(`${n.params.containerModifierClass}${i}`),
              n.el.classList.add(`${n.params.containerModifierClass}${t}`),
              n.emitContainerClasses(),
              (n.params.direction = t),
              n.slides.forEach((e) => {
                "vertical" === t ? (e.style.width = "") : (e.style.height = "");
              }),
              n.emit("changeDirection"),
              e && n.update()),
            n
          );
        }
        changeLanguageDirection(t) {
          const e = this;
          (e.rtl && "rtl" === t) ||
            (!e.rtl && "ltr" === t) ||
            ((e.rtl = "rtl" === t),
            (e.rtlTranslate = "horizontal" === e.params.direction && e.rtl),
            e.rtl
              ? (e.el.classList.add(`${e.params.containerModifierClass}rtl`),
                (e.el.dir = "rtl"))
              : (e.el.classList.remove(`${e.params.containerModifierClass}rtl`),
                (e.el.dir = "ltr")),
            e.update());
        }
        mount(t) {
          const e = this;
          if (e.mounted) return !0;
          let n = t || e.params.el;
          if (("string" == typeof n && (n = document.querySelector(n)), !n))
            return !1;
          (n.swiper = e), n.shadowEl && (e.isElement = !0);
          const i = () =>
            `.${(e.params.wrapperClass || "").trim().split(" ").join(".")}`;
          let r =
            n && n.shadowRoot && n.shadowRoot.querySelector
              ? n.shadowRoot.querySelector(i())
              : ku(n, i())[0];
          return (
            !r &&
              e.params.createElements &&
              ((r = (function (t, e = []) {
                const n = document.createElement(t);
                return n.classList.add(...(Array.isArray(e) ? e : [e])), n;
              })("div", e.params.wrapperClass)),
              n.append(r),
              ku(n, `.${e.params.slideClass}`).forEach((t) => {
                r.append(t);
              })),
            Object.assign(e, {
              el: n,
              wrapperEl: r,
              slidesEl: e.isElement ? n : r,
              mounted: !0,
              rtl:
                "rtl" === n.dir.toLowerCase() || "rtl" === zu(n, "direction"),
              rtlTranslate:
                "horizontal" === e.params.direction &&
                ("rtl" === n.dir.toLowerCase() || "rtl" === zu(n, "direction")),
              wrongRTL: "-webkit-box" === zu(r, "display"),
            }),
            !0
          );
        }
        init(t) {
          const e = this;
          return (
            e.initialized ||
              !1 === e.mount(t) ||
              (e.emit("beforeInit"),
              e.params.breakpoints && e.setBreakpoint(),
              e.addClasses(),
              e.updateSize(),
              e.updateSlides(),
              e.params.watchOverflow && e.checkOverflow(),
              e.params.grabCursor && e.enabled && e.setGrabCursor(),
              e.params.loop && e.virtual && e.params.virtual.enabled
                ? e.slideTo(
                    e.params.initialSlide + e.virtual.slidesBefore,
                    0,
                    e.params.runCallbacksOnInit,
                    !1,
                    !0
                  )
                : e.slideTo(
                    e.params.initialSlide,
                    0,
                    e.params.runCallbacksOnInit,
                    !1,
                    !0
                  ),
              e.params.loop && e.loopCreate(),
              e.attachEvents(),
              [...e.el.querySelectorAll('[loading="lazy"]')].forEach((t) => {
                t.complete
                  ? qu(e, t)
                  : t.addEventListener("load", (t) => {
                      qu(e, t.target);
                    });
              }),
              Ku(e),
              (e.initialized = !0),
              Ku(e),
              e.emit("init"),
              e.emit("afterInit")),
            e
          );
        }
        destroy(t = !0, e = !0) {
          const n = this,
            { params: i, el: r, wrapperEl: s, slides: o } = n;
          return (
            void 0 === n.params ||
              n.destroyed ||
              (n.emit("beforeDestroy"),
              (n.initialized = !1),
              n.detachEvents(),
              i.loop && n.loopDestroy(),
              e &&
                (n.removeClasses(),
                r.removeAttribute("style"),
                s.removeAttribute("style"),
                o &&
                  o.length &&
                  o.forEach((t) => {
                    t.classList.remove(
                      i.slideVisibleClass,
                      i.slideActiveClass,
                      i.slideNextClass,
                      i.slidePrevClass
                    ),
                      t.removeAttribute("style"),
                      t.removeAttribute("data-swiper-slide-index");
                  })),
              n.emit("destroy"),
              Object.keys(n.eventsListeners).forEach((t) => {
                n.off(t);
              }),
              !1 !== t &&
                ((n.el.swiper = null),
                (function (t) {
                  const e = t;
                  Object.keys(e).forEach((t) => {
                    try {
                      e[t] = null;
                    } catch (t) {}
                    try {
                      delete e[t];
                    } catch (t) {}
                  });
                })(n)),
              (n.destroyed = !0)),
            null
          );
        }
        static extendDefaults(t) {
          Fu(mh, t);
        }
        static get extendedDefaults() {
          return mh;
        }
        static get defaults() {
          return dh;
        }
        static installModule(t) {
          gh.prototype.__modules__ || (gh.prototype.__modules__ = []);
          const e = gh.prototype.__modules__;
          "function" == typeof t && e.indexOf(t) < 0 && e.push(t);
        }
        static use(t) {
          return Array.isArray(t)
            ? (t.forEach((t) => gh.installModule(t)), gh)
            : (gh.installModule(t), gh);
        }
      }
      Object.keys(fh).forEach((t) => {
        Object.keys(fh[t]).forEach((e) => {
          gh.prototype[e] = fh[t][e];
        });
      }),
        gh.use([
          function ({ swiper: t, on: e, emit: n }) {
            const i = Ru();
            let r = null,
              s = null;
            const o = () => {
                t &&
                  !t.destroyed &&
                  t.initialized &&
                  (n("beforeResize"), n("resize"));
              },
              a = () => {
                t && !t.destroyed && t.initialized && n("orientationchange");
              };
            e("init", () => {
              t.params.resizeObserver && void 0 !== i.ResizeObserver
                ? t &&
                  !t.destroyed &&
                  t.initialized &&
                  ((r = new ResizeObserver((e) => {
                    s = i.requestAnimationFrame(() => {
                      const { width: n, height: i } = t;
                      let r = n,
                        s = i;
                      e.forEach(
                        ({ contentBoxSize: e, contentRect: n, target: i }) => {
                          (i && i !== t.el) ||
                            ((r = n ? n.width : (e[0] || e).inlineSize),
                            (s = n ? n.height : (e[0] || e).blockSize));
                        }
                      ),
                        (r === n && s === i) || o();
                    });
                  })),
                  r.observe(t.el))
                : (i.addEventListener("resize", o),
                  i.addEventListener("orientationchange", a));
            }),
              e("destroy", () => {
                s && i.cancelAnimationFrame(s),
                  r && r.unobserve && t.el && (r.unobserve(t.el), (r = null)),
                  i.removeEventListener("resize", o),
                  i.removeEventListener("orientationchange", a);
              });
          },
          function ({ swiper: t, extendParams: e, on: n, emit: i }) {
            const r = [],
              s = Ru(),
              o = (e, n = {}) => {
                const o = new (s.MutationObserver || s.WebkitMutationObserver)(
                  (e) => {
                    if (t.__preventObserver__) return;
                    if (1 === e.length) return void i("observerUpdate", e[0]);
                    const n = function () {
                      i("observerUpdate", e[0]);
                    };
                    s.requestAnimationFrame
                      ? s.requestAnimationFrame(n)
                      : s.setTimeout(n, 0);
                  }
                );
                o.observe(e, {
                  attributes: void 0 === n.attributes || n.attributes,
                  childList: void 0 === n.childList || n.childList,
                  characterData: void 0 === n.characterData || n.characterData,
                }),
                  r.push(o);
              };
            e({
              observer: !1,
              observeParents: !1,
              observeSlideChildren: !1,
            }),
              n("init", () => {
                if (t.params.observer) {
                  if (t.params.observeParents) {
                    const e = (function (t, e) {
                      const n = [];
                      let i = t.parentElement;
                      for (; i; ) n.push(i), (i = i.parentElement);
                      return n;
                    })(t.el);
                    for (let t = 0; t < e.length; t += 1) o(e[t]);
                  }
                  o(t.el, {
                    childList: t.params.observeSlideChildren,
                  }),
                    o(t.wrapperEl, {
                      attributes: !1,
                    });
                }
              }),
              n("destroy", () => {
                r.forEach((t) => {
                  t.disconnect();
                }),
                  r.splice(0, r.length);
              });
          },
        ]);
      var vh = gh;
      function _h() {
        return (
          (_h =
            Object.assign ||
            function (t) {
              for (var e = 1; e < arguments.length; e++) {
                var n = arguments[e];
                for (var i in n)
                  Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
              }
              return t;
            }),
          _h.apply(this, arguments)
        );
      }
      function yh(t, e) {
        (t.prototype = Object.create(e.prototype)),
          (t.prototype.constructor = t),
          xh(t, e);
      }
      function xh(t, e) {
        return (
          (xh =
            Object.setPrototypeOf ||
            function (t, e) {
              return (t.__proto__ = e), t;
            }),
          xh(t, e)
        );
      }
      var bh = (function () {
          function t() {
            this.events = {};
          }
          var e = t.prototype;
          return (
            (e.on = function (t, e) {
              this.events[t] instanceof Array || (this.events[t] = []),
                this.events[t].push(e);
            }),
            (e.off = function (t, e) {
              this.events[t] = e
                ? this.events[t].filter(function (t) {
                    return t !== e;
                  })
                : [];
            }),
            (e.trigger = function (t) {
              var e = arguments,
                n = this;
              this.events[t] &&
                this.events[t].forEach(function (t) {
                  return t.call.apply(t, [n, n].concat([].slice.call(e, 1)));
                });
            }),
            t
          );
        })(),
        Sh = (function (t) {
          function e(n) {
            var i;
            return (
              ((i = t.call(this) || this).options = _h(
                {},
                e.defaultOptions,
                n
              )),
              (i.container =
                "string" == typeof i.options.container
                  ? document.querySelector(i.options.container)
                  : i.options.container),
              (i.wrapper =
                "string" == typeof i.options.wrapper
                  ? i.container.querySelector(i.options.wrapper)
                  : i.options.wrapper || i.options.container),
              (i.item = []),
              i.refresh(!1),
              i.options.autoUpdate ? i.bindResizeObserver() : i.update(),
              i
            );
          }
          yh(e, t);
          var n = e.prototype;
          return (
            (n.bindResizeObserver = function () {
              var t = this;
              (this.resizeObserver = new ResizeObserver(function () {
                t.update();
              })),
                this.resizeObserver.observe(this.container);
            }),
            (n.addClones = function (t, e) {
              var n;
              void 0 === e && (e = 0);
              for (var i = [], r = 0; r < t; r++) {
                var s = this.item[(e + r) % this.item.length].cloneNode(!0);
                s.classList.add(this.options.cloneClassName), i.push(s);
              }
              (n = this.wrapper).append.apply(n, i);
            }),
            (n.removeClones = function (t) {
              void 0 === t && (t = 0),
                Array.from(
                  this.wrapper.getElementsByClassName(
                    this.options.cloneClassName
                  )
                )
                  .slice(-t)
                  .forEach(function (t) {
                    return t.remove();
                  });
            }),
            (n.setClonesCount = function (t) {
              this.clonesCount !== t &&
                (this.clonesCount < t &&
                  this.addClones(t - this.clonesCount, this.clonesCount),
                this.clonesCount > t && this.removeClones(this.clonesCount - t),
                (this.clonesCount = t));
            }),
            (n.getCalcData = function () {
              var t = {
                clonesCount: 0,
                clonesWidth: 0,
                containerWidth: this.container.offsetWidth,
                fullWidth: 0,
                itemWidth: [],
                itemsWidth: 0,
                lastIndex: 0,
              };
              this.item.map(function (e) {
                var n = window.getComputedStyle(e),
                  i =
                    e.offsetWidth +
                    parseInt(n.marginLeft) +
                    parseInt(n.marginRight);
                t.itemWidth.push(i), (t.itemsWidth += i);
              });
              for (
                var e = t.itemWidth.length,
                  n = this.options.clonesOverflow
                    ? t.containerWidth
                    : t.containerWidth - t.itemsWidth;
                n > t.clonesWidth ||
                t.clonesCount < this.options.clonesMin ||
                (this.options.clonesFinish && t.clonesCount % e > 0);

              )
                (t.lastIndex = t.clonesCount % e),
                  (t.clonesWidth += t.itemWidth[t.lastIndex]),
                  t.clonesCount++;
              return (t.fullWidth = t.clonesWidth + t.itemsWidth), t;
            }),
            (n.update = function () {
              (this.calcData = this.getCalcData()),
                this.setClonesCount(this.calcData.clonesCount),
                this.trigger("update", this.calcData);
            }),
            (n.refresh = function (t) {
              void 0 === t && (t = !0),
                this.removeClones(),
                (this.item = Array.from(
                  this.container.querySelectorAll(this.options.itemSelector)
                )),
                (this.calcData = {}),
                (this.clonesCount = 0),
                this.trigger("refresh"),
                t && this.update();
            }),
            (n.destroy = function (t) {
              void 0 === t && (t = !1),
                t && this.removeClones(),
                this.resizeObserver && this.resizeObserver.disconnect(),
                this.trigger("destroy");
            }),
            e
          );
        })(bh);
      Sh.defaultOptions = {
        container: null,
        wrapper: null,
        itemSelector: null,
        cloneClassName: "-clone",
        autoUpdate: !0,
        clonesOverflow: !1,
        clonesFinish: !1,
        clonesMin: 0,
      };
      var Eh = (function (t) {
        function e(n) {
          var i;
          return (
            ((i = t.call(this) || this).options = _h({}, e.defaultOptions, n)),
            (i.gsap = e.gsap || window.gsap),
            (i.paused = i.options.paused),
            i.createFiller(),
            i.createTimeline(),
            i.options.autoStop && i.bindIntersectionObserver(),
            i.options.plugins && i.initPlugins(),
            i
          );
        }
        yh(e, t),
          (e.registerGSAP = function (t) {
            e.gsap = t;
          }),
          (e.use = function () {
            [].slice.call(arguments).forEach(function (t) {
              var n = t.pluginName;
              if ("string" != typeof n)
                throw new TypeError("Invalid plugin. Name is required.");
              e.plugins[n] = t;
            });
          });
        var n = e.prototype;
        return (
          (n.createFiller = function () {
            var t = this;
            (this.filler = new Sh(this.options)),
              this.filler.on("update", function (e, n) {
                t.invalidate(), t.trigger("update", n);
              }),
              this.filler.on("refresh", function () {
                t.trigger("refresh");
              });
          }),
          (n.createTimeline = function () {
            var t = this;
            return (
              (this.tl = new this.gsap.timeline({
                paused: this.options.paused,
                reversed: this.options.reversed,
                repeat: -1,
                yoyo: !this.options.loop,
                onReverseComplete: function () {
                  this.progress(1);
                },
              })),
              this.gsap.set(this.filler.container, {
                overflow: "hidden",
              }),
              this.tl.fromTo(
                this.filler.wrapper,
                {
                  x: function () {
                    return t.options.clonesOverflow
                      ? -t.filler.calcData.itemsWidth
                      : -(
                          t.filler.calcData.fullWidth -
                          t.filler.calcData.containerWidth
                        );
                  },
                },
                {
                  x: 0,
                  duration: this.options.speed,
                  ease: this.options.ease,
                }
              ),
              this.tl.seek(this.options.seek),
              this.tl
            );
          }),
          (n.bindIntersectionObserver = function () {
            var t = this;
            (this.intersectionObserver = new IntersectionObserver(function (e) {
              e[0].isIntersecting ? t.resume() : t.pause();
            })),
              this.intersectionObserver.observe(this.filler.container);
          }),
          (n.initPlugins = function () {
            this.plugin = {};
            for (
              var t = 0, n = Object.entries(this.options.plugins);
              t < n.length;
              t++
            ) {
              var i = n[t],
                r = i[0],
                s = i[1],
                o = e.plugins[r];
              o
                ? (this.plugin[r] = new o(this, s))
                : console.error(
                    "Plugin " +
                      r +
                      " not found. Make sure you register it with Reeller.use()"
                  );
            }
          }),
          (n.destroyPlugins = function () {
            for (var t = 0, e = Object.values(this.plugin); t < e.length; t++) {
              var n = e[t];
              n.destroy && n.destroy();
            }
          }),
          (n.resume = function () {
            this.gsap.set(this.filler.container, {
              z: "0",
            }),
              this.gsap.set(this.filler.wrapper, {
                willChange: "transform",
              }),
              (this.paused = !1),
              this.tl.resume(),
              this.trigger("resume");
          }),
          (n.reverse = function (t) {
            void 0 === t && (t = !0),
              this.tl.reversed(t),
              this.resume(),
              this.trigger("reverse", t);
          }),
          (n.pause = function () {
            this.gsap.set(this.filler.container, {
              clearProps: "z",
            }),
              this.gsap.set(this.filler.wrapper, {
                willChange: "auto",
              }),
              (this.paused = !0),
              this.tl.pause(),
              this.trigger("pause");
          }),
          (n.invalidate = function () {
            this.tl.invalidate(), this.trigger("invalidate");
          }),
          (n.update = function () {
            this.filler.update();
          }),
          (n.refresh = function (t) {
            void 0 === t && (t = !0), this.filler.refresh(t);
          }),
          (n.destroy = function (t, e) {
            void 0 === t && (t = !1),
              void 0 === e && (e = !1),
              this.intersectionObserver &&
                this.intersectionObserver.disconnect(),
              this.options.plugins && this.destroyPlugins(),
              this.tl.kill(),
              this.filler.destroy(t),
              e &&
                (this.gsap.set(this.filler.container, {
                  clearProps: "overflow",
                }),
                this.gsap.set(this.filler.wrapper, {
                  clearProps: "x,willChange",
                })),
              this.trigger("destroy");
          }),
          e
        );
      })(bh);
      (Eh.defaultOptions = {
        container: null,
        wrapper: null,
        itemSelector: null,
        cloneClassName: "-clone",
        speed: 10,
        ease: "none",
        initialSeek: 10,
        loop: !0,
        paused: !0,
        reversed: !1,
        autoStop: !0,
        autoUpdate: !0,
        clonesOverflow: !0,
        clonesFinish: !1,
        clonesMin: 0,
        plugins: null,
      }),
        (Eh.plugins = {});
      var Th = (function () {
        function t(e, n) {
          (this.options = _h({}, t.defaultOptions, n)),
            (this.reeller = e),
            (this.gsap = this.reeller.gsap),
            (this.tl = this.reeller.tl),
            this.init();
        }
        var e = t.prototype;
        return (
          (e.getScrollPos = function () {
            return this.options.scrollProxy
              ? this.options.scrollProxy()
              : window.pageYOffset;
          }),
          (e.init = function () {
            var t = this,
              e = this.getScrollPos(),
              n = 1,
              i = !0;
            (this.tickerFn = function () {
              var r = t.getScrollPos(),
                s = r - e;
              if (
                (t.options.bothDirection || (s = Math.abs(s)),
                t.options.reversed && (s *= -1),
                t.reeller.paused)
              )
                return (
                  (n = Math.sign(s)),
                  (e = r),
                  i || (t.gsap.killTweensOf(t.tl), (i = !0)),
                  void t.tl.timeScale(n * t.options.threshold)
                );
              if (s) {
                var o = s * t.options.multiplier,
                  a =
                    o > 0
                      ? Math.max(t.options.threshold, o)
                      : Math.min(-t.options.threshold, o);
                (t.tween = t.gsap.to(t.tl, {
                  timeScale: a,
                  duration: t.options.speed,
                  ease: t.options.ease,
                  overwrite: t.options.overwrite,
                })),
                  (i = !1);
              } else if (!i) {
                var l = t.options.stopOnEnd ? 0 : n * t.options.threshold;
                t.gsap.killTweensOf(t.tl),
                  (t.tween = t.gsap.to(t.tl, {
                    timeScale: l,
                    duration: t.options.speed,
                    overwrite: t.options.overwrite,
                    ease: t.options.ease,
                  })),
                  (i = !0);
              }
              (n = Math.sign(s)), (e = r);
            }),
              this.gsap.ticker.add(this.tickerFn);
          }),
          (e.destroy = function () {
            this.tickerFn &&
              (this.gsap.ticker.remove(this.tickerFn), (this.tickerFn = null)),
              this.tween && this.tween.kill();
          }),
          t
        );
      })();
      function Mh(t, e) {
        return (
          (Mh = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          Mh(t, e)
        );
      }
      (Th.pluginName = "scroller"),
        (Th.defaultOptions = {
          speed: 1,
          multiplier: 0.5,
          threshold: 1,
          ease: "expo.out",
          overwrite: !0,
          bothDirection: !0,
          reversed: !1,
          stopOnEnd: !1,
          scrollProxy: null,
        }),
        Eh.registerGSAP(Zi),
        Eh.use(Th),
        vh.use([
          function ({ swiper: t, extendParams: e, on: n, emit: i, params: r }) {
            let s, o;
            (t.autoplay = {
              running: !1,
              paused: !1,
              timeLeft: 0,
            }),
              e({
                autoplay: {
                  enabled: !1,
                  delay: 3e3,
                  waitForTransition: !0,
                  disableOnInteraction: !0,
                  stopOnLastSlide: !1,
                  reverseDirection: !1,
                  pauseOnMouseEnter: !1,
                },
              });
            let a,
              l,
              c,
              u,
              h,
              d,
              p,
              f = r && r.autoplay ? r.autoplay.delay : 3e3,
              m = r && r.autoplay ? r.autoplay.delay : 3e3,
              g = new Date().getTime;
            function v(e) {
              t &&
                !t.destroyed &&
                t.wrapperEl &&
                e.target === t.wrapperEl &&
                (t.wrapperEl.removeEventListener("transitionend", v), E());
            }
            const _ = () => {
                if (t.destroyed || !t.autoplay.running) return;
                t.autoplay.paused ? (l = !0) : l && ((m = a), (l = !1));
                const e = t.autoplay.paused ? a : g + m - new Date().getTime();
                (t.autoplay.timeLeft = e),
                  i("autoplayTimeLeft", e, e / f),
                  (o = requestAnimationFrame(() => {
                    _();
                  }));
              },
              y = (e) => {
                if (t.destroyed || !t.autoplay.running) return;
                cancelAnimationFrame(o), _();
                let n = void 0 === e ? t.params.autoplay.delay : e;
                (f = t.params.autoplay.delay), (m = t.params.autoplay.delay);
                const r = (() => {
                  let e;
                  if (
                    ((e =
                      t.virtual && t.params.virtual.enabled
                        ? t.slides.filter((t) =>
                            t.classList.contains("swiper-slide-active")
                          )[0]
                        : t.slides[t.activeIndex]),
                    e)
                  )
                    return parseInt(e.getAttribute("data-swiper-autoplay"), 10);
                })();
                !Number.isNaN(r) &&
                  r > 0 &&
                  void 0 === e &&
                  ((n = r), (f = r), (m = r)),
                  (a = n);
                const l = t.params.speed,
                  c = () => {
                    t &&
                      !t.destroyed &&
                      (t.params.autoplay.reverseDirection
                        ? !t.isBeginning || t.params.loop || t.params.rewind
                          ? (t.slidePrev(l, !0, !0), i("autoplay"))
                          : t.params.autoplay.stopOnLastSlide ||
                            (t.slideTo(t.slides.length - 1, l, !0, !0),
                            i("autoplay"))
                        : !t.isEnd || t.params.loop || t.params.rewind
                        ? (t.slideNext(l, !0, !0), i("autoplay"))
                        : t.params.autoplay.stopOnLastSlide ||
                          (t.slideTo(0, l, !0, !0), i("autoplay")),
                      t.params.cssMode &&
                        ((g = new Date().getTime()),
                        requestAnimationFrame(() => {
                          y();
                        })));
                  };
                return (
                  n > 0
                    ? (clearTimeout(s),
                      (s = setTimeout(() => {
                        c();
                      }, n)))
                    : requestAnimationFrame(() => {
                        c();
                      }),
                  n
                );
              },
              x = () => {
                (t.autoplay.running = !0), y(), i("autoplayStart");
              },
              b = () => {
                (t.autoplay.running = !1),
                  clearTimeout(s),
                  cancelAnimationFrame(o),
                  i("autoplayStop");
              },
              S = (e, n) => {
                if (t.destroyed || !t.autoplay.running) return;
                clearTimeout(s), e || (p = !0);
                const r = () => {
                  i("autoplayPause"),
                    t.params.autoplay.waitForTransition
                      ? t.wrapperEl.addEventListener("transitionend", v)
                      : E();
                };
                if (((t.autoplay.paused = !0), n))
                  return d && (a = t.params.autoplay.delay), (d = !1), void r();
                const o = a || t.params.autoplay.delay;
                (a = o - (new Date().getTime() - g)),
                  (t.isEnd && a < 0 && !t.params.loop) ||
                    (a < 0 && (a = 0), r());
              },
              E = () => {
                (t.isEnd && a < 0 && !t.params.loop) ||
                  t.destroyed ||
                  !t.autoplay.running ||
                  ((g = new Date().getTime()),
                  p ? ((p = !1), y(a)) : y(),
                  (t.autoplay.paused = !1),
                  i("autoplayResume"));
              },
              T = () => {
                if (t.destroyed || !t.autoplay.running) return;
                const e = Cu();
                "hidden" === e.visibilityState && ((p = !0), S(!0)),
                  "visible" === e.visibilityState && E();
              },
              M = (t) => {
                "mouse" === t.pointerType && ((p = !0), S(!0));
              },
              w = (e) => {
                "mouse" === e.pointerType && t.autoplay.paused && E();
              };
            n("init", () => {
              t.params.autoplay.enabled &&
                (t.params.autoplay.pauseOnMouseEnter &&
                  (t.el.addEventListener("pointerenter", M),
                  t.el.addEventListener("pointerleave", w)),
                Cu().addEventListener("visibilitychange", T),
                (g = new Date().getTime()),
                x());
            }),
              n("destroy", () => {
                t.el.removeEventListener("pointerenter", M),
                  t.el.removeEventListener("pointerleave", w),
                  Cu().removeEventListener("visibilitychange", T),
                  t.autoplay.running && b();
              }),
              n("beforeTransitionStart", (e, n, i) => {
                !t.destroyed &&
                  t.autoplay.running &&
                  (i || !t.params.autoplay.disableOnInteraction
                    ? S(!0, !0)
                    : b());
              }),
              n("sliderFirstMove", () => {
                !t.destroyed &&
                  t.autoplay.running &&
                  (t.params.autoplay.disableOnInteraction
                    ? b()
                    : ((c = !0),
                      (u = !1),
                      (p = !1),
                      (h = setTimeout(() => {
                        (p = !0), (u = !0), S(!0);
                      }, 200))));
              }),
              n("touchEnd", () => {
                if (!t.destroyed && t.autoplay.running && c) {
                  if (
                    (clearTimeout(h),
                    clearTimeout(s),
                    t.params.autoplay.disableOnInteraction)
                  )
                    return (u = !1), void (c = !1);
                  u && t.params.cssMode && E(), (u = !1), (c = !1);
                }
              }),
              n("slideChange", () => {
                !t.destroyed && t.autoplay.running && (d = !0);
              }),
              Object.assign(t.autoplay, {
                start: x,
                stop: b,
                pause: S,
                resume: E,
              });
          },
        ]);
      var wh = (function (t) {
        var e, n;
        function i() {
          var e;
          return (
            ((e = t.apply(this, arguments) || this).cursor =
              e.app.get("cursor")),
            (e.layout = e.app.get("layout")),
            (e.bg = e.el.querySelector(".cb-overview-bg")),
            (e.content = e.el.querySelector(".cb-overview-content")),
            (e.carousel = e.el.querySelector(".cb-overview-carousel")),
            (e.carouselItem = e.el.querySelectorAll(
              ".cb-overview-carousel-item"
            )),
            (e.header = e.el.querySelector(".cb-overview-header")),
            (e.icon = e.el.querySelector(".cb-overview-icon")),
            (e.caption = e.el.querySelectorAll(".cb-overview-caption")),
            (e.author = e.el.querySelector(".cb-overview-author")),
            (e.text = e.el.querySelector(".cb-overview-text")),
            (e.action = e.el.querySelector(".cb-overview-action")),
            (e.link = e.el.querySelectorAll(".cb-overview-link")),
            (e.counter = e.el.querySelectorAll(".cb-overview-counter")),
            (e.logo = e.el.querySelectorAll(".cb-overview-logo")),
            e.initCarousel(),
            e
          );
        }
        (n = t),
          ((e = i).prototype = Object.create(n.prototype)),
          (e.prototype.constructor = e),
          Mh(e, n);
        var r = i.prototype;
        return (
          (r.onInit = function () {
            try {
              var t = this;
              return Promise.resolve(document.fonts.ready).then(function () {
                t.magicParallax(), t.magicShow();
              });
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.onDestroy = function () {
            try {
              return (
                this.swiper && this.swiper.destroy(!0, !1), Promise.resolve()
              );
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.initCarousel = function () {
            var t = this;
            this.carousel &&
              ((this.swiper = new vh(this.carousel, {
                wrapperClass: "cb-overview-carousel-wrap",
                slideClass: "cb-overview-carousel-item",
                slidesPerView: 1,
                loop: !0,
                grabCursor: !0,
                touchStartPreventDefault: !1,
                autoplay: {
                  delay: 5e3,
                  pauseOnMouseEnter: !0,
                },
              })),
              this.carouselItem.forEach(function (e) {
                var n = e.querySelector(".cb-overview-text");
                n &&
                  (n.addEventListener("click", function (e) {
                    t.swiper.slideNext();
                  }),
                  t.cursor.follower &&
                    (n.addEventListener("mouseenter", function () {
                      t.cursor.follower.setIcon(
                        "long-arrow-right-o",
                        "font-size:28px"
                      );
                    }),
                    n.addEventListener("mouseleave", function () {
                      t.cursor.follower.removeIcon();
                    })));
              }));
          }),
          (r.magicShow = function () {
            var t, e, n;
            this.header &&
              kc(this.header.firstElementChild, {
                type: "lines",
                stagger: 0.3,
              }),
              this.icon && Bc(this.icon),
              this.caption.length &&
                this.caption.forEach(function (t) {
                  kc(t, {
                    stagger: 0.1,
                  });
                }),
              this.author && jc(this.author),
              this.text && kc(this.text),
              this.action && Vc(this.action),
              this.link.length &&
                jc(this.link, {
                  duration: 0.8,
                  stagger: 0.2,
                }),
              this.counter.length && Vc(this.counter),
              this.logo.length &&
                ((t = this.logo),
                void 0 === e && (e = {}),
                void 0 === n && (n = {}),
                Zi.set(t, {
                  opacity: 0,
                }),
                ta.batch(
                  t,
                  Fc(
                    {
                      onEnter: function (t) {
                        return jc(t, e);
                      },
                      once: !0,
                    },
                    n
                  )
                ));
          }),
          (r.magicParallax = function () {
            this.bg &&
              ta.create({
                trigger: this.el,
                animation: this.tlParallax(),
                start: "top bottom",
                end: "bottom top",
                scrub: !0,
              });
          }),
          (r.tlParallax = function () {
            var t = new Zi.timeline();
            return (
              this.bg &&
                t.fromTo(
                  this.bg,
                  {
                    yPercent: -30,
                  },
                  {
                    yPercent: 30,
                    ease: "none",
                  },
                  0
                ),
              t
            );
          }),
          i
        );
      })(o);
      function Dh(t, e) {
        return (
          (Dh = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          Dh(t, e)
        );
      }
      var Ah = (function (t) {
        var e, n;
        function i() {
          var e;
          return (
            ((e = t.apply(this, arguments) || this).item =
              e.el.querySelectorAll(".cb-splitshow-item")),
            e
          );
        }
        (n = t),
          ((e = i).prototype = Object.create(n.prototype)),
          (e.prototype.constructor = e),
          Dh(e, n);
        var r = i.prototype;
        return (
          (r.onInit = function () {
            try {
              return this.magicItems(), Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.magicItems = function () {
            var t = this;
            this.item.forEach(function (e) {
              var n = e
                  .querySelector(".cb-splitshow-preview")
                  .querySelector(".cb-splitshow-preview-media"),
                i = e.querySelector(".cb-splitshow-caption");
              ta.create({
                trigger: e,
                animation: t.tlShow(n, i),
                once: !0,
              }),
                ta.create({
                  trigger: e,
                  animation: t.tlParallax(n),
                  start: "top bottom",
                  end: "bottom top",
                  scrub: !0,
                });
            });
          }),
          (r.tlShow = function (t, e) {
            var n = new Zi.timeline();
            return (
              Zi.set(t, {
                opacity: 0,
              }),
              n.to(t, {
                opacity: 1,
                duration: 1,
              }),
              n
            );
          }),
          (r.tlParallax = function (t) {
            var e = new Zi.timeline();
            return (
              Zi.set(t, {
                scale: 1.05,
              }),
              e.fromTo(
                t,
                {
                  y: "-10%",
                },
                {
                  y: "10%",
                  ease: "none",
                }
              ),
              e
            );
          }),
          i
        );
      })(o);
      const Ch = (t) => Math.max(t.offsetHeight, t.scrollHeight);
      class Ph {
        constructor(t = {}) {
          const e = {
            content: t.viewport.children[0],
            direction: "all",
            pointerMode: "all",
            scrollMode: void 0,
            bounce: !0,
            bounceForce: 0.1,
            friction: 0.05,
            textSelection: !1,
            inputsFocus: !0,
            emulateScroll: !1,
            preventDefaultOnEmulateScroll: !1,
            preventPointerMoveDefault: !0,
            lockScrollOnDragDirection: !1,
            pointerDownPreventDefault: !0,
            dragDirectionTolerance: 40,
            onPointerDown() {},
            onPointerUp() {},
            onPointerMove() {},
            onClick() {},
            onUpdate() {},
            onWheel() {},
            shouldScroll() {
              return !0;
            },
          };
          if (
            ((this.props = {
              ...e,
              ...t,
            }),
            !(this.props.viewport && this.props.viewport instanceof Element))
          )
            return void console.error(
              'ScrollBooster init error: "viewport" config property must be present and must be Element'
            );
          if (!this.props.content)
            return void console.error(
              "ScrollBooster init error: Viewport does not have any content"
            );
          (this.isDragging = !1),
            (this.isTargetScroll = !1),
            (this.isScrolling = !1),
            (this.isRunning = !1);
          const n = {
            x: 0,
            y: 0,
          };
          (this.position = {
            ...n,
          }),
            (this.velocity = {
              ...n,
            }),
            (this.dragStartPosition = {
              ...n,
            }),
            (this.dragOffset = {
              ...n,
            }),
            (this.clientOffset = {
              ...n,
            }),
            (this.dragPosition = {
              ...n,
            }),
            (this.targetPosition = {
              ...n,
            }),
            (this.scrollOffset = {
              ...n,
            }),
            (this.rafID = null),
            (this.events = {}),
            this.updateMetrics(),
            this.handleEvents();
        }
        updateOptions(t = {}) {
          (this.props = {
            ...this.props,
            ...t,
          }),
            this.props.onUpdate(this.getState()),
            this.startAnimationLoop();
        }
        updateMetrics() {
          var t;
          (this.viewport = {
            width: this.props.viewport.clientWidth,
            height: this.props.viewport.clientHeight,
          }),
            (this.content = {
              width:
                ((t = this.props.content),
                Math.max(t.offsetWidth, t.scrollWidth)),
              height: Ch(this.props.content),
            }),
            (this.edgeX = {
              from: Math.min(-this.content.width + this.viewport.width, 0),
              to: 0,
            }),
            (this.edgeY = {
              from: Math.min(-this.content.height + this.viewport.height, 0),
              to: 0,
            }),
            this.props.onUpdate(this.getState()),
            this.startAnimationLoop();
        }
        startAnimationLoop() {
          (this.isRunning = !0),
            cancelAnimationFrame(this.rafID),
            (this.rafID = requestAnimationFrame(() => this.animate()));
        }
        animate() {
          if (!this.isRunning) return;
          this.updateScrollPosition(),
            this.isMoving() ||
              ((this.isRunning = !1), (this.isTargetScroll = !1));
          const t = this.getState();
          this.setContentPosition(t),
            this.props.onUpdate(t),
            (this.rafID = requestAnimationFrame(() => this.animate()));
        }
        updateScrollPosition() {
          this.applyEdgeForce(),
            this.applyDragForce(),
            this.applyScrollForce(),
            this.applyTargetForce();
          const t = 1 - this.props.friction;
          (this.velocity.x *= t),
            (this.velocity.y *= t),
            "vertical" !== this.props.direction &&
              (this.position.x += this.velocity.x),
            "horizontal" !== this.props.direction &&
              (this.position.y += this.velocity.y),
            (this.props.bounce && !this.isScrolling) ||
              this.isTargetScroll ||
              ((this.position.x = Math.max(
                Math.min(this.position.x, this.edgeX.to),
                this.edgeX.from
              )),
              (this.position.y = Math.max(
                Math.min(this.position.y, this.edgeY.to),
                this.edgeY.from
              )));
        }
        applyForce(t) {
          (this.velocity.x += t.x), (this.velocity.y += t.y);
        }
        applyEdgeForce() {
          if (!this.props.bounce || this.isDragging) return;
          const t = this.position.x < this.edgeX.from,
            e = this.position.x > this.edgeX.to,
            n = this.position.y < this.edgeY.from,
            i = this.position.y > this.edgeY.to,
            r = t || e,
            s = n || i;
          if (!r && !s) return;
          const o = t ? this.edgeX.from : this.edgeX.to,
            a = n ? this.edgeY.from : this.edgeY.to,
            l = o - this.position.x,
            c = a - this.position.y,
            u = {
              x: l * this.props.bounceForce,
              y: c * this.props.bounceForce,
            },
            h = this.position.x + (this.velocity.x + u.x) / this.props.friction,
            d = this.position.y + (this.velocity.y + u.y) / this.props.friction;
          ((t && h >= this.edgeX.from) || (e && h <= this.edgeX.to)) &&
            (u.x = l * this.props.bounceForce - this.velocity.x),
            ((n && d >= this.edgeY.from) || (i && d <= this.edgeY.to)) &&
              (u.y = c * this.props.bounceForce - this.velocity.y),
            this.applyForce({
              x: r ? u.x : 0,
              y: s ? u.y : 0,
            });
        }
        applyDragForce() {
          if (!this.isDragging) return;
          const t = this.dragPosition.x - this.position.x,
            e = this.dragPosition.y - this.position.y;
          this.applyForce({
            x: t - this.velocity.x,
            y: e - this.velocity.y,
          });
        }
        applyScrollForce() {
          this.isScrolling &&
            (this.applyForce({
              x: this.scrollOffset.x - this.velocity.x,
              y: this.scrollOffset.y - this.velocity.y,
            }),
            (this.scrollOffset.x = 0),
            (this.scrollOffset.y = 0));
        }
        applyTargetForce() {
          this.isTargetScroll &&
            this.applyForce({
              x:
                0.08 * (this.targetPosition.x - this.position.x) -
                this.velocity.x,
              y:
                0.08 * (this.targetPosition.y - this.position.y) -
                this.velocity.y,
            });
        }
        isMoving() {
          return (
            this.isDragging ||
            this.isScrolling ||
            Math.abs(this.velocity.x) >= 0.01 ||
            Math.abs(this.velocity.y) >= 0.01
          );
        }
        scrollTo(t = {}) {
          (this.isTargetScroll = !0),
            (this.targetPosition.x = -t.x || 0),
            (this.targetPosition.y = -t.y || 0),
            this.startAnimationLoop();
        }
        setPosition(t = {}) {
          (this.velocity.x = 0),
            (this.velocity.y = 0),
            (this.position.x = -t.x || 0),
            (this.position.y = -t.y || 0),
            this.startAnimationLoop();
        }
        getState() {
          return {
            isMoving: this.isMoving(),
            isDragging: !(!this.dragOffset.x && !this.dragOffset.y),
            position: {
              x: -this.position.x,
              y: -this.position.y,
            },
            dragOffset: this.dragOffset,
            dragAngle: this.getDragAngle(
              this.clientOffset.x,
              this.clientOffset.y
            ),
            borderCollision: {
              left: this.position.x >= this.edgeX.to,
              right: this.position.x <= this.edgeX.from,
              top: this.position.y >= this.edgeY.to,
              bottom: this.position.y <= this.edgeY.from,
            },
          };
        }
        getDragAngle(t, e) {
          return Math.round(Math.atan2(t, e) * (180 / Math.PI));
        }
        getDragDirection(t, e) {
          return Math.abs(90 - Math.abs(t)) <= 90 - e
            ? "horizontal"
            : "vertical";
        }
        setContentPosition(t) {
          "transform" === this.props.scrollMode &&
            (this.props.content.style.transform = `translate(${-t.position
              .x}px, ${-t.position.y}px)`),
            "native" === this.props.scrollMode &&
              ((this.props.viewport.scrollTop = t.position.y),
              (this.props.viewport.scrollLeft = t.position.x));
        }
        handleEvents() {
          const t = {
              x: 0,
              y: 0,
            },
            e = {
              x: 0,
              y: 0,
            };
          let n = null,
            i = null,
            r = !1;
          const s = (i) => {
            if (!this.isDragging) return;
            const s = r ? i.touches[0] : i,
              { pageX: o, pageY: a, clientX: l, clientY: c } = s;
            (this.dragOffset.x = o - t.x),
              (this.dragOffset.y = a - t.y),
              (this.clientOffset.x = l - e.x),
              (this.clientOffset.y = c - e.y),
              ((Math.abs(this.clientOffset.x) > 5 && !n) ||
                (Math.abs(this.clientOffset.y) > 5 && !n)) &&
                (n = this.getDragDirection(
                  this.getDragAngle(this.clientOffset.x, this.clientOffset.y),
                  this.props.dragDirectionTolerance
                )),
              this.props.lockScrollOnDragDirection &&
              "all" !== this.props.lockScrollOnDragDirection
                ? n === this.props.lockScrollOnDragDirection && r
                  ? ((this.dragPosition.x =
                      this.dragStartPosition.x + this.dragOffset.x),
                    (this.dragPosition.y =
                      this.dragStartPosition.y + this.dragOffset.y))
                  : r
                  ? ((this.dragPosition.x = this.dragStartPosition.x),
                    (this.dragPosition.y = this.dragStartPosition.y))
                  : ((this.dragPosition.x =
                      this.dragStartPosition.x + this.dragOffset.x),
                    (this.dragPosition.y =
                      this.dragStartPosition.y + this.dragOffset.y))
                : ((this.dragPosition.x =
                    this.dragStartPosition.x + this.dragOffset.x),
                  (this.dragPosition.y =
                    this.dragStartPosition.y + this.dragOffset.y));
          };
          (this.events.pointerdown = (n) => {
            (r = !(!n.touches || !n.touches[0])),
              this.props.onPointerDown(this.getState(), n, r);
            const i = r ? n.touches[0] : n,
              { pageX: o, pageY: a, clientX: l, clientY: c } = i,
              { viewport: u } = this.props,
              h = u.getBoundingClientRect();
            if (
              !(l - h.left >= u.clientLeft + u.clientWidth) &&
              !(c - h.top >= u.clientTop + u.clientHeight) &&
              this.props.shouldScroll(this.getState(), n) &&
              2 !== n.button &&
              ("mouse" !== this.props.pointerMode || !r) &&
              ("touch" !== this.props.pointerMode || r) &&
              !(
                this.props.inputsFocus &&
                ["input", "textarea", "button", "select", "label"].indexOf(
                  n.target.nodeName.toLowerCase()
                ) > -1
              )
            ) {
              if (this.props.textSelection) {
                const t = ((t, e, n) => {
                  const i = t.childNodes,
                    r = document.createRange();
                  for (let t = 0; t < i.length; t++) {
                    const s = i[t];
                    if (3 !== s.nodeType) continue;
                    r.selectNodeContents(s);
                    const o = r.getBoundingClientRect();
                    if (
                      e >= o.left &&
                      n >= o.top &&
                      e <= o.right &&
                      n <= o.bottom
                    )
                      return s;
                  }
                  return !1;
                })(n.target, l, c);
                if (t) return;
                (() => {
                  const t = window.getSelection
                    ? window.getSelection()
                    : document.selection;
                  t &&
                    (t.removeAllRanges
                      ? t.removeAllRanges()
                      : t.empty && t.empty());
                })();
              }
              (this.isDragging = !0),
                (t.x = o),
                (t.y = a),
                (e.x = l),
                (e.y = c),
                (this.dragStartPosition.x = this.position.x),
                (this.dragStartPosition.y = this.position.y),
                s(n),
                this.startAnimationLoop(),
                !r &&
                  this.props.pointerDownPreventDefault &&
                  n.preventDefault();
            }
          }),
            (this.events.pointermove = (t) => {
              !t.cancelable ||
                ("all" !== this.props.lockScrollOnDragDirection &&
                  this.props.lockScrollOnDragDirection !== n) ||
                t.preventDefault(),
                s(t),
                this.props.onPointerMove(this.getState(), t, r);
            }),
            (this.events.pointerup = (t) => {
              (this.isDragging = !1),
                (n = null),
                this.props.onPointerUp(this.getState(), t, r);
            }),
            (this.events.wheel = (t) => {
              const e = this.getState();
              this.props.emulateScroll &&
                ((this.velocity.x = 0),
                (this.velocity.y = 0),
                (this.isScrolling = !0),
                (this.scrollOffset.x = -t.deltaX),
                (this.scrollOffset.y = -t.deltaY),
                this.props.onWheel(e, t),
                this.startAnimationLoop(),
                clearTimeout(i),
                (i = setTimeout(() => (this.isScrolling = !1), 80)),
                this.props.preventDefaultOnEmulateScroll &&
                  this.getDragDirection(
                    this.getDragAngle(-t.deltaX, -t.deltaY),
                    this.props.dragDirectionTolerance
                  ) === this.props.preventDefaultOnEmulateScroll &&
                  t.preventDefault());
            }),
            (this.events.scroll = () => {
              const { scrollLeft: t, scrollTop: e } = this.props.viewport;
              Math.abs(this.position.x + t) > 3 &&
                ((this.position.x = -t), (this.velocity.x = 0)),
                Math.abs(this.position.y + e) > 3 &&
                  ((this.position.y = -e), (this.velocity.y = 0));
            }),
            (this.events.click = (t) => {
              const e = this.getState(),
                n = "vertical" !== this.props.direction ? e.dragOffset.x : 0,
                i = "horizontal" !== this.props.direction ? e.dragOffset.y : 0;
              Math.max(Math.abs(n), Math.abs(i)) > 5 &&
                (t.preventDefault(), t.stopPropagation()),
                this.props.onClick(e, t, r);
            }),
            (this.events.contentLoad = () => this.updateMetrics()),
            (this.events.resize = () => this.updateMetrics()),
            this.props.viewport.addEventListener(
              "mousedown",
              this.events.pointerdown
            ),
            this.props.viewport.addEventListener(
              "touchstart",
              this.events.pointerdown,
              {
                passive: !1,
              }
            ),
            this.props.viewport.addEventListener("click", this.events.click),
            this.props.viewport.addEventListener("wheel", this.events.wheel, {
              passive: !1,
            }),
            this.props.viewport.addEventListener("scroll", this.events.scroll),
            this.props.content.addEventListener(
              "load",
              this.events.contentLoad,
              !0
            ),
            window.addEventListener("mousemove", this.events.pointermove),
            window.addEventListener("touchmove", this.events.pointermove, {
              passive: !1,
            }),
            window.addEventListener("mouseup", this.events.pointerup),
            window.addEventListener("touchend", this.events.pointerup),
            window.addEventListener("resize", this.events.resize);
        }
        destroy() {
          this.props.viewport.removeEventListener(
            "mousedown",
            this.events.pointerdown
          ),
            this.props.viewport.removeEventListener(
              "touchstart",
              this.events.pointerdown
            ),
            this.props.viewport.removeEventListener("click", this.events.click),
            this.props.viewport.removeEventListener("wheel", this.events.wheel),
            this.props.viewport.removeEventListener(
              "scroll",
              this.events.scroll
            ),
            this.props.content.removeEventListener(
              "load",
              this.events.contentLoad
            ),
            window.removeEventListener("mousemove", this.events.pointermove),
            window.removeEventListener("touchmove", this.events.pointermove),
            window.removeEventListener("mouseup", this.events.pointerup),
            window.removeEventListener("touchend", this.events.pointerup),
            window.removeEventListener("resize", this.events.resize);
        }
      }
      function Rh(t, e) {
        return (
          (Rh = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          Rh(t, e)
        );
      }
      var Lh = (function (t) {
        var e, n;
        function i() {
          var e;
          return (
            ((e = t.apply(this, arguments) || this).header =
              e.el.querySelector(".cb-summary-header")),
            (e.text = e.el.querySelector(".cb-summary-text")),
            (e.figure = e.el.querySelector(".cb-summary-figure")),
            (e.carousel = e.el.querySelector(".cb-summary-carousel")),
            (e.entry = e.el.querySelectorAll(".cb-summary-entry")),
            (e.more = e.el.querySelector(".cb-summary-more")),
            (e.actionBtn = e.el.querySelector(".cb-summary-action a")),
            e.initCarousel(),
            e
          );
        }
        (n = t),
          ((e = i).prototype = Object.create(n.prototype)),
          (e.prototype.constructor = e),
          Rh(e, n);
        var r = i.prototype;
        return (
          (r.onInit = function () {
            try {
              var t = this;
              return Promise.resolve(document.fonts.ready).then(function () {
                t.magicShow();
              });
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.onDestroy = function () {
            try {
              return this.swiper && this.sb.destroy(), Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.initCarousel = function () {
            this.carousel &&
              (this.sb = new Ph({
                viewport: this.carousel,
                scrollMode: "transform",
                direction: "horizontal",
                lockScrollOnDragDirection: "horizontal",
              }));
          }),
          (r.magicShow = function () {
            this.header &&
              kc(this.header.firstElementChild, {
                type: "lines",
                stagger: 0.2,
              }),
              this.text && kc(this.text),
              this.figure &&
                Bc(this.figure, {
                  from: 0.5,
                }),
              this.entry.length &&
                jc(this.entry, {
                  duration: 1,
                }),
              this.more && Vc(this.more),
              this.actionBtn && qc(this.actionBtn);
          }),
          i
        );
      })(o);
      function Oh(t, e) {
        return (
          (Oh = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          Oh(t, e)
        );
      }
      var Ih = (function (t) {
        var e, n;
        function i() {
          var e;
          return (
            ((e = t.apply(this, arguments) || this).preview =
              e.el.querySelector(".cb-screenshot-preview")),
            (e.previewMedia = e.preview.querySelector(
              ".cb-screenshot-preview-media"
            )),
            e
          );
        }
        (n = t),
          ((e = i).prototype = Object.create(n.prototype)),
          (e.prototype.constructor = e),
          Oh(e, n);
        var r = i.prototype;
        return (
          (r.onInit = function () {
            try {
              return this.magicShow(), this.magicParallax(), Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.magicShow = function () {
            ta.create({
              trigger: this.el,
              animation: this.tlShow(),
              once: !0,
            });
          }),
          (r.tlShow = function () {
            var t = new Zi.timeline();
            return (
              Zi.set(this.previewMedia, {
                opacity: 0,
              }),
              t.to(this.previewMedia, {
                opacity: 1,
                duration: 1,
              }),
              t
            );
          }),
          (r.magicParallax = function () {
            ta.create({
              trigger: this.el,
              animation: this.tlParallax(),
              start: "top bottom",
              end: "bottom top",
              scrub: !0,
            });
          }),
          (r.tlParallax = function () {
            var t = new Zi.timeline();
            return (
              Zi.set(this.previewMedia, {
                scale: 1.05,
              }),
              t.fromTo(
                this.previewMedia,
                {
                  y: "-10%",
                },
                {
                  y: "10%",
                  ease: "none",
                }
              ),
              t
            );
          }),
          i
        );
      })(o);
      function Fh(t, e) {
        return (
          (Fh = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          Fh(t, e)
        );
      }
      var Nh = (function (t) {
        var e, n;
        function i() {
          var e;
          return (
            ((e = t.apply(this, arguments) || this).layout =
              e.app.get("layout")),
            (e.reel = e.el.querySelector(".cb-nextcase-reel")),
            e.initReeller(),
            e
          );
        }
        (n = t),
          ((e = i).prototype = Object.create(n.prototype)),
          (e.prototype.constructor = e),
          Fh(e, n);
        var r = i.prototype;
        return (
          (r.onDestroy = function () {
            try {
              return this.reeller.destroy(), Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.initReeller = function () {
            var t = this;
            this.reeller = new Eh({
              container: this.reel,
              wrapper: ".cb-nextcase-reel-items",
              itemSelector: ".cb-nextcase-reel-item",
              speed: 15,
              plugins: {
                scroller: {
                  multiplier: 0.3,
                  speed: 1,
                  threshold: 1,
                  reversed: !0,
                  scrollProxy: function () {
                    return t.layout.scrollTop();
                  },
                },
              },
            });
          }),
          i
        );
      })(o);
      function Uh(t, e) {
        return (
          (Uh = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          Uh(t, e)
        );
      }
      var kh = (function (t) {
        var e, n;
        function i() {
          var e;
          return (
            ((e = t.apply(this, arguments) || this).layout =
              e.app.get("layout")),
            (e.reel = e.el.querySelector(".cb-smfeed-reel")),
            (e.carousel = e.el.querySelector(".cb-smfeed-carousel")),
            (e.item = e.el.querySelectorAll(".cb-smfeed-item")),
            e
          );
        }
        (n = t),
          ((e = i).prototype = Object.create(n.prototype)),
          (e.prototype.constructor = e),
          Uh(e, n);
        var r = i.prototype;
        return (
          (r.onInit = function () {
            try {
              var t = this;
              return Promise.resolve(document.fonts.ready).then(function () {
                t.initReeller(), t.initCarousel(), t.magicShow();
              });
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.onDestroy = function () {
            try {
              return this.sb && this.sb.destroy(), Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.initCarousel = function () {
            this.carousel &&
              (this.sb = new Ph({
                viewport: this.carousel,
                scrollMode: "transform",
                direction: "horizontal",
                lockScrollOnDragDirection: "horizontal",
              }));
          }),
          (r.initReeller = function () {
            var t = this;
            this.reel &&
              (this.reeller = new Eh({
                container: this.reel,
                wrapper: ".cb-smfeed-reel-wrap",
                itemSelector: ".cb-smfeed-reel-item",
                speed: 20,
                plugins: {
                  scroller: {
                    multiplier: 0.3,
                    speed: 1,
                    threshold: 1,
                    reversed: !0,
                    scrollProxy: function () {
                      var e;
                      return null == (e = t.layout) ? void 0 : e.scrollTop();
                    },
                  },
                },
              }));
          }),
          (r.magicShow = function () {
            this.item.length &&
              jc(this.item, {
                duration: 1,
              });
          }),
          i
        );
      })(o);
      function zh(t, e) {
        return (
          (zh = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          zh(t, e)
        );
      }
      var Bh = (function (t) {
        var e, n;
        function i() {
          var e;
          return (
            ((e = t.apply(this, arguments) || this).layout =
              e.app.get("layout")),
            (e.reel = e.el.querySelector(".cb-outro-reel")),
            (e.header = e.el.querySelector(".cb-outro-header")),
            (e.caption = e.el.querySelector(".cb-outro-caption")),
            (e.social = e.el.querySelectorAll(".cb-outro-social")),
            (e.location = e.el.querySelectorAll(".cb-outro-location")),
            e.initReeller(),
            e
          );
        }
        (n = t),
          ((e = i).prototype = Object.create(n.prototype)),
          (e.prototype.constructor = e),
          zh(e, n);
        var r = i.prototype;
        return (
          (r.onInit = function () {
            try {
              return this.magicShow(), Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.initReeller = function () {
            var t = this;
            new Eh({
              container: this.reel,
              wrapper: ".cb-outro-reel-wrap",
              itemSelector: ".cb-outro-reel-item",
              speed: 10,
              plugins: {
                scroller: {
                  multiplier: 0.3,
                  speed: 1,
                  threshold: 1,
                  reversed: !0,
                  scrollProxy: function () {
                    var e;
                    return null == (e = t.layout) ? void 0 : e.scrollTop();
                  },
                },
              },
            }),
              ta.isTouch ||
                this.social.forEach(function (t) {
                  var e = t.querySelector(".cb-outro-social-reel"),
                    n = new Eh({
                      container: e,
                      wrapper: ".cb-outro-social-reel-wrap",
                      itemSelector: ".cb-outro-social-reel-item",
                      autoStop: !1,
                      speed: 3,
                    });
                  t.addEventListener("mouseenter", function () {
                    return n.reverse();
                  }),
                    t.addEventListener("mouseleave", function () {
                      return n.pause();
                    });
                });
          }),
          (r.magicShow = function () {
            var t = this;
            this.caption &&
              kc(this.caption, {
                stagger: 0.1,
              }),
              this.social.length &&
                this.social.forEach(function (e) {
                  ta.create({
                    trigger: e,
                    start: "center bottom",
                    animation: t.tlShowSocialItem(e),
                    once: !0,
                  });
                }),
              this.location.length &&
                this.location.forEach(function (e) {
                  ta.create({
                    trigger: e,
                    start: "center bottom",
                    animation: t.tlShowLocationItem(e),
                    once: !0,
                  });
                });
          }),
          (r.tlShowSocialItem = function (t) {
            var e = new Zi.timeline(),
              n = t.querySelector(".cb-outro-social-title"),
              i = t.querySelector(".cb-outro-social-divider"),
              r = t.querySelector(".cb-outro-social-arr");
            return (
              Zi.set(i, {
                scaleX: 0,
                transformOrigin: "left center",
              }),
              e.to(
                i,
                {
                  scaleX: 1,
                  duration: 3,
                  stagger: 0.3,
                  ease: "expo.out",
                },
                0
              ),
              e.add(
                Uc(n, {
                  duration: 2.5,
                }),
                0
              ),
              e.add(zc(r), 0.5),
              e
            );
          }),
          (r.tlShowLocationItem = function (t) {
            var e = new Zi.timeline(),
              n = t.querySelector(".cb-outro-location-caption"),
              i = t.querySelector(".cb-outro-location-address"),
              r = t.querySelector(".cb-outro-location-action");
            return e.add(Wc(n), 0), e.add(Uc(i), 0.2), e.add(Hc(r), 0.4), e;
          }),
          i
        );
      })(o);
      const Hh = "157",
        Vh = 1,
        Gh = 2,
        Wh = 3,
        jh = 100,
        Xh = 0,
        qh = 1,
        Yh = 2,
        Kh = 0,
        Zh = 1,
        $h = 2,
        Jh = 3,
        Qh = 4,
        td = 5,
        ed = 301,
        nd = 302,
        id = 306,
        rd = 1e3,
        sd = 1001,
        od = 1002,
        ad = 1003,
        ld = 1005,
        cd = 1006,
        ud = 1008,
        hd = 1009,
        dd = 1012,
        pd = 1014,
        fd = 1015,
        md = 1016,
        gd = 1020,
        vd = 1023,
        _d = 1026,
        yd = 1027,
        xd = 33776,
        bd = 33777,
        Sd = 33778,
        Ed = 33779,
        Td = 36492,
        Md = 2300,
        wd = 2301,
        Dd = 2302,
        Ad = 3001,
        Cd = "",
        Pd = "srgb",
        Rd = "srgb-linear",
        Ld = "display-p3",
        Od = "display-p3-linear",
        Id = "linear",
        Fd = "srgb",
        Nd = "rec709",
        Ud = "p3",
        kd = 7680,
        zd = "300 es",
        Bd = 1035,
        Hd = 2e3,
        Vd = 2001;
      class Gd {
        addEventListener(t, e) {
          void 0 === this._listeners && (this._listeners = {});
          const n = this._listeners;
          void 0 === n[t] && (n[t] = []),
            -1 === n[t].indexOf(e) && n[t].push(e);
        }
        hasEventListener(t, e) {
          if (void 0 === this._listeners) return !1;
          const n = this._listeners;
          return void 0 !== n[t] && -1 !== n[t].indexOf(e);
        }
        removeEventListener(t, e) {
          if (void 0 === this._listeners) return;
          const n = this._listeners[t];
          if (void 0 !== n) {
            const t = n.indexOf(e);
            -1 !== t && n.splice(t, 1);
          }
        }
        dispatchEvent(t) {
          if (void 0 === this._listeners) return;
          const e = this._listeners[t.type];
          if (void 0 !== e) {
            t.target = this;
            const n = e.slice(0);
            for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
            t.target = null;
          }
        }
      }
      const Wd = [
          "00",
          "01",
          "02",
          "03",
          "04",
          "05",
          "06",
          "07",
          "08",
          "09",
          "0a",
          "0b",
          "0c",
          "0d",
          "0e",
          "0f",
          "10",
          "11",
          "12",
          "13",
          "14",
          "15",
          "16",
          "17",
          "18",
          "19",
          "1a",
          "1b",
          "1c",
          "1d",
          "1e",
          "1f",
          "20",
          "21",
          "22",
          "23",
          "24",
          "25",
          "26",
          "27",
          "28",
          "29",
          "2a",
          "2b",
          "2c",
          "2d",
          "2e",
          "2f",
          "30",
          "31",
          "32",
          "33",
          "34",
          "35",
          "36",
          "37",
          "38",
          "39",
          "3a",
          "3b",
          "3c",
          "3d",
          "3e",
          "3f",
          "40",
          "41",
          "42",
          "43",
          "44",
          "45",
          "46",
          "47",
          "48",
          "49",
          "4a",
          "4b",
          "4c",
          "4d",
          "4e",
          "4f",
          "50",
          "51",
          "52",
          "53",
          "54",
          "55",
          "56",
          "57",
          "58",
          "59",
          "5a",
          "5b",
          "5c",
          "5d",
          "5e",
          "5f",
          "60",
          "61",
          "62",
          "63",
          "64",
          "65",
          "66",
          "67",
          "68",
          "69",
          "6a",
          "6b",
          "6c",
          "6d",
          "6e",
          "6f",
          "70",
          "71",
          "72",
          "73",
          "74",
          "75",
          "76",
          "77",
          "78",
          "79",
          "7a",
          "7b",
          "7c",
          "7d",
          "7e",
          "7f",
          "80",
          "81",
          "82",
          "83",
          "84",
          "85",
          "86",
          "87",
          "88",
          "89",
          "8a",
          "8b",
          "8c",
          "8d",
          "8e",
          "8f",
          "90",
          "91",
          "92",
          "93",
          "94",
          "95",
          "96",
          "97",
          "98",
          "99",
          "9a",
          "9b",
          "9c",
          "9d",
          "9e",
          "9f",
          "a0",
          "a1",
          "a2",
          "a3",
          "a4",
          "a5",
          "a6",
          "a7",
          "a8",
          "a9",
          "aa",
          "ab",
          "ac",
          "ad",
          "ae",
          "af",
          "b0",
          "b1",
          "b2",
          "b3",
          "b4",
          "b5",
          "b6",
          "b7",
          "b8",
          "b9",
          "ba",
          "bb",
          "bc",
          "bd",
          "be",
          "bf",
          "c0",
          "c1",
          "c2",
          "c3",
          "c4",
          "c5",
          "c6",
          "c7",
          "c8",
          "c9",
          "ca",
          "cb",
          "cc",
          "cd",
          "ce",
          "cf",
          "d0",
          "d1",
          "d2",
          "d3",
          "d4",
          "d5",
          "d6",
          "d7",
          "d8",
          "d9",
          "da",
          "db",
          "dc",
          "dd",
          "de",
          "df",
          "e0",
          "e1",
          "e2",
          "e3",
          "e4",
          "e5",
          "e6",
          "e7",
          "e8",
          "e9",
          "ea",
          "eb",
          "ec",
          "ed",
          "ee",
          "ef",
          "f0",
          "f1",
          "f2",
          "f3",
          "f4",
          "f5",
          "f6",
          "f7",
          "f8",
          "f9",
          "fa",
          "fb",
          "fc",
          "fd",
          "fe",
          "ff",
        ],
        jd = Math.PI / 180,
        Xd = 180 / Math.PI;
      function qd() {
        const t = (4294967295 * Math.random()) | 0,
          e = (4294967295 * Math.random()) | 0,
          n = (4294967295 * Math.random()) | 0,
          i = (4294967295 * Math.random()) | 0;
        return (
          Wd[255 & t] +
          Wd[(t >> 8) & 255] +
          Wd[(t >> 16) & 255] +
          Wd[(t >> 24) & 255] +
          "-" +
          Wd[255 & e] +
          Wd[(e >> 8) & 255] +
          "-" +
          Wd[((e >> 16) & 15) | 64] +
          Wd[(e >> 24) & 255] +
          "-" +
          Wd[(63 & n) | 128] +
          Wd[(n >> 8) & 255] +
          "-" +
          Wd[(n >> 16) & 255] +
          Wd[(n >> 24) & 255] +
          Wd[255 & i] +
          Wd[(i >> 8) & 255] +
          Wd[(i >> 16) & 255] +
          Wd[(i >> 24) & 255]
        ).toLowerCase();
      }
      function Yd(t, e, n) {
        return Math.max(e, Math.min(n, t));
      }
      function Kd(t, e, n) {
        return (1 - n) * t + n * e;
      }
      function Zd(t) {
        return 0 == (t & (t - 1)) && 0 !== t;
      }
      function $d(t) {
        return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
      }
      function Jd(t, e) {
        switch (e.constructor) {
          case Float32Array:
            return t;
          case Uint32Array:
            return t / 4294967295;
          case Uint16Array:
            return t / 65535;
          case Uint8Array:
            return t / 255;
          case Int32Array:
            return Math.max(t / 2147483647, -1);
          case Int16Array:
            return Math.max(t / 32767, -1);
          case Int8Array:
            return Math.max(t / 127, -1);
          default:
            throw new Error("Invalid component type.");
        }
      }
      function Qd(t, e) {
        switch (e.constructor) {
          case Float32Array:
            return t;
          case Uint32Array:
            return Math.round(4294967295 * t);
          case Uint16Array:
            return Math.round(65535 * t);
          case Uint8Array:
            return Math.round(255 * t);
          case Int32Array:
            return Math.round(2147483647 * t);
          case Int16Array:
            return Math.round(32767 * t);
          case Int8Array:
            return Math.round(127 * t);
          default:
            throw new Error("Invalid component type.");
        }
      }
      class tp {
        constructor(t = 0, e = 0) {
          (tp.prototype.isVector2 = !0), (this.x = t), (this.y = e);
        }
        get width() {
          return this.x;
        }
        set width(t) {
          this.x = t;
        }
        get height() {
          return this.y;
        }
        set height(t) {
          this.y = t;
        }
        set(t, e) {
          return (this.x = t), (this.y = e), this;
        }
        setScalar(t) {
          return (this.x = t), (this.y = t), this;
        }
        setX(t) {
          return (this.x = t), this;
        }
        setY(t) {
          return (this.y = t), this;
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(t) {
          return (this.x = t.x), (this.y = t.y), this;
        }
        add(t) {
          return (this.x += t.x), (this.y += t.y), this;
        }
        addScalar(t) {
          return (this.x += t), (this.y += t), this;
        }
        addVectors(t, e) {
          return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
        }
        addScaledVector(t, e) {
          return (this.x += t.x * e), (this.y += t.y * e), this;
        }
        sub(t) {
          return (this.x -= t.x), (this.y -= t.y), this;
        }
        subScalar(t) {
          return (this.x -= t), (this.y -= t), this;
        }
        subVectors(t, e) {
          return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
        }
        multiply(t) {
          return (this.x *= t.x), (this.y *= t.y), this;
        }
        multiplyScalar(t) {
          return (this.x *= t), (this.y *= t), this;
        }
        divide(t) {
          return (this.x /= t.x), (this.y /= t.y), this;
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        applyMatrix3(t) {
          const e = this.x,
            n = this.y,
            i = t.elements;
          return (
            (this.x = i[0] * e + i[3] * n + i[6]),
            (this.y = i[1] * e + i[4] * n + i[7]),
            this
          );
        }
        min(t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            this
          );
        }
        max(t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            this
          );
        }
        clamp(t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            this
          );
        }
        clampScalar(t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            this
          );
        }
        clampLength(t, e) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(t, Math.min(e, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          );
        }
        roundToZero() {
          return (
            (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this
          );
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), this;
        }
        dot(t) {
          return this.x * t.x + this.y * t.y;
        }
        cross(t) {
          return this.x * t.y - this.y * t.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        angleTo(t) {
          const e = Math.sqrt(this.lengthSq() * t.lengthSq());
          if (0 === e) return Math.PI / 2;
          const n = this.dot(t) / e;
          return Math.acos(Yd(n, -1, 1));
        }
        distanceTo(t) {
          return Math.sqrt(this.distanceToSquared(t));
        }
        distanceToSquared(t) {
          const e = this.x - t.x,
            n = this.y - t.y;
          return e * e + n * n;
        }
        manhattanDistanceTo(t) {
          return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
          return (
            (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
          );
        }
        lerpVectors(t, e, n) {
          return (
            (this.x = t.x + (e.x - t.x) * n),
            (this.y = t.y + (e.y - t.y) * n),
            this
          );
        }
        equals(t) {
          return t.x === this.x && t.y === this.y;
        }
        fromArray(t, e = 0) {
          return (this.x = t[e]), (this.y = t[e + 1]), this;
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.x), (t[e + 1] = this.y), t;
        }
        fromBufferAttribute(t, e) {
          return (this.x = t.getX(e)), (this.y = t.getY(e)), this;
        }
        rotateAround(t, e) {
          const n = Math.cos(e),
            i = Math.sin(e),
            r = this.x - t.x,
            s = this.y - t.y;
          return (
            (this.x = r * n - s * i + t.x), (this.y = r * i + s * n + t.y), this
          );
        }
        random() {
          return (this.x = Math.random()), (this.y = Math.random()), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y;
        }
      }
      class ep {
        constructor(t, e, n, i, r, s, o, a, l) {
          (ep.prototype.isMatrix3 = !0),
            (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            void 0 !== t && this.set(t, e, n, i, r, s, o, a, l);
        }
        set(t, e, n, i, r, s, o, a, l) {
          const c = this.elements;
          return (
            (c[0] = t),
            (c[1] = i),
            (c[2] = o),
            (c[3] = e),
            (c[4] = r),
            (c[5] = a),
            (c[6] = n),
            (c[7] = s),
            (c[8] = l),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(t) {
          const e = this.elements,
            n = t.elements;
          return (
            (e[0] = n[0]),
            (e[1] = n[1]),
            (e[2] = n[2]),
            (e[3] = n[3]),
            (e[4] = n[4]),
            (e[5] = n[5]),
            (e[6] = n[6]),
            (e[7] = n[7]),
            (e[8] = n[8]),
            this
          );
        }
        extractBasis(t, e, n) {
          return (
            t.setFromMatrix3Column(this, 0),
            e.setFromMatrix3Column(this, 1),
            n.setFromMatrix3Column(this, 2),
            this
          );
        }
        setFromMatrix4(t) {
          const e = t.elements;
          return (
            this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
            this
          );
        }
        multiply(t) {
          return this.multiplyMatrices(this, t);
        }
        premultiply(t) {
          return this.multiplyMatrices(t, this);
        }
        multiplyMatrices(t, e) {
          const n = t.elements,
            i = e.elements,
            r = this.elements,
            s = n[0],
            o = n[3],
            a = n[6],
            l = n[1],
            c = n[4],
            u = n[7],
            h = n[2],
            d = n[5],
            p = n[8],
            f = i[0],
            m = i[3],
            g = i[6],
            v = i[1],
            _ = i[4],
            y = i[7],
            x = i[2],
            b = i[5],
            S = i[8];
          return (
            (r[0] = s * f + o * v + a * x),
            (r[3] = s * m + o * _ + a * b),
            (r[6] = s * g + o * y + a * S),
            (r[1] = l * f + c * v + u * x),
            (r[4] = l * m + c * _ + u * b),
            (r[7] = l * g + c * y + u * S),
            (r[2] = h * f + d * v + p * x),
            (r[5] = h * m + d * _ + p * b),
            (r[8] = h * g + d * y + p * S),
            this
          );
        }
        multiplyScalar(t) {
          const e = this.elements;
          return (
            (e[0] *= t),
            (e[3] *= t),
            (e[6] *= t),
            (e[1] *= t),
            (e[4] *= t),
            (e[7] *= t),
            (e[2] *= t),
            (e[5] *= t),
            (e[8] *= t),
            this
          );
        }
        determinant() {
          const t = this.elements,
            e = t[0],
            n = t[1],
            i = t[2],
            r = t[3],
            s = t[4],
            o = t[5],
            a = t[6],
            l = t[7],
            c = t[8];
          return (
            e * s * c -
            e * o * l -
            n * r * c +
            n * o * a +
            i * r * l -
            i * s * a
          );
        }
        invert() {
          const t = this.elements,
            e = t[0],
            n = t[1],
            i = t[2],
            r = t[3],
            s = t[4],
            o = t[5],
            a = t[6],
            l = t[7],
            c = t[8],
            u = c * s - o * l,
            h = o * a - c * r,
            d = l * r - s * a,
            p = e * u + n * h + i * d;
          if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const f = 1 / p;
          return (
            (t[0] = u * f),
            (t[1] = (i * l - c * n) * f),
            (t[2] = (o * n - i * s) * f),
            (t[3] = h * f),
            (t[4] = (c * e - i * a) * f),
            (t[5] = (i * r - o * e) * f),
            (t[6] = d * f),
            (t[7] = (n * a - l * e) * f),
            (t[8] = (s * e - n * r) * f),
            this
          );
        }
        transpose() {
          let t;
          const e = this.elements;
          return (
            (t = e[1]),
            (e[1] = e[3]),
            (e[3] = t),
            (t = e[2]),
            (e[2] = e[6]),
            (e[6] = t),
            (t = e[5]),
            (e[5] = e[7]),
            (e[7] = t),
            this
          );
        }
        getNormalMatrix(t) {
          return this.setFromMatrix4(t).invert().transpose();
        }
        transposeIntoArray(t) {
          const e = this.elements;
          return (
            (t[0] = e[0]),
            (t[1] = e[3]),
            (t[2] = e[6]),
            (t[3] = e[1]),
            (t[4] = e[4]),
            (t[5] = e[7]),
            (t[6] = e[2]),
            (t[7] = e[5]),
            (t[8] = e[8]),
            this
          );
        }
        setUvTransform(t, e, n, i, r, s, o) {
          const a = Math.cos(r),
            l = Math.sin(r);
          return (
            this.set(
              n * a,
              n * l,
              -n * (a * s + l * o) + s + t,
              -i * l,
              i * a,
              -i * (-l * s + a * o) + o + e,
              0,
              0,
              1
            ),
            this
          );
        }
        scale(t, e) {
          return this.premultiply(np.makeScale(t, e)), this;
        }
        rotate(t) {
          return this.premultiply(np.makeRotation(-t)), this;
        }
        translate(t, e) {
          return this.premultiply(np.makeTranslation(t, e)), this;
        }
        makeTranslation(t, e) {
          return (
            t.isVector2
              ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1)
              : this.set(1, 0, t, 0, 1, e, 0, 0, 1),
            this
          );
        }
        makeRotation(t) {
          const e = Math.cos(t),
            n = Math.sin(t);
          return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this;
        }
        makeScale(t, e) {
          return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this;
        }
        equals(t) {
          const e = this.elements,
            n = t.elements;
          for (let t = 0; t < 9; t++) if (e[t] !== n[t]) return !1;
          return !0;
        }
        fromArray(t, e = 0) {
          for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
          return this;
        }
        toArray(t = [], e = 0) {
          const n = this.elements;
          return (
            (t[e] = n[0]),
            (t[e + 1] = n[1]),
            (t[e + 2] = n[2]),
            (t[e + 3] = n[3]),
            (t[e + 4] = n[4]),
            (t[e + 5] = n[5]),
            (t[e + 6] = n[6]),
            (t[e + 7] = n[7]),
            (t[e + 8] = n[8]),
            t
          );
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      const np = new ep();
      function ip(t) {
        for (let e = t.length - 1; e >= 0; --e) if (t[e] >= 65535) return !0;
        return !1;
      }
      function rp(t) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", t);
      }
      function sp() {
        const t = rp("canvas");
        return (t.style.display = "block"), t;
      }
      Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array;
      const op = {};
      function ap(t) {
        t in op || ((op[t] = !0), console.warn(t));
      }
      const lp = new ep().set(
          0.8224621,
          0.177538,
          0,
          0.0331941,
          0.9668058,
          0,
          0.0170827,
          0.0723974,
          0.9105199
        ),
        cp = new ep().set(
          1.2249401,
          -0.2249404,
          0,
          -0.0420569,
          1.0420571,
          0,
          -0.0196376,
          -0.0786361,
          1.0982735
        ),
        up = {
          [Rd]: {
            transfer: Id,
            primaries: Nd,
            toReference: (t) => t,
            fromReference: (t) => t,
          },
          [Pd]: {
            transfer: Fd,
            primaries: Nd,
            toReference: (t) => t.convertSRGBToLinear(),
            fromReference: (t) => t.convertLinearToSRGB(),
          },
          [Od]: {
            transfer: Id,
            primaries: Ud,
            toReference: (t) => t.applyMatrix3(cp),
            fromReference: (t) => t.applyMatrix3(lp),
          },
          [Ld]: {
            transfer: Fd,
            primaries: Ud,
            toReference: (t) => t.convertSRGBToLinear().applyMatrix3(cp),
            fromReference: (t) => t.applyMatrix3(lp).convertLinearToSRGB(),
          },
        },
        hp = new Set([Rd, Od]),
        dp = {
          enabled: !0,
          _workingColorSpace: Rd,
          get legacyMode() {
            return (
              console.warn(
                "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
              ),
              !this.enabled
            );
          },
          set legacyMode(t) {
            console.warn(
              "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
            ),
              (this.enabled = !t);
          },
          get workingColorSpace() {
            return this._workingColorSpace;
          },
          set workingColorSpace(t) {
            if (!hp.has(t))
              throw new Error(`Unsupported working color space, "${t}".`);
            this._workingColorSpace = t;
          },
          convert: function (t, e, n) {
            if (!1 === this.enabled || e === n || !e || !n) return t;
            const i = up[e].toReference;
            return (0, up[n].fromReference)(i(t));
          },
          fromWorkingColorSpace: function (t, e) {
            return this.convert(t, this._workingColorSpace, e);
          },
          toWorkingColorSpace: function (t, e) {
            return this.convert(t, e, this._workingColorSpace);
          },
          getPrimaries: function (t) {
            return up[t].primaries;
          },
          getTransfer: function (t) {
            return t === Cd ? Id : up[t].transfer;
          },
        };
      function pp(t) {
        return t < 0.04045
          ? 0.0773993808 * t
          : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
      }
      function fp(t) {
        return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
      }
      let mp;
      class gp {
        static getDataURL(t) {
          if (/^data:/i.test(t.src)) return t.src;
          if ("undefined" == typeof HTMLCanvasElement) return t.src;
          let e;
          if (t instanceof HTMLCanvasElement) e = t;
          else {
            void 0 === mp && (mp = rp("canvas")),
              (mp.width = t.width),
              (mp.height = t.height);
            const n = mp.getContext("2d");
            t instanceof ImageData
              ? n.putImageData(t, 0, 0)
              : n.drawImage(t, 0, 0, t.width, t.height),
              (e = mp);
          }
          return e.width > 2048 || e.height > 2048
            ? (console.warn(
                "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                t
              ),
              e.toDataURL("image/jpeg", 0.6))
            : e.toDataURL("image/png");
        }
        static sRGBToLinear(t) {
          if (
            ("undefined" != typeof HTMLImageElement &&
              t instanceof HTMLImageElement) ||
            ("undefined" != typeof HTMLCanvasElement &&
              t instanceof HTMLCanvasElement) ||
            ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
          ) {
            const e = rp("canvas");
            (e.width = t.width), (e.height = t.height);
            const n = e.getContext("2d");
            n.drawImage(t, 0, 0, t.width, t.height);
            const i = n.getImageData(0, 0, t.width, t.height),
              r = i.data;
            for (let t = 0; t < r.length; t++) r[t] = 255 * pp(r[t] / 255);
            return n.putImageData(i, 0, 0), e;
          }
          if (t.data) {
            const e = t.data.slice(0);
            for (let t = 0; t < e.length; t++)
              e instanceof Uint8Array || e instanceof Uint8ClampedArray
                ? (e[t] = Math.floor(255 * pp(e[t] / 255)))
                : (e[t] = pp(e[t]));
            return {
              data: e,
              width: t.width,
              height: t.height,
            };
          }
          return (
            console.warn(
              "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
            ),
            t
          );
        }
      }
      let vp = 0;
      class _p {
        constructor(t = null) {
          (this.isSource = !0),
            Object.defineProperty(this, "id", {
              value: vp++,
            }),
            (this.uuid = qd()),
            (this.data = t),
            (this.version = 0);
        }
        set needsUpdate(t) {
          !0 === t && this.version++;
        }
        toJSON(t) {
          const e = void 0 === t || "string" == typeof t;
          if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid];
          const n = {
              uuid: this.uuid,
              url: "",
            },
            i = this.data;
          if (null !== i) {
            let t;
            if (Array.isArray(i)) {
              t = [];
              for (let e = 0, n = i.length; e < n; e++)
                i[e].isDataTexture ? t.push(yp(i[e].image)) : t.push(yp(i[e]));
            } else t = yp(i);
            n.url = t;
          }
          return e || (t.images[this.uuid] = n), n;
        }
      }
      function yp(t) {
        return ("undefined" != typeof HTMLImageElement &&
          t instanceof HTMLImageElement) ||
          ("undefined" != typeof HTMLCanvasElement &&
            t instanceof HTMLCanvasElement) ||
          ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
          ? gp.getDataURL(t)
          : t.data
          ? {
              data: Array.from(t.data),
              width: t.width,
              height: t.height,
              type: t.data.constructor.name,
            }
          : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      let xp = 0;
      class bp extends Gd {
        constructor(
          t = bp.DEFAULT_IMAGE,
          e = bp.DEFAULT_MAPPING,
          n = 1001,
          i = 1001,
          r = 1006,
          s = 1008,
          o = 1023,
          a = 1009,
          l = bp.DEFAULT_ANISOTROPY,
          c = ""
        ) {
          super(),
            (this.isTexture = !0),
            Object.defineProperty(this, "id", {
              value: xp++,
            }),
            (this.uuid = qd()),
            (this.name = ""),
            (this.source = new _p(t)),
            (this.mipmaps = []),
            (this.mapping = e),
            (this.channel = 0),
            (this.wrapS = n),
            (this.wrapT = i),
            (this.magFilter = r),
            (this.minFilter = s),
            (this.anisotropy = l),
            (this.format = o),
            (this.internalFormat = null),
            (this.type = a),
            (this.offset = new tp(0, 0)),
            (this.repeat = new tp(1, 1)),
            (this.center = new tp(0, 0)),
            (this.rotation = 0),
            (this.matrixAutoUpdate = !0),
            (this.matrix = new ep()),
            (this.generateMipmaps = !0),
            (this.premultiplyAlpha = !1),
            (this.flipY = !0),
            (this.unpackAlignment = 4),
            "string" == typeof c
              ? (this.colorSpace = c)
              : (ap(
                  "THREE.Texture: Property .encoding has been replaced by .colorSpace."
                ),
                (this.colorSpace = c === Ad ? Pd : Cd)),
            (this.userData = {}),
            (this.version = 0),
            (this.onUpdate = null),
            (this.isRenderTargetTexture = !1),
            (this.needsPMREMUpdate = !1);
        }
        get image() {
          return this.source.data;
        }
        set image(t = null) {
          this.source.data = t;
        }
        updateMatrix() {
          this.matrix.setUvTransform(
            this.offset.x,
            this.offset.y,
            this.repeat.x,
            this.repeat.y,
            this.rotation,
            this.center.x,
            this.center.y
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return (
            (this.name = t.name),
            (this.source = t.source),
            (this.mipmaps = t.mipmaps.slice(0)),
            (this.mapping = t.mapping),
            (this.channel = t.channel),
            (this.wrapS = t.wrapS),
            (this.wrapT = t.wrapT),
            (this.magFilter = t.magFilter),
            (this.minFilter = t.minFilter),
            (this.anisotropy = t.anisotropy),
            (this.format = t.format),
            (this.internalFormat = t.internalFormat),
            (this.type = t.type),
            this.offset.copy(t.offset),
            this.repeat.copy(t.repeat),
            this.center.copy(t.center),
            (this.rotation = t.rotation),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this.matrix.copy(t.matrix),
            (this.generateMipmaps = t.generateMipmaps),
            (this.premultiplyAlpha = t.premultiplyAlpha),
            (this.flipY = t.flipY),
            (this.unpackAlignment = t.unpackAlignment),
            (this.colorSpace = t.colorSpace),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            (this.needsUpdate = !0),
            this
          );
        }
        toJSON(t) {
          const e = void 0 === t || "string" == typeof t;
          if (!e && void 0 !== t.textures[this.uuid])
            return t.textures[this.uuid];
          const n = {
            metadata: {
              version: 4.6,
              type: "Texture",
              generator: "Texture.toJSON",
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(t).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment,
          };
          return (
            Object.keys(this.userData).length > 0 &&
              (n.userData = this.userData),
            e || (t.textures[this.uuid] = n),
            n
          );
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose",
          });
        }
        transformUv(t) {
          if (300 !== this.mapping) return t;
          if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
            switch (this.wrapS) {
              case rd:
                t.x = t.x - Math.floor(t.x);
                break;
              case sd:
                t.x = t.x < 0 ? 0 : 1;
                break;
              case od:
                1 === Math.abs(Math.floor(t.x) % 2)
                  ? (t.x = Math.ceil(t.x) - t.x)
                  : (t.x = t.x - Math.floor(t.x));
            }
          if (t.y < 0 || t.y > 1)
            switch (this.wrapT) {
              case rd:
                t.y = t.y - Math.floor(t.y);
                break;
              case sd:
                t.y = t.y < 0 ? 0 : 1;
                break;
              case od:
                1 === Math.abs(Math.floor(t.y) % 2)
                  ? (t.y = Math.ceil(t.y) - t.y)
                  : (t.y = t.y - Math.floor(t.y));
            }
          return this.flipY && (t.y = 1 - t.y), t;
        }
        set needsUpdate(t) {
          !0 === t && (this.version++, (this.source.needsUpdate = !0));
        }
        get encoding() {
          return (
            ap(
              "THREE.Texture: Property .encoding has been replaced by .colorSpace."
            ),
            this.colorSpace === Pd ? Ad : 3e3
          );
        }
        set encoding(t) {
          ap(
            "THREE.Texture: Property .encoding has been replaced by .colorSpace."
          ),
            (this.colorSpace = t === Ad ? Pd : Cd);
        }
      }
      (bp.DEFAULT_IMAGE = null),
        (bp.DEFAULT_MAPPING = 300),
        (bp.DEFAULT_ANISOTROPY = 1);
      class Sp {
        constructor(t = 0, e = 0, n = 0, i = 1) {
          (Sp.prototype.isVector4 = !0),
            (this.x = t),
            (this.y = e),
            (this.z = n),
            (this.w = i);
        }
        get width() {
          return this.z;
        }
        set width(t) {
          this.z = t;
        }
        get height() {
          return this.w;
        }
        set height(t) {
          this.w = t;
        }
        set(t, e, n, i) {
          return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
        }
        setScalar(t) {
          return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
        }
        setX(t) {
          return (this.x = t), this;
        }
        setY(t) {
          return (this.y = t), this;
        }
        setZ(t) {
          return (this.z = t), this;
        }
        setW(t) {
          return (this.w = t), this;
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            case 2:
              this.z = e;
              break;
            case 3:
              this.w = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(t) {
          return (
            (this.x = t.x),
            (this.y = t.y),
            (this.z = t.z),
            (this.w = void 0 !== t.w ? t.w : 1),
            this
          );
        }
        add(t) {
          return (
            (this.x += t.x),
            (this.y += t.y),
            (this.z += t.z),
            (this.w += t.w),
            this
          );
        }
        addScalar(t) {
          return (
            (this.x += t), (this.y += t), (this.z += t), (this.w += t), this
          );
        }
        addVectors(t, e) {
          return (
            (this.x = t.x + e.x),
            (this.y = t.y + e.y),
            (this.z = t.z + e.z),
            (this.w = t.w + e.w),
            this
          );
        }
        addScaledVector(t, e) {
          return (
            (this.x += t.x * e),
            (this.y += t.y * e),
            (this.z += t.z * e),
            (this.w += t.w * e),
            this
          );
        }
        sub(t) {
          return (
            (this.x -= t.x),
            (this.y -= t.y),
            (this.z -= t.z),
            (this.w -= t.w),
            this
          );
        }
        subScalar(t) {
          return (
            (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this
          );
        }
        subVectors(t, e) {
          return (
            (this.x = t.x - e.x),
            (this.y = t.y - e.y),
            (this.z = t.z - e.z),
            (this.w = t.w - e.w),
            this
          );
        }
        multiply(t) {
          return (
            (this.x *= t.x),
            (this.y *= t.y),
            (this.z *= t.z),
            (this.w *= t.w),
            this
          );
        }
        multiplyScalar(t) {
          return (
            (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
          );
        }
        applyMatrix4(t) {
          const e = this.x,
            n = this.y,
            i = this.z,
            r = this.w,
            s = t.elements;
          return (
            (this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r),
            (this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r),
            (this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r),
            (this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r),
            this
          );
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        setAxisAngleFromQuaternion(t) {
          this.w = 2 * Math.acos(t.w);
          const e = Math.sqrt(1 - t.w * t.w);
          return (
            e < 1e-4
              ? ((this.x = 1), (this.y = 0), (this.z = 0))
              : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
            this
          );
        }
        setAxisAngleFromRotationMatrix(t) {
          let e, n, i, r;
          const s = 0.01,
            o = 0.1,
            a = t.elements,
            l = a[0],
            c = a[4],
            u = a[8],
            h = a[1],
            d = a[5],
            p = a[9],
            f = a[2],
            m = a[6],
            g = a[10];
          if (
            Math.abs(c - h) < s &&
            Math.abs(u - f) < s &&
            Math.abs(p - m) < s
          ) {
            if (
              Math.abs(c + h) < o &&
              Math.abs(u + f) < o &&
              Math.abs(p + m) < o &&
              Math.abs(l + d + g - 3) < o
            )
              return this.set(1, 0, 0, 0), this;
            e = Math.PI;
            const t = (l + 1) / 2,
              a = (d + 1) / 2,
              v = (g + 1) / 2,
              _ = (c + h) / 4,
              y = (u + f) / 4,
              x = (p + m) / 4;
            return (
              t > a && t > v
                ? t < s
                  ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                  : ((n = Math.sqrt(t)), (i = _ / n), (r = y / n))
                : a > v
                ? a < s
                  ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                  : ((i = Math.sqrt(a)), (n = _ / i), (r = x / i))
                : v < s
                ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                : ((r = Math.sqrt(v)), (n = y / r), (i = x / r)),
              this.set(n, i, r, e),
              this
            );
          }
          let v = Math.sqrt(
            (m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c)
          );
          return (
            Math.abs(v) < 0.001 && (v = 1),
            (this.x = (m - p) / v),
            (this.y = (u - f) / v),
            (this.z = (h - c) / v),
            (this.w = Math.acos((l + d + g - 1) / 2)),
            this
          );
        }
        min(t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            (this.z = Math.min(this.z, t.z)),
            (this.w = Math.min(this.w, t.w)),
            this
          );
        }
        max(t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            (this.z = Math.max(this.z, t.z)),
            (this.w = Math.max(this.w, t.w)),
            this
          );
        }
        clamp(t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            (this.z = Math.max(t.z, Math.min(e.z, this.z))),
            (this.w = Math.max(t.w, Math.min(e.w, this.w))),
            this
          );
        }
        clampScalar(t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            (this.z = Math.max(t, Math.min(e, this.z))),
            (this.w = Math.max(t, Math.min(e, this.w))),
            this
          );
        }
        clampLength(t, e) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(t, Math.min(e, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = Math.trunc(this.x)),
            (this.y = Math.trunc(this.y)),
            (this.z = Math.trunc(this.z)),
            (this.w = Math.trunc(this.w)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
          );
        }
        dot(t) {
          return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
        }
        lengthSq() {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          );
        }
        length() {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
          );
        }
        manhattanLength() {
          return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
          );
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
          return (
            (this.x += (t.x - this.x) * e),
            (this.y += (t.y - this.y) * e),
            (this.z += (t.z - this.z) * e),
            (this.w += (t.w - this.w) * e),
            this
          );
        }
        lerpVectors(t, e, n) {
          return (
            (this.x = t.x + (e.x - t.x) * n),
            (this.y = t.y + (e.y - t.y) * n),
            (this.z = t.z + (e.z - t.z) * n),
            (this.w = t.w + (e.w - t.w) * n),
            this
          );
        }
        equals(t) {
          return (
            t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
          );
        }
        fromArray(t, e = 0) {
          return (
            (this.x = t[e]),
            (this.y = t[e + 1]),
            (this.z = t[e + 2]),
            (this.w = t[e + 3]),
            this
          );
        }
        toArray(t = [], e = 0) {
          return (
            (t[e] = this.x),
            (t[e + 1] = this.y),
            (t[e + 2] = this.z),
            (t[e + 3] = this.w),
            t
          );
        }
        fromBufferAttribute(t, e) {
          return (
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            (this.z = t.getZ(e)),
            (this.w = t.getW(e)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            (this.w = Math.random()),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z, yield this.w;
        }
      }
      class Ep extends Gd {
        constructor(t = 1, e = 1, n = {}) {
          super(),
            (this.isRenderTarget = !0),
            (this.width = t),
            (this.height = e),
            (this.depth = 1),
            (this.scissor = new Sp(0, 0, t, e)),
            (this.scissorTest = !1),
            (this.viewport = new Sp(0, 0, t, e));
          const i = {
            width: t,
            height: e,
            depth: 1,
          };
          void 0 !== n.encoding &&
            (ap(
              "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."
            ),
            (n.colorSpace = n.encoding === Ad ? Pd : Cd)),
            (n = Object.assign(
              {
                generateMipmaps: !1,
                internalFormat: null,
                minFilter: cd,
                depthBuffer: !0,
                stencilBuffer: !1,
                depthTexture: null,
                samples: 0,
              },
              n
            )),
            (this.texture = new bp(
              i,
              n.mapping,
              n.wrapS,
              n.wrapT,
              n.magFilter,
              n.minFilter,
              n.format,
              n.type,
              n.anisotropy,
              n.colorSpace
            )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.flipY = !1),
            (this.texture.generateMipmaps = n.generateMipmaps),
            (this.texture.internalFormat = n.internalFormat),
            (this.depthBuffer = n.depthBuffer),
            (this.stencilBuffer = n.stencilBuffer),
            (this.depthTexture = n.depthTexture),
            (this.samples = n.samples);
        }
        setSize(t, e, n = 1) {
          (this.width === t && this.height === e && this.depth === n) ||
            ((this.width = t),
            (this.height = e),
            (this.depth = n),
            (this.texture.image.width = t),
            (this.texture.image.height = e),
            (this.texture.image.depth = n),
            this.dispose()),
            this.viewport.set(0, 0, t, e),
            this.scissor.set(0, 0, t, e);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          (this.width = t.width),
            (this.height = t.height),
            (this.depth = t.depth),
            this.scissor.copy(t.scissor),
            (this.scissorTest = t.scissorTest),
            this.viewport.copy(t.viewport),
            (this.texture = t.texture.clone()),
            (this.texture.isRenderTargetTexture = !0);
          const e = Object.assign({}, t.texture.image);
          return (
            (this.texture.source = new _p(e)),
            (this.depthBuffer = t.depthBuffer),
            (this.stencilBuffer = t.stencilBuffer),
            null !== t.depthTexture &&
              (this.depthTexture = t.depthTexture.clone()),
            (this.samples = t.samples),
            this
          );
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose",
          });
        }
      }
      class Tp extends Ep {
        constructor(t = 1, e = 1, n = {}) {
          super(t, e, n), (this.isWebGLRenderTarget = !0);
        }
      }
      class Mp extends bp {
        constructor(t = null, e = 1, n = 1, i = 1) {
          super(null),
            (this.isDataArrayTexture = !0),
            (this.image = {
              data: t,
              width: e,
              height: n,
              depth: i,
            }),
            (this.magFilter = ad),
            (this.minFilter = ad),
            (this.wrapR = sd),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      class wp extends bp {
        constructor(t = null, e = 1, n = 1, i = 1) {
          super(null),
            (this.isData3DTexture = !0),
            (this.image = {
              data: t,
              width: e,
              height: n,
              depth: i,
            }),
            (this.magFilter = ad),
            (this.minFilter = ad),
            (this.wrapR = sd),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      class Dp {
        constructor(t = 0, e = 0, n = 0, i = 1) {
          (this.isQuaternion = !0),
            (this._x = t),
            (this._y = e),
            (this._z = n),
            (this._w = i);
        }
        static slerpFlat(t, e, n, i, r, s, o) {
          let a = n[i + 0],
            l = n[i + 1],
            c = n[i + 2],
            u = n[i + 3];
          const h = r[s + 0],
            d = r[s + 1],
            p = r[s + 2],
            f = r[s + 3];
          if (0 === o)
            return (
              (t[e + 0] = a),
              (t[e + 1] = l),
              (t[e + 2] = c),
              void (t[e + 3] = u)
            );
          if (1 === o)
            return (
              (t[e + 0] = h),
              (t[e + 1] = d),
              (t[e + 2] = p),
              void (t[e + 3] = f)
            );
          if (u !== f || a !== h || l !== d || c !== p) {
            let t = 1 - o;
            const e = a * h + l * d + c * p + u * f,
              n = e >= 0 ? 1 : -1,
              i = 1 - e * e;
            if (i > Number.EPSILON) {
              const r = Math.sqrt(i),
                s = Math.atan2(r, e * n);
              (t = Math.sin(t * s) / r), (o = Math.sin(o * s) / r);
            }
            const r = o * n;
            if (
              ((a = a * t + h * r),
              (l = l * t + d * r),
              (c = c * t + p * r),
              (u = u * t + f * r),
              t === 1 - o)
            ) {
              const t = 1 / Math.sqrt(a * a + l * l + c * c + u * u);
              (a *= t), (l *= t), (c *= t), (u *= t);
            }
          }
          (t[e] = a), (t[e + 1] = l), (t[e + 2] = c), (t[e + 3] = u);
        }
        static multiplyQuaternionsFlat(t, e, n, i, r, s) {
          const o = n[i],
            a = n[i + 1],
            l = n[i + 2],
            c = n[i + 3],
            u = r[s],
            h = r[s + 1],
            d = r[s + 2],
            p = r[s + 3];
          return (
            (t[e] = o * p + c * u + a * d - l * h),
            (t[e + 1] = a * p + c * h + l * u - o * d),
            (t[e + 2] = l * p + c * d + o * h - a * u),
            (t[e + 3] = c * p - o * u - a * h - l * d),
            t
          );
        }
        get x() {
          return this._x;
        }
        set x(t) {
          (this._x = t), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(t) {
          (this._y = t), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(t) {
          (this._z = t), this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(t) {
          (this._w = t), this._onChangeCallback();
        }
        set(t, e, n, i) {
          return (
            (this._x = t),
            (this._y = e),
            (this._z = n),
            (this._w = i),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(t) {
          return (
            (this._x = t.x),
            (this._y = t.y),
            (this._z = t.z),
            (this._w = t.w),
            this._onChangeCallback(),
            this
          );
        }
        setFromEuler(t, e) {
          const n = t._x,
            i = t._y,
            r = t._z,
            s = t._order,
            o = Math.cos,
            a = Math.sin,
            l = o(n / 2),
            c = o(i / 2),
            u = o(r / 2),
            h = a(n / 2),
            d = a(i / 2),
            p = a(r / 2);
          switch (s) {
            case "XYZ":
              (this._x = h * c * u + l * d * p),
                (this._y = l * d * u - h * c * p),
                (this._z = l * c * p + h * d * u),
                (this._w = l * c * u - h * d * p);
              break;
            case "YXZ":
              (this._x = h * c * u + l * d * p),
                (this._y = l * d * u - h * c * p),
                (this._z = l * c * p - h * d * u),
                (this._w = l * c * u + h * d * p);
              break;
            case "ZXY":
              (this._x = h * c * u - l * d * p),
                (this._y = l * d * u + h * c * p),
                (this._z = l * c * p + h * d * u),
                (this._w = l * c * u - h * d * p);
              break;
            case "ZYX":
              (this._x = h * c * u - l * d * p),
                (this._y = l * d * u + h * c * p),
                (this._z = l * c * p - h * d * u),
                (this._w = l * c * u + h * d * p);
              break;
            case "YZX":
              (this._x = h * c * u + l * d * p),
                (this._y = l * d * u + h * c * p),
                (this._z = l * c * p - h * d * u),
                (this._w = l * c * u - h * d * p);
              break;
            case "XZY":
              (this._x = h * c * u - l * d * p),
                (this._y = l * d * u - h * c * p),
                (this._z = l * c * p + h * d * u),
                (this._w = l * c * u + h * d * p);
              break;
            default:
              console.warn(
                "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                  s
              );
          }
          return !1 !== e && this._onChangeCallback(), this;
        }
        setFromAxisAngle(t, e) {
          const n = e / 2,
            i = Math.sin(n);
          return (
            (this._x = t.x * i),
            (this._y = t.y * i),
            (this._z = t.z * i),
            (this._w = Math.cos(n)),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(t) {
          const e = t.elements,
            n = e[0],
            i = e[4],
            r = e[8],
            s = e[1],
            o = e[5],
            a = e[9],
            l = e[2],
            c = e[6],
            u = e[10],
            h = n + o + u;
          if (h > 0) {
            const t = 0.5 / Math.sqrt(h + 1);
            (this._w = 0.25 / t),
              (this._x = (c - a) * t),
              (this._y = (r - l) * t),
              (this._z = (s - i) * t);
          } else if (n > o && n > u) {
            const t = 2 * Math.sqrt(1 + n - o - u);
            (this._w = (c - a) / t),
              (this._x = 0.25 * t),
              (this._y = (i + s) / t),
              (this._z = (r + l) / t);
          } else if (o > u) {
            const t = 2 * Math.sqrt(1 + o - n - u);
            (this._w = (r - l) / t),
              (this._x = (i + s) / t),
              (this._y = 0.25 * t),
              (this._z = (a + c) / t);
          } else {
            const t = 2 * Math.sqrt(1 + u - n - o);
            (this._w = (s - i) / t),
              (this._x = (r + l) / t),
              (this._y = (a + c) / t),
              (this._z = 0.25 * t);
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(t, e) {
          let n = t.dot(e) + 1;
          return (
            n < Number.EPSILON
              ? ((n = 0),
                Math.abs(t.x) > Math.abs(t.z)
                  ? ((this._x = -t.y),
                    (this._y = t.x),
                    (this._z = 0),
                    (this._w = n))
                  : ((this._x = 0),
                    (this._y = -t.z),
                    (this._z = t.y),
                    (this._w = n)))
              : ((this._x = t.y * e.z - t.z * e.y),
                (this._y = t.z * e.x - t.x * e.z),
                (this._z = t.x * e.y - t.y * e.x),
                (this._w = n)),
            this.normalize()
          );
        }
        angleTo(t) {
          return 2 * Math.acos(Math.abs(Yd(this.dot(t), -1, 1)));
        }
        rotateTowards(t, e) {
          const n = this.angleTo(t);
          if (0 === n) return this;
          const i = Math.min(1, e / n);
          return this.slerp(t, i), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this._onChangeCallback(),
            this
          );
        }
        dot(t) {
          return (
            this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
          );
        }
        lengthSq() {
          return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
          );
        }
        length() {
          return Math.sqrt(
            this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
          );
        }
        normalize() {
          let t = this.length();
          return (
            0 === t
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((t = 1 / t),
                (this._x = this._x * t),
                (this._y = this._y * t),
                (this._z = this._z * t),
                (this._w = this._w * t)),
            this._onChangeCallback(),
            this
          );
        }
        multiply(t) {
          return this.multiplyQuaternions(this, t);
        }
        premultiply(t) {
          return this.multiplyQuaternions(t, this);
        }
        multiplyQuaternions(t, e) {
          const n = t._x,
            i = t._y,
            r = t._z,
            s = t._w,
            o = e._x,
            a = e._y,
            l = e._z,
            c = e._w;
          return (
            (this._x = n * c + s * o + i * l - r * a),
            (this._y = i * c + s * a + r * o - n * l),
            (this._z = r * c + s * l + n * a - i * o),
            (this._w = s * c - n * o - i * a - r * l),
            this._onChangeCallback(),
            this
          );
        }
        slerp(t, e) {
          if (0 === e) return this;
          if (1 === e) return this.copy(t);
          const n = this._x,
            i = this._y,
            r = this._z,
            s = this._w;
          let o = s * t._w + n * t._x + i * t._y + r * t._z;
          if (
            (o < 0
              ? ((this._w = -t._w),
                (this._x = -t._x),
                (this._y = -t._y),
                (this._z = -t._z),
                (o = -o))
              : this.copy(t),
            o >= 1)
          )
            return (
              (this._w = s), (this._x = n), (this._y = i), (this._z = r), this
            );
          const a = 1 - o * o;
          if (a <= Number.EPSILON) {
            const t = 1 - e;
            return (
              (this._w = t * s + e * this._w),
              (this._x = t * n + e * this._x),
              (this._y = t * i + e * this._y),
              (this._z = t * r + e * this._z),
              this.normalize(),
              this._onChangeCallback(),
              this
            );
          }
          const l = Math.sqrt(a),
            c = Math.atan2(l, o),
            u = Math.sin((1 - e) * c) / l,
            h = Math.sin(e * c) / l;
          return (
            (this._w = s * u + this._w * h),
            (this._x = n * u + this._x * h),
            (this._y = i * u + this._y * h),
            (this._z = r * u + this._z * h),
            this._onChangeCallback(),
            this
          );
        }
        slerpQuaternions(t, e, n) {
          return this.copy(t).slerp(e, n);
        }
        random() {
          const t = Math.random(),
            e = Math.sqrt(1 - t),
            n = Math.sqrt(t),
            i = 2 * Math.PI * Math.random(),
            r = 2 * Math.PI * Math.random();
          return this.set(
            e * Math.cos(i),
            n * Math.sin(r),
            n * Math.cos(r),
            e * Math.sin(i)
          );
        }
        equals(t) {
          return (
            t._x === this._x &&
            t._y === this._y &&
            t._z === this._z &&
            t._w === this._w
          );
        }
        fromArray(t, e = 0) {
          return (
            (this._x = t[e]),
            (this._y = t[e + 1]),
            (this._z = t[e + 2]),
            (this._w = t[e + 3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(t = [], e = 0) {
          return (
            (t[e] = this._x),
            (t[e + 1] = this._y),
            (t[e + 2] = this._z),
            (t[e + 3] = this._w),
            t
          );
        }
        fromBufferAttribute(t, e) {
          return (
            (this._x = t.getX(e)),
            (this._y = t.getY(e)),
            (this._z = t.getZ(e)),
            (this._w = t.getW(e)),
            this
          );
        }
        toJSON() {
          return this.toArray();
        }
        _onChange(t) {
          return (this._onChangeCallback = t), this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._w;
        }
      }
      class Ap {
        constructor(t = 0, e = 0, n = 0) {
          (Ap.prototype.isVector3 = !0),
            (this.x = t),
            (this.y = e),
            (this.z = n);
        }
        set(t, e, n) {
          return (
            void 0 === n && (n = this.z),
            (this.x = t),
            (this.y = e),
            (this.z = n),
            this
          );
        }
        setScalar(t) {
          return (this.x = t), (this.y = t), (this.z = t), this;
        }
        setX(t) {
          return (this.x = t), this;
        }
        setY(t) {
          return (this.y = t), this;
        }
        setZ(t) {
          return (this.z = t), this;
        }
        setComponent(t, e) {
          switch (t) {
            case 0:
              this.x = e;
              break;
            case 1:
              this.y = e;
              break;
            case 2:
              this.z = e;
              break;
            default:
              throw new Error("index is out of range: " + t);
          }
          return this;
        }
        getComponent(t) {
          switch (t) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + t);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(t) {
          return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
        }
        add(t) {
          return (this.x += t.x), (this.y += t.y), (this.z += t.z), this;
        }
        addScalar(t) {
          return (this.x += t), (this.y += t), (this.z += t), this;
        }
        addVectors(t, e) {
          return (
            (this.x = t.x + e.x),
            (this.y = t.y + e.y),
            (this.z = t.z + e.z),
            this
          );
        }
        addScaledVector(t, e) {
          return (
            (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
          );
        }
        sub(t) {
          return (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this;
        }
        subScalar(t) {
          return (this.x -= t), (this.y -= t), (this.z -= t), this;
        }
        subVectors(t, e) {
          return (
            (this.x = t.x - e.x),
            (this.y = t.y - e.y),
            (this.z = t.z - e.z),
            this
          );
        }
        multiply(t) {
          return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this;
        }
        multiplyScalar(t) {
          return (this.x *= t), (this.y *= t), (this.z *= t), this;
        }
        multiplyVectors(t, e) {
          return (
            (this.x = t.x * e.x),
            (this.y = t.y * e.y),
            (this.z = t.z * e.z),
            this
          );
        }
        applyEuler(t) {
          return this.applyQuaternion(Pp.setFromEuler(t));
        }
        applyAxisAngle(t, e) {
          return this.applyQuaternion(Pp.setFromAxisAngle(t, e));
        }
        applyMatrix3(t) {
          const e = this.x,
            n = this.y,
            i = this.z,
            r = t.elements;
          return (
            (this.x = r[0] * e + r[3] * n + r[6] * i),
            (this.y = r[1] * e + r[4] * n + r[7] * i),
            (this.z = r[2] * e + r[5] * n + r[8] * i),
            this
          );
        }
        applyNormalMatrix(t) {
          return this.applyMatrix3(t).normalize();
        }
        applyMatrix4(t) {
          const e = this.x,
            n = this.y,
            i = this.z,
            r = t.elements,
            s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
          return (
            (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s),
            (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s),
            (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s),
            this
          );
        }
        applyQuaternion(t) {
          const e = this.x,
            n = this.y,
            i = this.z,
            r = t.x,
            s = t.y,
            o = t.z,
            a = t.w,
            l = a * e + s * i - o * n,
            c = a * n + o * e - r * i,
            u = a * i + r * n - s * e,
            h = -r * e - s * n - o * i;
          return (
            (this.x = l * a + h * -r + c * -o - u * -s),
            (this.y = c * a + h * -s + u * -r - l * -o),
            (this.z = u * a + h * -o + l * -s - c * -r),
            this
          );
        }
        project(t) {
          return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
            t.projectionMatrix
          );
        }
        unproject(t) {
          return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
            t.matrixWorld
          );
        }
        transformDirection(t) {
          const e = this.x,
            n = this.y,
            i = this.z,
            r = t.elements;
          return (
            (this.x = r[0] * e + r[4] * n + r[8] * i),
            (this.y = r[1] * e + r[5] * n + r[9] * i),
            (this.z = r[2] * e + r[6] * n + r[10] * i),
            this.normalize()
          );
        }
        divide(t) {
          return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
        }
        divideScalar(t) {
          return this.multiplyScalar(1 / t);
        }
        min(t) {
          return (
            (this.x = Math.min(this.x, t.x)),
            (this.y = Math.min(this.y, t.y)),
            (this.z = Math.min(this.z, t.z)),
            this
          );
        }
        max(t) {
          return (
            (this.x = Math.max(this.x, t.x)),
            (this.y = Math.max(this.y, t.y)),
            (this.z = Math.max(this.z, t.z)),
            this
          );
        }
        clamp(t, e) {
          return (
            (this.x = Math.max(t.x, Math.min(e.x, this.x))),
            (this.y = Math.max(t.y, Math.min(e.y, this.y))),
            (this.z = Math.max(t.z, Math.min(e.z, this.z))),
            this
          );
        }
        clampScalar(t, e) {
          return (
            (this.x = Math.max(t, Math.min(e, this.x))),
            (this.y = Math.max(t, Math.min(e, this.y))),
            (this.z = Math.max(t, Math.min(e, this.z))),
            this
          );
        }
        clampLength(t, e) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(t, Math.min(e, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = Math.trunc(this.x)),
            (this.y = Math.trunc(this.y)),
            (this.z = Math.trunc(this.z)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
          );
        }
        dot(t) {
          return this.x * t.x + this.y * t.y + this.z * t.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(t) {
          return this.normalize().multiplyScalar(t);
        }
        lerp(t, e) {
          return (
            (this.x += (t.x - this.x) * e),
            (this.y += (t.y - this.y) * e),
            (this.z += (t.z - this.z) * e),
            this
          );
        }
        lerpVectors(t, e, n) {
          return (
            (this.x = t.x + (e.x - t.x) * n),
            (this.y = t.y + (e.y - t.y) * n),
            (this.z = t.z + (e.z - t.z) * n),
            this
          );
        }
        cross(t) {
          return this.crossVectors(this, t);
        }
        crossVectors(t, e) {
          const n = t.x,
            i = t.y,
            r = t.z,
            s = e.x,
            o = e.y,
            a = e.z;
          return (
            (this.x = i * a - r * o),
            (this.y = r * s - n * a),
            (this.z = n * o - i * s),
            this
          );
        }
        projectOnVector(t) {
          const e = t.lengthSq();
          if (0 === e) return this.set(0, 0, 0);
          const n = t.dot(this) / e;
          return this.copy(t).multiplyScalar(n);
        }
        projectOnPlane(t) {
          return Cp.copy(this).projectOnVector(t), this.sub(Cp);
        }
        reflect(t) {
          return this.sub(Cp.copy(t).multiplyScalar(2 * this.dot(t)));
        }
        angleTo(t) {
          const e = Math.sqrt(this.lengthSq() * t.lengthSq());
          if (0 === e) return Math.PI / 2;
          const n = this.dot(t) / e;
          return Math.acos(Yd(n, -1, 1));
        }
        distanceTo(t) {
          return Math.sqrt(this.distanceToSquared(t));
        }
        distanceToSquared(t) {
          const e = this.x - t.x,
            n = this.y - t.y,
            i = this.z - t.z;
          return e * e + n * n + i * i;
        }
        manhattanDistanceTo(t) {
          return (
            Math.abs(this.x - t.x) +
            Math.abs(this.y - t.y) +
            Math.abs(this.z - t.z)
          );
        }
        setFromSpherical(t) {
          return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
        }
        setFromSphericalCoords(t, e, n) {
          const i = Math.sin(e) * t;
          return (
            (this.x = i * Math.sin(n)),
            (this.y = Math.cos(e) * t),
            (this.z = i * Math.cos(n)),
            this
          );
        }
        setFromCylindrical(t) {
          return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
        }
        setFromCylindricalCoords(t, e, n) {
          return (
            (this.x = t * Math.sin(e)),
            (this.y = n),
            (this.z = t * Math.cos(e)),
            this
          );
        }
        setFromMatrixPosition(t) {
          const e = t.elements;
          return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
        }
        setFromMatrixScale(t) {
          const e = this.setFromMatrixColumn(t, 0).length(),
            n = this.setFromMatrixColumn(t, 1).length(),
            i = this.setFromMatrixColumn(t, 2).length();
          return (this.x = e), (this.y = n), (this.z = i), this;
        }
        setFromMatrixColumn(t, e) {
          return this.fromArray(t.elements, 4 * e);
        }
        setFromMatrix3Column(t, e) {
          return this.fromArray(t.elements, 3 * e);
        }
        setFromEuler(t) {
          return (this.x = t._x), (this.y = t._y), (this.z = t._z), this;
        }
        setFromColor(t) {
          return (this.x = t.r), (this.y = t.g), (this.z = t.b), this;
        }
        equals(t) {
          return t.x === this.x && t.y === this.y && t.z === this.z;
        }
        fromArray(t, e = 0) {
          return (
            (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this
          );
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
        }
        fromBufferAttribute(t, e) {
          return (
            (this.x = t.getX(e)),
            (this.y = t.getY(e)),
            (this.z = t.getZ(e)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            this
          );
        }
        randomDirection() {
          const t = 2 * (Math.random() - 0.5),
            e = Math.random() * Math.PI * 2,
            n = Math.sqrt(1 - t ** 2);
          return (
            (this.x = n * Math.cos(e)),
            (this.y = n * Math.sin(e)),
            (this.z = t),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z;
        }
      }
      const Cp = new Ap(),
        Pp = new Dp();
      class Rp {
        constructor(
          t = new Ap(1 / 0, 1 / 0, 1 / 0),
          e = new Ap(-1 / 0, -1 / 0, -1 / 0)
        ) {
          (this.isBox3 = !0), (this.min = t), (this.max = e);
        }
        set(t, e) {
          return this.min.copy(t), this.max.copy(e), this;
        }
        setFromArray(t) {
          this.makeEmpty();
          for (let e = 0, n = t.length; e < n; e += 3)
            this.expandByPoint(Op.fromArray(t, e));
          return this;
        }
        setFromBufferAttribute(t) {
          this.makeEmpty();
          for (let e = 0, n = t.count; e < n; e++)
            this.expandByPoint(Op.fromBufferAttribute(t, e));
          return this;
        }
        setFromPoints(t) {
          this.makeEmpty();
          for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
          return this;
        }
        setFromCenterAndSize(t, e) {
          const n = Op.copy(e).multiplyScalar(0.5);
          return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
        }
        setFromObject(t, e = !1) {
          return this.makeEmpty(), this.expandByObject(t, e);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.min.copy(t.min), this.max.copy(t.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = this.min.z = 1 / 0),
            (this.max.x = this.max.y = this.max.z = -1 / 0),
            this
          );
        }
        isEmpty() {
          return (
            this.max.x < this.min.x ||
            this.max.y < this.min.y ||
            this.max.z < this.min.z
          );
        }
        getCenter(t) {
          return this.isEmpty()
            ? t.set(0, 0, 0)
            : t.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(t) {
          return this.isEmpty()
            ? t.set(0, 0, 0)
            : t.subVectors(this.max, this.min);
        }
        expandByPoint(t) {
          return this.min.min(t), this.max.max(t), this;
        }
        expandByVector(t) {
          return this.min.sub(t), this.max.add(t), this;
        }
        expandByScalar(t) {
          return this.min.addScalar(-t), this.max.addScalar(t), this;
        }
        expandByObject(t, e = !1) {
          if ((t.updateWorldMatrix(!1, !1), void 0 !== t.boundingBox))
            null === t.boundingBox && t.computeBoundingBox(),
              Ip.copy(t.boundingBox),
              Ip.applyMatrix4(t.matrixWorld),
              this.union(Ip);
          else {
            const n = t.geometry;
            if (void 0 !== n)
              if (
                e &&
                void 0 !== n.attributes &&
                void 0 !== n.attributes.position
              ) {
                const e = n.attributes.position;
                for (let n = 0, i = e.count; n < i; n++)
                  Op.fromBufferAttribute(e, n).applyMatrix4(t.matrixWorld),
                    this.expandByPoint(Op);
              } else
                null === n.boundingBox && n.computeBoundingBox(),
                  Ip.copy(n.boundingBox),
                  Ip.applyMatrix4(t.matrixWorld),
                  this.union(Ip);
          }
          const n = t.children;
          for (let t = 0, i = n.length; t < i; t++)
            this.expandByObject(n[t], e);
          return this;
        }
        containsPoint(t) {
          return !(
            t.x < this.min.x ||
            t.x > this.max.x ||
            t.y < this.min.y ||
            t.y > this.max.y ||
            t.z < this.min.z ||
            t.z > this.max.z
          );
        }
        containsBox(t) {
          return (
            this.min.x <= t.min.x &&
            t.max.x <= this.max.x &&
            this.min.y <= t.min.y &&
            t.max.y <= this.max.y &&
            this.min.z <= t.min.z &&
            t.max.z <= this.max.z
          );
        }
        getParameter(t, e) {
          return e.set(
            (t.x - this.min.x) / (this.max.x - this.min.x),
            (t.y - this.min.y) / (this.max.y - this.min.y),
            (t.z - this.min.z) / (this.max.z - this.min.z)
          );
        }
        intersectsBox(t) {
          return !(
            t.max.x < this.min.x ||
            t.min.x > this.max.x ||
            t.max.y < this.min.y ||
            t.min.y > this.max.y ||
            t.max.z < this.min.z ||
            t.min.z > this.max.z
          );
        }
        intersectsSphere(t) {
          return (
            this.clampPoint(t.center, Op),
            Op.distanceToSquared(t.center) <= t.radius * t.radius
          );
        }
        intersectsPlane(t) {
          let e, n;
          return (
            t.normal.x > 0
              ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
              : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
            t.normal.y > 0
              ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
              : ((e += t.normal.y * this.max.y),
                (n += t.normal.y * this.min.y)),
            t.normal.z > 0
              ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
              : ((e += t.normal.z * this.max.z),
                (n += t.normal.z * this.min.z)),
            e <= -t.constant && n >= -t.constant
          );
        }
        intersectsTriangle(t) {
          if (this.isEmpty()) return !1;
          this.getCenter(Hp),
            Vp.subVectors(this.max, Hp),
            Fp.subVectors(t.a, Hp),
            Np.subVectors(t.b, Hp),
            Up.subVectors(t.c, Hp),
            kp.subVectors(Np, Fp),
            zp.subVectors(Up, Np),
            Bp.subVectors(Fp, Up);
          let e = [
            0,
            -kp.z,
            kp.y,
            0,
            -zp.z,
            zp.y,
            0,
            -Bp.z,
            Bp.y,
            kp.z,
            0,
            -kp.x,
            zp.z,
            0,
            -zp.x,
            Bp.z,
            0,
            -Bp.x,
            -kp.y,
            kp.x,
            0,
            -zp.y,
            zp.x,
            0,
            -Bp.y,
            Bp.x,
            0,
          ];
          return (
            !!jp(e, Fp, Np, Up, Vp) &&
            ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            !!jp(e, Fp, Np, Up, Vp) &&
              (Gp.crossVectors(kp, zp),
              (e = [Gp.x, Gp.y, Gp.z]),
              jp(e, Fp, Np, Up, Vp)))
          );
        }
        clampPoint(t, e) {
          return e.copy(t).clamp(this.min, this.max);
        }
        distanceToPoint(t) {
          return this.clampPoint(t, Op).distanceTo(t);
        }
        getBoundingSphere(t) {
          return (
            this.isEmpty()
              ? t.makeEmpty()
              : (this.getCenter(t.center),
                (t.radius = 0.5 * this.getSize(Op).length())),
            t
          );
        }
        intersect(t) {
          return (
            this.min.max(t.min),
            this.max.min(t.max),
            this.isEmpty() && this.makeEmpty(),
            this
          );
        }
        union(t) {
          return this.min.min(t.min), this.max.max(t.max), this;
        }
        applyMatrix4(t) {
          return (
            this.isEmpty() ||
              (Lp[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
              Lp[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
              Lp[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
              Lp[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
              Lp[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
              Lp[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
              Lp[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
              Lp[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
              this.setFromPoints(Lp)),
            this
          );
        }
        translate(t) {
          return this.min.add(t), this.max.add(t), this;
        }
        equals(t) {
          return t.min.equals(this.min) && t.max.equals(this.max);
        }
      }
      const Lp = [
          new Ap(),
          new Ap(),
          new Ap(),
          new Ap(),
          new Ap(),
          new Ap(),
          new Ap(),
          new Ap(),
        ],
        Op = new Ap(),
        Ip = new Rp(),
        Fp = new Ap(),
        Np = new Ap(),
        Up = new Ap(),
        kp = new Ap(),
        zp = new Ap(),
        Bp = new Ap(),
        Hp = new Ap(),
        Vp = new Ap(),
        Gp = new Ap(),
        Wp = new Ap();
      function jp(t, e, n, i, r) {
        for (let s = 0, o = t.length - 3; s <= o; s += 3) {
          Wp.fromArray(t, s);
          const o =
              r.x * Math.abs(Wp.x) +
              r.y * Math.abs(Wp.y) +
              r.z * Math.abs(Wp.z),
            a = e.dot(Wp),
            l = n.dot(Wp),
            c = i.dot(Wp);
          if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > o) return !1;
        }
        return !0;
      }
      const Xp = new Rp(),
        qp = new Ap(),
        Yp = new Ap();
      class Kp {
        constructor(t = new Ap(), e = -1) {
          (this.center = t), (this.radius = e);
        }
        set(t, e) {
          return this.center.copy(t), (this.radius = e), this;
        }
        setFromPoints(t, e) {
          const n = this.center;
          void 0 !== e ? n.copy(e) : Xp.setFromPoints(t).getCenter(n);
          let i = 0;
          for (let e = 0, r = t.length; e < r; e++)
            i = Math.max(i, n.distanceToSquared(t[e]));
          return (this.radius = Math.sqrt(i)), this;
        }
        copy(t) {
          return this.center.copy(t.center), (this.radius = t.radius), this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), (this.radius = -1), this;
        }
        containsPoint(t) {
          return t.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(t) {
          return t.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(t) {
          const e = this.radius + t.radius;
          return t.center.distanceToSquared(this.center) <= e * e;
        }
        intersectsBox(t) {
          return t.intersectsSphere(this);
        }
        intersectsPlane(t) {
          return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(t, e) {
          const n = this.center.distanceToSquared(t);
          return (
            e.copy(t),
            n > this.radius * this.radius &&
              (e.sub(this.center).normalize(),
              e.multiplyScalar(this.radius).add(this.center)),
            e
          );
        }
        getBoundingBox(t) {
          return this.isEmpty()
            ? (t.makeEmpty(), t)
            : (t.set(this.center, this.center),
              t.expandByScalar(this.radius),
              t);
        }
        applyMatrix4(t) {
          return (
            this.center.applyMatrix4(t),
            (this.radius = this.radius * t.getMaxScaleOnAxis()),
            this
          );
        }
        translate(t) {
          return this.center.add(t), this;
        }
        expandByPoint(t) {
          if (this.isEmpty())
            return this.center.copy(t), (this.radius = 0), this;
          qp.subVectors(t, this.center);
          const e = qp.lengthSq();
          if (e > this.radius * this.radius) {
            const t = Math.sqrt(e),
              n = 0.5 * (t - this.radius);
            this.center.addScaledVector(qp, n / t), (this.radius += n);
          }
          return this;
        }
        union(t) {
          return t.isEmpty()
            ? this
            : this.isEmpty()
            ? (this.copy(t), this)
            : (!0 === this.center.equals(t.center)
                ? (this.radius = Math.max(this.radius, t.radius))
                : (Yp.subVectors(t.center, this.center).setLength(t.radius),
                  this.expandByPoint(qp.copy(t.center).add(Yp)),
                  this.expandByPoint(qp.copy(t.center).sub(Yp))),
              this);
        }
        equals(t) {
          return t.center.equals(this.center) && t.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Zp = new Ap(),
        $p = new Ap(),
        Jp = new Ap(),
        Qp = new Ap(),
        tf = new Ap(),
        ef = new Ap(),
        nf = new Ap();
      class rf {
        constructor(t = new Ap(), e = new Ap(0, 0, -1)) {
          (this.origin = t), (this.direction = e);
        }
        set(t, e) {
          return this.origin.copy(t), this.direction.copy(e), this;
        }
        copy(t) {
          return (
            this.origin.copy(t.origin), this.direction.copy(t.direction), this
          );
        }
        at(t, e) {
          return e.copy(this.origin).addScaledVector(this.direction, t);
        }
        lookAt(t) {
          return this.direction.copy(t).sub(this.origin).normalize(), this;
        }
        recast(t) {
          return this.origin.copy(this.at(t, Zp)), this;
        }
        closestPointToPoint(t, e) {
          e.subVectors(t, this.origin);
          const n = e.dot(this.direction);
          return n < 0
            ? e.copy(this.origin)
            : e.copy(this.origin).addScaledVector(this.direction, n);
        }
        distanceToPoint(t) {
          return Math.sqrt(this.distanceSqToPoint(t));
        }
        distanceSqToPoint(t) {
          const e = Zp.subVectors(t, this.origin).dot(this.direction);
          return e < 0
            ? this.origin.distanceToSquared(t)
            : (Zp.copy(this.origin).addScaledVector(this.direction, e),
              Zp.distanceToSquared(t));
        }
        distanceSqToSegment(t, e, n, i) {
          $p.copy(t).add(e).multiplyScalar(0.5),
            Jp.copy(e).sub(t).normalize(),
            Qp.copy(this.origin).sub($p);
          const r = 0.5 * t.distanceTo(e),
            s = -this.direction.dot(Jp),
            o = Qp.dot(this.direction),
            a = -Qp.dot(Jp),
            l = Qp.lengthSq(),
            c = Math.abs(1 - s * s);
          let u, h, d, p;
          if (c > 0)
            if (((u = s * a - o), (h = s * o - a), (p = r * c), u >= 0))
              if (h >= -p)
                if (h <= p) {
                  const t = 1 / c;
                  (u *= t),
                    (h *= t),
                    (d = u * (u + s * h + 2 * o) + h * (s * u + h + 2 * a) + l);
                } else
                  (h = r),
                    (u = Math.max(0, -(s * h + o))),
                    (d = -u * u + h * (h + 2 * a) + l);
              else
                (h = -r),
                  (u = Math.max(0, -(s * h + o))),
                  (d = -u * u + h * (h + 2 * a) + l);
            else
              h <= -p
                ? ((u = Math.max(0, -(-s * r + o))),
                  (h = u > 0 ? -r : Math.min(Math.max(-r, -a), r)),
                  (d = -u * u + h * (h + 2 * a) + l))
                : h <= p
                ? ((u = 0),
                  (h = Math.min(Math.max(-r, -a), r)),
                  (d = h * (h + 2 * a) + l))
                : ((u = Math.max(0, -(s * r + o))),
                  (h = u > 0 ? r : Math.min(Math.max(-r, -a), r)),
                  (d = -u * u + h * (h + 2 * a) + l));
          else
            (h = s > 0 ? -r : r),
              (u = Math.max(0, -(s * h + o))),
              (d = -u * u + h * (h + 2 * a) + l);
          return (
            n && n.copy(this.origin).addScaledVector(this.direction, u),
            i && i.copy($p).addScaledVector(Jp, h),
            d
          );
        }
        intersectSphere(t, e) {
          Zp.subVectors(t.center, this.origin);
          const n = Zp.dot(this.direction),
            i = Zp.dot(Zp) - n * n,
            r = t.radius * t.radius;
          if (i > r) return null;
          const s = Math.sqrt(r - i),
            o = n - s,
            a = n + s;
          return a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e);
        }
        intersectsSphere(t) {
          return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
        }
        distanceToPlane(t) {
          const e = t.normal.dot(this.direction);
          if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
          const n = -(this.origin.dot(t.normal) + t.constant) / e;
          return n >= 0 ? n : null;
        }
        intersectPlane(t, e) {
          const n = this.distanceToPlane(t);
          return null === n ? null : this.at(n, e);
        }
        intersectsPlane(t) {
          const e = t.distanceToPoint(this.origin);
          return 0 === e || t.normal.dot(this.direction) * e < 0;
        }
        intersectBox(t, e) {
          let n, i, r, s, o, a;
          const l = 1 / this.direction.x,
            c = 1 / this.direction.y,
            u = 1 / this.direction.z,
            h = this.origin;
          return (
            l >= 0
              ? ((n = (t.min.x - h.x) * l), (i = (t.max.x - h.x) * l))
              : ((n = (t.max.x - h.x) * l), (i = (t.min.x - h.x) * l)),
            c >= 0
              ? ((r = (t.min.y - h.y) * c), (s = (t.max.y - h.y) * c))
              : ((r = (t.max.y - h.y) * c), (s = (t.min.y - h.y) * c)),
            n > s || r > i
              ? null
              : ((r > n || isNaN(n)) && (n = r),
                (s < i || isNaN(i)) && (i = s),
                u >= 0
                  ? ((o = (t.min.z - h.z) * u), (a = (t.max.z - h.z) * u))
                  : ((o = (t.max.z - h.z) * u), (a = (t.min.z - h.z) * u)),
                n > a || o > i
                  ? null
                  : ((o > n || n != n) && (n = o),
                    (a < i || i != i) && (i = a),
                    i < 0 ? null : this.at(n >= 0 ? n : i, e)))
          );
        }
        intersectsBox(t) {
          return null !== this.intersectBox(t, Zp);
        }
        intersectTriangle(t, e, n, i, r) {
          tf.subVectors(e, t), ef.subVectors(n, t), nf.crossVectors(tf, ef);
          let s,
            o = this.direction.dot(nf);
          if (o > 0) {
            if (i) return null;
            s = 1;
          } else {
            if (!(o < 0)) return null;
            (s = -1), (o = -o);
          }
          Qp.subVectors(this.origin, t);
          const a = s * this.direction.dot(ef.crossVectors(Qp, ef));
          if (a < 0) return null;
          const l = s * this.direction.dot(tf.cross(Qp));
          if (l < 0) return null;
          if (a + l > o) return null;
          const c = -s * Qp.dot(nf);
          return c < 0 ? null : this.at(c / o, r);
        }
        applyMatrix4(t) {
          return (
            this.origin.applyMatrix4(t),
            this.direction.transformDirection(t),
            this
          );
        }
        equals(t) {
          return (
            t.origin.equals(this.origin) && t.direction.equals(this.direction)
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class sf {
        constructor(t, e, n, i, r, s, o, a, l, c, u, h, d, p, f, m) {
          (sf.prototype.isMatrix4 = !0),
            (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
            void 0 !== t &&
              this.set(t, e, n, i, r, s, o, a, l, c, u, h, d, p, f, m);
        }
        set(t, e, n, i, r, s, o, a, l, c, u, h, d, p, f, m) {
          const g = this.elements;
          return (
            (g[0] = t),
            (g[4] = e),
            (g[8] = n),
            (g[12] = i),
            (g[1] = r),
            (g[5] = s),
            (g[9] = o),
            (g[13] = a),
            (g[2] = l),
            (g[6] = c),
            (g[10] = u),
            (g[14] = h),
            (g[3] = d),
            (g[7] = p),
            (g[11] = f),
            (g[15] = m),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new sf().fromArray(this.elements);
        }
        copy(t) {
          const e = this.elements,
            n = t.elements;
          return (
            (e[0] = n[0]),
            (e[1] = n[1]),
            (e[2] = n[2]),
            (e[3] = n[3]),
            (e[4] = n[4]),
            (e[5] = n[5]),
            (e[6] = n[6]),
            (e[7] = n[7]),
            (e[8] = n[8]),
            (e[9] = n[9]),
            (e[10] = n[10]),
            (e[11] = n[11]),
            (e[12] = n[12]),
            (e[13] = n[13]),
            (e[14] = n[14]),
            (e[15] = n[15]),
            this
          );
        }
        copyPosition(t) {
          const e = this.elements,
            n = t.elements;
          return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
        }
        setFromMatrix3(t) {
          const e = t.elements;
          return (
            this.set(
              e[0],
              e[3],
              e[6],
              0,
              e[1],
              e[4],
              e[7],
              0,
              e[2],
              e[5],
              e[8],
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractBasis(t, e, n) {
          return (
            t.setFromMatrixColumn(this, 0),
            e.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
          );
        }
        makeBasis(t, e, n) {
          return (
            this.set(
              t.x,
              e.x,
              n.x,
              0,
              t.y,
              e.y,
              n.y,
              0,
              t.z,
              e.z,
              n.z,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractRotation(t) {
          const e = this.elements,
            n = t.elements,
            i = 1 / of.setFromMatrixColumn(t, 0).length(),
            r = 1 / of.setFromMatrixColumn(t, 1).length(),
            s = 1 / of.setFromMatrixColumn(t, 2).length();
          return (
            (e[0] = n[0] * i),
            (e[1] = n[1] * i),
            (e[2] = n[2] * i),
            (e[3] = 0),
            (e[4] = n[4] * r),
            (e[5] = n[5] * r),
            (e[6] = n[6] * r),
            (e[7] = 0),
            (e[8] = n[8] * s),
            (e[9] = n[9] * s),
            (e[10] = n[10] * s),
            (e[11] = 0),
            (e[12] = 0),
            (e[13] = 0),
            (e[14] = 0),
            (e[15] = 1),
            this
          );
        }
        makeRotationFromEuler(t) {
          const e = this.elements,
            n = t.x,
            i = t.y,
            r = t.z,
            s = Math.cos(n),
            o = Math.sin(n),
            a = Math.cos(i),
            l = Math.sin(i),
            c = Math.cos(r),
            u = Math.sin(r);
          if ("XYZ" === t.order) {
            const t = s * c,
              n = s * u,
              i = o * c,
              r = o * u;
            (e[0] = a * c),
              (e[4] = -a * u),
              (e[8] = l),
              (e[1] = n + i * l),
              (e[5] = t - r * l),
              (e[9] = -o * a),
              (e[2] = r - t * l),
              (e[6] = i + n * l),
              (e[10] = s * a);
          } else if ("YXZ" === t.order) {
            const t = a * c,
              n = a * u,
              i = l * c,
              r = l * u;
            (e[0] = t + r * o),
              (e[4] = i * o - n),
              (e[8] = s * l),
              (e[1] = s * u),
              (e[5] = s * c),
              (e[9] = -o),
              (e[2] = n * o - i),
              (e[6] = r + t * o),
              (e[10] = s * a);
          } else if ("ZXY" === t.order) {
            const t = a * c,
              n = a * u,
              i = l * c,
              r = l * u;
            (e[0] = t - r * o),
              (e[4] = -s * u),
              (e[8] = i + n * o),
              (e[1] = n + i * o),
              (e[5] = s * c),
              (e[9] = r - t * o),
              (e[2] = -s * l),
              (e[6] = o),
              (e[10] = s * a);
          } else if ("ZYX" === t.order) {
            const t = s * c,
              n = s * u,
              i = o * c,
              r = o * u;
            (e[0] = a * c),
              (e[4] = i * l - n),
              (e[8] = t * l + r),
              (e[1] = a * u),
              (e[5] = r * l + t),
              (e[9] = n * l - i),
              (e[2] = -l),
              (e[6] = o * a),
              (e[10] = s * a);
          } else if ("YZX" === t.order) {
            const t = s * a,
              n = s * l,
              i = o * a,
              r = o * l;
            (e[0] = a * c),
              (e[4] = r - t * u),
              (e[8] = i * u + n),
              (e[1] = u),
              (e[5] = s * c),
              (e[9] = -o * c),
              (e[2] = -l * c),
              (e[6] = n * u + i),
              (e[10] = t - r * u);
          } else if ("XZY" === t.order) {
            const t = s * a,
              n = s * l,
              i = o * a,
              r = o * l;
            (e[0] = a * c),
              (e[4] = -u),
              (e[8] = l * c),
              (e[1] = t * u + r),
              (e[5] = s * c),
              (e[9] = n * u - i),
              (e[2] = i * u - n),
              (e[6] = o * c),
              (e[10] = r * u + t);
          }
          return (
            (e[3] = 0),
            (e[7] = 0),
            (e[11] = 0),
            (e[12] = 0),
            (e[13] = 0),
            (e[14] = 0),
            (e[15] = 1),
            this
          );
        }
        makeRotationFromQuaternion(t) {
          return this.compose(lf, t, cf);
        }
        lookAt(t, e, n) {
          const i = this.elements;
          return (
            df.subVectors(t, e),
            0 === df.lengthSq() && (df.z = 1),
            df.normalize(),
            uf.crossVectors(n, df),
            0 === uf.lengthSq() &&
              (1 === Math.abs(n.z) ? (df.x += 1e-4) : (df.z += 1e-4),
              df.normalize(),
              uf.crossVectors(n, df)),
            uf.normalize(),
            hf.crossVectors(df, uf),
            (i[0] = uf.x),
            (i[4] = hf.x),
            (i[8] = df.x),
            (i[1] = uf.y),
            (i[5] = hf.y),
            (i[9] = df.y),
            (i[2] = uf.z),
            (i[6] = hf.z),
            (i[10] = df.z),
            this
          );
        }
        multiply(t) {
          return this.multiplyMatrices(this, t);
        }
        premultiply(t) {
          return this.multiplyMatrices(t, this);
        }
        multiplyMatrices(t, e) {
          const n = t.elements,
            i = e.elements,
            r = this.elements,
            s = n[0],
            o = n[4],
            a = n[8],
            l = n[12],
            c = n[1],
            u = n[5],
            h = n[9],
            d = n[13],
            p = n[2],
            f = n[6],
            m = n[10],
            g = n[14],
            v = n[3],
            _ = n[7],
            y = n[11],
            x = n[15],
            b = i[0],
            S = i[4],
            E = i[8],
            T = i[12],
            M = i[1],
            w = i[5],
            D = i[9],
            A = i[13],
            C = i[2],
            P = i[6],
            R = i[10],
            L = i[14],
            O = i[3],
            I = i[7],
            F = i[11],
            N = i[15];
          return (
            (r[0] = s * b + o * M + a * C + l * O),
            (r[4] = s * S + o * w + a * P + l * I),
            (r[8] = s * E + o * D + a * R + l * F),
            (r[12] = s * T + o * A + a * L + l * N),
            (r[1] = c * b + u * M + h * C + d * O),
            (r[5] = c * S + u * w + h * P + d * I),
            (r[9] = c * E + u * D + h * R + d * F),
            (r[13] = c * T + u * A + h * L + d * N),
            (r[2] = p * b + f * M + m * C + g * O),
            (r[6] = p * S + f * w + m * P + g * I),
            (r[10] = p * E + f * D + m * R + g * F),
            (r[14] = p * T + f * A + m * L + g * N),
            (r[3] = v * b + _ * M + y * C + x * O),
            (r[7] = v * S + _ * w + y * P + x * I),
            (r[11] = v * E + _ * D + y * R + x * F),
            (r[15] = v * T + _ * A + y * L + x * N),
            this
          );
        }
        multiplyScalar(t) {
          const e = this.elements;
          return (
            (e[0] *= t),
            (e[4] *= t),
            (e[8] *= t),
            (e[12] *= t),
            (e[1] *= t),
            (e[5] *= t),
            (e[9] *= t),
            (e[13] *= t),
            (e[2] *= t),
            (e[6] *= t),
            (e[10] *= t),
            (e[14] *= t),
            (e[3] *= t),
            (e[7] *= t),
            (e[11] *= t),
            (e[15] *= t),
            this
          );
        }
        determinant() {
          const t = this.elements,
            e = t[0],
            n = t[4],
            i = t[8],
            r = t[12],
            s = t[1],
            o = t[5],
            a = t[9],
            l = t[13],
            c = t[2],
            u = t[6],
            h = t[10],
            d = t[14];
          return (
            t[3] *
              (+r * a * u -
                i * l * u -
                r * o * h +
                n * l * h +
                i * o * d -
                n * a * d) +
            t[7] *
              (+e * a * d -
                e * l * h +
                r * s * h -
                i * s * d +
                i * l * c -
                r * a * c) +
            t[11] *
              (+e * l * u -
                e * o * d -
                r * s * u +
                n * s * d +
                r * o * c -
                n * l * c) +
            t[15] *
              (-i * o * c -
                e * a * u +
                e * o * h +
                i * s * u -
                n * s * h +
                n * a * c)
          );
        }
        transpose() {
          const t = this.elements;
          let e;
          return (
            (e = t[1]),
            (t[1] = t[4]),
            (t[4] = e),
            (e = t[2]),
            (t[2] = t[8]),
            (t[8] = e),
            (e = t[6]),
            (t[6] = t[9]),
            (t[9] = e),
            (e = t[3]),
            (t[3] = t[12]),
            (t[12] = e),
            (e = t[7]),
            (t[7] = t[13]),
            (t[13] = e),
            (e = t[11]),
            (t[11] = t[14]),
            (t[14] = e),
            this
          );
        }
        setPosition(t, e, n) {
          const i = this.elements;
          return (
            t.isVector3
              ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
              : ((i[12] = t), (i[13] = e), (i[14] = n)),
            this
          );
        }
        invert() {
          const t = this.elements,
            e = t[0],
            n = t[1],
            i = t[2],
            r = t[3],
            s = t[4],
            o = t[5],
            a = t[6],
            l = t[7],
            c = t[8],
            u = t[9],
            h = t[10],
            d = t[11],
            p = t[12],
            f = t[13],
            m = t[14],
            g = t[15],
            v =
              u * m * l -
              f * h * l +
              f * a * d -
              o * m * d -
              u * a * g +
              o * h * g,
            _ =
              p * h * l -
              c * m * l -
              p * a * d +
              s * m * d +
              c * a * g -
              s * h * g,
            y =
              c * f * l -
              p * u * l +
              p * o * d -
              s * f * d -
              c * o * g +
              s * u * g,
            x =
              p * u * a -
              c * f * a -
              p * o * h +
              s * f * h +
              c * o * m -
              s * u * m,
            b = e * v + n * _ + i * y + r * x;
          if (0 === b)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const S = 1 / b;
          return (
            (t[0] = v * S),
            (t[1] =
              (f * h * r -
                u * m * r -
                f * i * d +
                n * m * d +
                u * i * g -
                n * h * g) *
              S),
            (t[2] =
              (o * m * r -
                f * a * r +
                f * i * l -
                n * m * l -
                o * i * g +
                n * a * g) *
              S),
            (t[3] =
              (u * a * r -
                o * h * r -
                u * i * l +
                n * h * l +
                o * i * d -
                n * a * d) *
              S),
            (t[4] = _ * S),
            (t[5] =
              (c * m * r -
                p * h * r +
                p * i * d -
                e * m * d -
                c * i * g +
                e * h * g) *
              S),
            (t[6] =
              (p * a * r -
                s * m * r -
                p * i * l +
                e * m * l +
                s * i * g -
                e * a * g) *
              S),
            (t[7] =
              (s * h * r -
                c * a * r +
                c * i * l -
                e * h * l -
                s * i * d +
                e * a * d) *
              S),
            (t[8] = y * S),
            (t[9] =
              (p * u * r -
                c * f * r -
                p * n * d +
                e * f * d +
                c * n * g -
                e * u * g) *
              S),
            (t[10] =
              (s * f * r -
                p * o * r +
                p * n * l -
                e * f * l -
                s * n * g +
                e * o * g) *
              S),
            (t[11] =
              (c * o * r -
                s * u * r -
                c * n * l +
                e * u * l +
                s * n * d -
                e * o * d) *
              S),
            (t[12] = x * S),
            (t[13] =
              (c * f * i -
                p * u * i +
                p * n * h -
                e * f * h -
                c * n * m +
                e * u * m) *
              S),
            (t[14] =
              (p * o * i -
                s * f * i -
                p * n * a +
                e * f * a +
                s * n * m -
                e * o * m) *
              S),
            (t[15] =
              (s * u * i -
                c * o * i +
                c * n * a -
                e * u * a -
                s * n * h +
                e * o * h) *
              S),
            this
          );
        }
        scale(t) {
          const e = this.elements,
            n = t.x,
            i = t.y,
            r = t.z;
          return (
            (e[0] *= n),
            (e[4] *= i),
            (e[8] *= r),
            (e[1] *= n),
            (e[5] *= i),
            (e[9] *= r),
            (e[2] *= n),
            (e[6] *= i),
            (e[10] *= r),
            (e[3] *= n),
            (e[7] *= i),
            (e[11] *= r),
            this
          );
        }
        getMaxScaleOnAxis() {
          const t = this.elements,
            e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
            n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
            i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
          return Math.sqrt(Math.max(e, n, i));
        }
        makeTranslation(t, e, n) {
          return (
            t.isVector3
              ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1)
              : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
            this
          );
        }
        makeRotationX(t) {
          const e = Math.cos(t),
            n = Math.sin(t);
          return (
            this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationY(t) {
          const e = Math.cos(t),
            n = Math.sin(t);
          return (
            this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationZ(t) {
          const e = Math.cos(t),
            n = Math.sin(t);
          return (
            this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationAxis(t, e) {
          const n = Math.cos(e),
            i = Math.sin(e),
            r = 1 - n,
            s = t.x,
            o = t.y,
            a = t.z,
            l = r * s,
            c = r * o;
          return (
            this.set(
              l * s + n,
              l * o - i * a,
              l * a + i * o,
              0,
              l * o + i * a,
              c * o + n,
              c * a - i * s,
              0,
              l * a - i * o,
              c * a + i * s,
              r * a * a + n,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        makeScale(t, e, n) {
          return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
        }
        makeShear(t, e, n, i, r, s) {
          return this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1), this;
        }
        compose(t, e, n) {
          const i = this.elements,
            r = e._x,
            s = e._y,
            o = e._z,
            a = e._w,
            l = r + r,
            c = s + s,
            u = o + o,
            h = r * l,
            d = r * c,
            p = r * u,
            f = s * c,
            m = s * u,
            g = o * u,
            v = a * l,
            _ = a * c,
            y = a * u,
            x = n.x,
            b = n.y,
            S = n.z;
          return (
            (i[0] = (1 - (f + g)) * x),
            (i[1] = (d + y) * x),
            (i[2] = (p - _) * x),
            (i[3] = 0),
            (i[4] = (d - y) * b),
            (i[5] = (1 - (h + g)) * b),
            (i[6] = (m + v) * b),
            (i[7] = 0),
            (i[8] = (p + _) * S),
            (i[9] = (m - v) * S),
            (i[10] = (1 - (h + f)) * S),
            (i[11] = 0),
            (i[12] = t.x),
            (i[13] = t.y),
            (i[14] = t.z),
            (i[15] = 1),
            this
          );
        }
        decompose(t, e, n) {
          const i = this.elements;
          let r = of.set(i[0], i[1], i[2]).length();
          const s = of.set(i[4], i[5], i[6]).length(),
            o = of.set(i[8], i[9], i[10]).length();
          this.determinant() < 0 && (r = -r),
            (t.x = i[12]),
            (t.y = i[13]),
            (t.z = i[14]),
            af.copy(this);
          const a = 1 / r,
            l = 1 / s,
            c = 1 / o;
          return (
            (af.elements[0] *= a),
            (af.elements[1] *= a),
            (af.elements[2] *= a),
            (af.elements[4] *= l),
            (af.elements[5] *= l),
            (af.elements[6] *= l),
            (af.elements[8] *= c),
            (af.elements[9] *= c),
            (af.elements[10] *= c),
            e.setFromRotationMatrix(af),
            (n.x = r),
            (n.y = s),
            (n.z = o),
            this
          );
        }
        makePerspective(t, e, n, i, r, s, o = 2e3) {
          const a = this.elements,
            l = (2 * r) / (e - t),
            c = (2 * r) / (n - i),
            u = (e + t) / (e - t),
            h = (n + i) / (n - i);
          let d, p;
          if (o === Hd) (d = -(s + r) / (s - r)), (p = (-2 * s * r) / (s - r));
          else {
            if (o !== Vd)
              throw new Error(
                "THREE.Matrix4.makePerspective(): Invalid coordinate system: " +
                  o
              );
            (d = -s / (s - r)), (p = (-s * r) / (s - r));
          }
          return (
            (a[0] = l),
            (a[4] = 0),
            (a[8] = u),
            (a[12] = 0),
            (a[1] = 0),
            (a[5] = c),
            (a[9] = h),
            (a[13] = 0),
            (a[2] = 0),
            (a[6] = 0),
            (a[10] = d),
            (a[14] = p),
            (a[3] = 0),
            (a[7] = 0),
            (a[11] = -1),
            (a[15] = 0),
            this
          );
        }
        makeOrthographic(t, e, n, i, r, s, o = 2e3) {
          const a = this.elements,
            l = 1 / (e - t),
            c = 1 / (n - i),
            u = 1 / (s - r),
            h = (e + t) * l,
            d = (n + i) * c;
          let p, f;
          if (o === Hd) (p = (s + r) * u), (f = -2 * u);
          else {
            if (o !== Vd)
              throw new Error(
                "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " +
                  o
              );
            (p = r * u), (f = -1 * u);
          }
          return (
            (a[0] = 2 * l),
            (a[4] = 0),
            (a[8] = 0),
            (a[12] = -h),
            (a[1] = 0),
            (a[5] = 2 * c),
            (a[9] = 0),
            (a[13] = -d),
            (a[2] = 0),
            (a[6] = 0),
            (a[10] = f),
            (a[14] = -p),
            (a[3] = 0),
            (a[7] = 0),
            (a[11] = 0),
            (a[15] = 1),
            this
          );
        }
        equals(t) {
          const e = this.elements,
            n = t.elements;
          for (let t = 0; t < 16; t++) if (e[t] !== n[t]) return !1;
          return !0;
        }
        fromArray(t, e = 0) {
          for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
          return this;
        }
        toArray(t = [], e = 0) {
          const n = this.elements;
          return (
            (t[e] = n[0]),
            (t[e + 1] = n[1]),
            (t[e + 2] = n[2]),
            (t[e + 3] = n[3]),
            (t[e + 4] = n[4]),
            (t[e + 5] = n[5]),
            (t[e + 6] = n[6]),
            (t[e + 7] = n[7]),
            (t[e + 8] = n[8]),
            (t[e + 9] = n[9]),
            (t[e + 10] = n[10]),
            (t[e + 11] = n[11]),
            (t[e + 12] = n[12]),
            (t[e + 13] = n[13]),
            (t[e + 14] = n[14]),
            (t[e + 15] = n[15]),
            t
          );
        }
      }
      const of = new Ap(),
        af = new sf(),
        lf = new Ap(0, 0, 0),
        cf = new Ap(1, 1, 1),
        uf = new Ap(),
        hf = new Ap(),
        df = new Ap(),
        pf = new sf(),
        ff = new Dp();
      class mf {
        constructor(t = 0, e = 0, n = 0, i = mf.DEFAULT_ORDER) {
          (this.isEuler = !0),
            (this._x = t),
            (this._y = e),
            (this._z = n),
            (this._order = i);
        }
        get x() {
          return this._x;
        }
        set x(t) {
          (this._x = t), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(t) {
          (this._y = t), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(t) {
          (this._z = t), this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(t) {
          (this._order = t), this._onChangeCallback();
        }
        set(t, e, n, i = this._order) {
          return (
            (this._x = t),
            (this._y = e),
            (this._z = n),
            (this._order = i),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(t) {
          return (
            (this._x = t._x),
            (this._y = t._y),
            (this._z = t._z),
            (this._order = t._order),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(t, e = this._order, n = !0) {
          const i = t.elements,
            r = i[0],
            s = i[4],
            o = i[8],
            a = i[1],
            l = i[5],
            c = i[9],
            u = i[2],
            h = i[6],
            d = i[10];
          switch (e) {
            case "XYZ":
              (this._y = Math.asin(Yd(o, -1, 1))),
                Math.abs(o) < 0.9999999
                  ? ((this._x = Math.atan2(-c, d)),
                    (this._z = Math.atan2(-s, r)))
                  : ((this._x = Math.atan2(h, l)), (this._z = 0));
              break;
            case "YXZ":
              (this._x = Math.asin(-Yd(c, -1, 1))),
                Math.abs(c) < 0.9999999
                  ? ((this._y = Math.atan2(o, d)), (this._z = Math.atan2(a, l)))
                  : ((this._y = Math.atan2(-u, r)), (this._z = 0));
              break;
            case "ZXY":
              (this._x = Math.asin(Yd(h, -1, 1))),
                Math.abs(h) < 0.9999999
                  ? ((this._y = Math.atan2(-u, d)),
                    (this._z = Math.atan2(-s, l)))
                  : ((this._y = 0), (this._z = Math.atan2(a, r)));
              break;
            case "ZYX":
              (this._y = Math.asin(-Yd(u, -1, 1))),
                Math.abs(u) < 0.9999999
                  ? ((this._x = Math.atan2(h, d)), (this._z = Math.atan2(a, r)))
                  : ((this._x = 0), (this._z = Math.atan2(-s, l)));
              break;
            case "YZX":
              (this._z = Math.asin(Yd(a, -1, 1))),
                Math.abs(a) < 0.9999999
                  ? ((this._x = Math.atan2(-c, l)),
                    (this._y = Math.atan2(-u, r)))
                  : ((this._x = 0), (this._y = Math.atan2(o, d)));
              break;
            case "XZY":
              (this._z = Math.asin(-Yd(s, -1, 1))),
                Math.abs(s) < 0.9999999
                  ? ((this._x = Math.atan2(h, l)), (this._y = Math.atan2(o, r)))
                  : ((this._x = Math.atan2(-c, d)), (this._y = 0));
              break;
            default:
              console.warn(
                "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                  e
              );
          }
          return (this._order = e), !0 === n && this._onChangeCallback(), this;
        }
        setFromQuaternion(t, e, n) {
          return (
            pf.makeRotationFromQuaternion(t),
            this.setFromRotationMatrix(pf, e, n)
          );
        }
        setFromVector3(t, e = this._order) {
          return this.set(t.x, t.y, t.z, e);
        }
        reorder(t) {
          return ff.setFromEuler(this), this.setFromQuaternion(ff, t);
        }
        equals(t) {
          return (
            t._x === this._x &&
            t._y === this._y &&
            t._z === this._z &&
            t._order === this._order
          );
        }
        fromArray(t) {
          return (
            (this._x = t[0]),
            (this._y = t[1]),
            (this._z = t[2]),
            void 0 !== t[3] && (this._order = t[3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(t = [], e = 0) {
          return (
            (t[e] = this._x),
            (t[e + 1] = this._y),
            (t[e + 2] = this._z),
            (t[e + 3] = this._order),
            t
          );
        }
        _onChange(t) {
          return (this._onChangeCallback = t), this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._order;
        }
      }
      mf.DEFAULT_ORDER = "XYZ";
      class gf {
        constructor() {
          this.mask = 1;
        }
        set(t) {
          this.mask = ((1 << t) | 0) >>> 0;
        }
        enable(t) {
          this.mask |= (1 << t) | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(t) {
          this.mask ^= (1 << t) | 0;
        }
        disable(t) {
          this.mask &= ~((1 << t) | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(t) {
          return 0 != (this.mask & t.mask);
        }
        isEnabled(t) {
          return 0 != (this.mask & ((1 << t) | 0));
        }
      }
      let vf = 0;
      const _f = new Ap(),
        yf = new Dp(),
        xf = new sf(),
        bf = new Ap(),
        Sf = new Ap(),
        Ef = new Ap(),
        Tf = new Dp(),
        Mf = new Ap(1, 0, 0),
        wf = new Ap(0, 1, 0),
        Df = new Ap(0, 0, 1),
        Af = {
          type: "added",
        },
        Cf = {
          type: "removed",
        };
      class Pf extends Gd {
        constructor() {
          super(),
            (this.isObject3D = !0),
            Object.defineProperty(this, "id", {
              value: vf++,
            }),
            (this.uuid = qd()),
            (this.name = ""),
            (this.type = "Object3D"),
            (this.parent = null),
            (this.children = []),
            (this.up = Pf.DEFAULT_UP.clone());
          const t = new Ap(),
            e = new mf(),
            n = new Dp(),
            i = new Ap(1, 1, 1);
          e._onChange(function () {
            n.setFromEuler(e, !1);
          }),
            n._onChange(function () {
              e.setFromQuaternion(n, void 0, !1);
            }),
            Object.defineProperties(this, {
              position: {
                configurable: !0,
                enumerable: !0,
                value: t,
              },
              rotation: {
                configurable: !0,
                enumerable: !0,
                value: e,
              },
              quaternion: {
                configurable: !0,
                enumerable: !0,
                value: n,
              },
              scale: {
                configurable: !0,
                enumerable: !0,
                value: i,
              },
              modelViewMatrix: {
                value: new sf(),
              },
              normalMatrix: {
                value: new ep(),
              },
            }),
            (this.matrix = new sf()),
            (this.matrixWorld = new sf()),
            (this.matrixAutoUpdate = Pf.DEFAULT_MATRIX_AUTO_UPDATE),
            (this.matrixWorldNeedsUpdate = !1),
            (this.matrixWorldAutoUpdate = Pf.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
            (this.layers = new gf()),
            (this.visible = !0),
            (this.castShadow = !1),
            (this.receiveShadow = !1),
            (this.frustumCulled = !0),
            (this.renderOrder = 0),
            (this.animations = []),
            (this.userData = {});
        }
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(t),
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(t) {
          return this.quaternion.premultiply(t), this;
        }
        setRotationFromAxisAngle(t, e) {
          this.quaternion.setFromAxisAngle(t, e);
        }
        setRotationFromEuler(t) {
          this.quaternion.setFromEuler(t, !0);
        }
        setRotationFromMatrix(t) {
          this.quaternion.setFromRotationMatrix(t);
        }
        setRotationFromQuaternion(t) {
          this.quaternion.copy(t);
        }
        rotateOnAxis(t, e) {
          return yf.setFromAxisAngle(t, e), this.quaternion.multiply(yf), this;
        }
        rotateOnWorldAxis(t, e) {
          return (
            yf.setFromAxisAngle(t, e), this.quaternion.premultiply(yf), this
          );
        }
        rotateX(t) {
          return this.rotateOnAxis(Mf, t);
        }
        rotateY(t) {
          return this.rotateOnAxis(wf, t);
        }
        rotateZ(t) {
          return this.rotateOnAxis(Df, t);
        }
        translateOnAxis(t, e) {
          return (
            _f.copy(t).applyQuaternion(this.quaternion),
            this.position.add(_f.multiplyScalar(e)),
            this
          );
        }
        translateX(t) {
          return this.translateOnAxis(Mf, t);
        }
        translateY(t) {
          return this.translateOnAxis(wf, t);
        }
        translateZ(t) {
          return this.translateOnAxis(Df, t);
        }
        localToWorld(t) {
          return (
            this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld)
          );
        }
        worldToLocal(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            t.applyMatrix4(xf.copy(this.matrixWorld).invert())
          );
        }
        lookAt(t, e, n) {
          t.isVector3 ? bf.copy(t) : bf.set(t, e, n);
          const i = this.parent;
          this.updateWorldMatrix(!0, !1),
            Sf.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight
              ? xf.lookAt(Sf, bf, this.up)
              : xf.lookAt(bf, Sf, this.up),
            this.quaternion.setFromRotationMatrix(xf),
            i &&
              (xf.extractRotation(i.matrixWorld),
              yf.setFromRotationMatrix(xf),
              this.quaternion.premultiply(yf.invert()));
        }
        add(t) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this;
          }
          return t === this
            ? (console.error(
                "THREE.Object3D.add: object can't be added as a child of itself.",
                t
              ),
              this)
            : (t && t.isObject3D
                ? (null !== t.parent && t.parent.remove(t),
                  (t.parent = this),
                  this.children.push(t),
                  t.dispatchEvent(Af))
                : console.error(
                    "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                    t
                  ),
              this);
        }
        remove(t) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
              this.remove(arguments[t]);
            return this;
          }
          const e = this.children.indexOf(t);
          return (
            -1 !== e &&
              ((t.parent = null),
              this.children.splice(e, 1),
              t.dispatchEvent(Cf)),
            this
          );
        }
        removeFromParent() {
          const t = this.parent;
          return null !== t && t.remove(this), this;
        }
        clear() {
          return this.remove(...this.children);
        }
        attach(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            xf.copy(this.matrixWorld).invert(),
            null !== t.parent &&
              (t.parent.updateWorldMatrix(!0, !1),
              xf.multiply(t.parent.matrixWorld)),
            t.applyMatrix4(xf),
            this.add(t),
            t.updateWorldMatrix(!1, !0),
            this
          );
        }
        getObjectById(t) {
          return this.getObjectByProperty("id", t);
        }
        getObjectByName(t) {
          return this.getObjectByProperty("name", t);
        }
        getObjectByProperty(t, e) {
          if (this[t] === e) return this;
          for (let n = 0, i = this.children.length; n < i; n++) {
            const i = this.children[n].getObjectByProperty(t, e);
            if (void 0 !== i) return i;
          }
        }
        getObjectsByProperty(t, e) {
          let n = [];
          this[t] === e && n.push(this);
          for (let i = 0, r = this.children.length; i < r; i++) {
            const r = this.children[i].getObjectsByProperty(t, e);
            r.length > 0 && (n = n.concat(r));
          }
          return n;
        }
        getWorldPosition(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            t.setFromMatrixPosition(this.matrixWorld)
          );
        }
        getWorldQuaternion(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(Sf, t, Ef),
            t
          );
        }
        getWorldScale(t) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(Sf, Tf, t),
            t
          );
        }
        getWorldDirection(t) {
          this.updateWorldMatrix(!0, !1);
          const e = this.matrixWorld.elements;
          return t.set(e[8], e[9], e[10]).normalize();
        }
        raycast() {}
        traverse(t) {
          t(this);
          const e = this.children;
          for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);
        }
        traverseVisible(t) {
          if (!1 === this.visible) return;
          t(this);
          const e = this.children;
          for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t);
        }
        traverseAncestors(t) {
          const e = this.parent;
          null !== e && (t(e), e.traverseAncestors(t));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale),
            (this.matrixWorldNeedsUpdate = !0);
        }
        updateMatrixWorld(t) {
          this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || t) &&
              (null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  ),
              (this.matrixWorldNeedsUpdate = !1),
              (t = !0));
          const e = this.children;
          for (let n = 0, i = e.length; n < i; n++) {
            const i = e[n];
            (!0 !== i.matrixWorldAutoUpdate && !0 !== t) ||
              i.updateMatrixWorld(t);
          }
        }
        updateWorldMatrix(t, e) {
          const n = this.parent;
          if (
            (!0 === t &&
              null !== n &&
              !0 === n.matrixWorldAutoUpdate &&
              n.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix
                ),
            !0 === e)
          ) {
            const t = this.children;
            for (let e = 0, n = t.length; e < n; e++) {
              const n = t[e];
              !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0);
            }
          }
        }
        toJSON(t) {
          const e = void 0 === t || "string" == typeof t,
            n = {};
          e &&
            ((t = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {},
              nodes: {},
            }),
            (n.metadata = {
              version: 4.6,
              type: "Object",
              generator: "Object3D.toJSON",
            }));
          const i = {};
          function r(e, n) {
            return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
          }
          if (
            ((i.uuid = this.uuid),
            (i.type = this.type),
            "" !== this.name && (i.name = this.name),
            !0 === this.castShadow && (i.castShadow = !0),
            !0 === this.receiveShadow && (i.receiveShadow = !0),
            !1 === this.visible && (i.visible = !1),
            !1 === this.frustumCulled && (i.frustumCulled = !1),
            0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
            Object.keys(this.userData).length > 0 &&
              (i.userData = this.userData),
            (i.layers = this.layers.mask),
            (i.matrix = this.matrix.toArray()),
            (i.up = this.up.toArray()),
            !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
            this.isInstancedMesh &&
              ((i.type = "InstancedMesh"),
              (i.count = this.count),
              (i.instanceMatrix = this.instanceMatrix.toJSON()),
              null !== this.instanceColor &&
                (i.instanceColor = this.instanceColor.toJSON())),
            this.isScene)
          )
            this.background &&
              (this.background.isColor
                ? (i.background = this.background.toJSON())
                : this.background.isTexture &&
                  (i.background = this.background.toJSON(t).uuid)),
              this.environment &&
                this.environment.isTexture &&
                !0 !== this.environment.isRenderTargetTexture &&
                (i.environment = this.environment.toJSON(t).uuid);
          else if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = r(t.geometries, this.geometry);
            const e = this.geometry.parameters;
            if (void 0 !== e && void 0 !== e.shapes) {
              const n = e.shapes;
              if (Array.isArray(n))
                for (let e = 0, i = n.length; e < i; e++) {
                  const i = n[e];
                  r(t.shapes, i);
                }
              else r(t.shapes, n);
            }
          }
          if (
            (this.isSkinnedMesh &&
              ((i.bindMode = this.bindMode),
              (i.bindMatrix = this.bindMatrix.toArray()),
              void 0 !== this.skeleton &&
                (r(t.skeletons, this.skeleton),
                (i.skeleton = this.skeleton.uuid))),
            void 0 !== this.material)
          )
            if (Array.isArray(this.material)) {
              const e = [];
              for (let n = 0, i = this.material.length; n < i; n++)
                e.push(r(t.materials, this.material[n]));
              i.material = e;
            } else i.material = r(t.materials, this.material);
          if (this.children.length > 0) {
            i.children = [];
            for (let e = 0; e < this.children.length; e++)
              i.children.push(this.children[e].toJSON(t).object);
          }
          if (this.animations.length > 0) {
            i.animations = [];
            for (let e = 0; e < this.animations.length; e++) {
              const n = this.animations[e];
              i.animations.push(r(t.animations, n));
            }
          }
          if (e) {
            const e = s(t.geometries),
              i = s(t.materials),
              r = s(t.textures),
              o = s(t.images),
              a = s(t.shapes),
              l = s(t.skeletons),
              c = s(t.animations),
              u = s(t.nodes);
            e.length > 0 && (n.geometries = e),
              i.length > 0 && (n.materials = i),
              r.length > 0 && (n.textures = r),
              o.length > 0 && (n.images = o),
              a.length > 0 && (n.shapes = a),
              l.length > 0 && (n.skeletons = l),
              c.length > 0 && (n.animations = c),
              u.length > 0 && (n.nodes = u);
          }
          return (n.object = i), n;
          function s(t) {
            const e = [];
            for (const n in t) {
              const i = t[n];
              delete i.metadata, e.push(i);
            }
            return e;
          }
        }
        clone(t) {
          return new this.constructor().copy(this, t);
        }
        copy(t, e = !0) {
          if (
            ((this.name = t.name),
            this.up.copy(t.up),
            this.position.copy(t.position),
            (this.rotation.order = t.rotation.order),
            this.quaternion.copy(t.quaternion),
            this.scale.copy(t.scale),
            this.matrix.copy(t.matrix),
            this.matrixWorld.copy(t.matrixWorld),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
            (this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate),
            (this.layers.mask = t.layers.mask),
            (this.visible = t.visible),
            (this.castShadow = t.castShadow),
            (this.receiveShadow = t.receiveShadow),
            (this.frustumCulled = t.frustumCulled),
            (this.renderOrder = t.renderOrder),
            (this.animations = t.animations.slice()),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            !0 === e)
          )
            for (let e = 0; e < t.children.length; e++) {
              const n = t.children[e];
              this.add(n.clone());
            }
          return this;
        }
      }
      (Pf.DEFAULT_UP = new Ap(0, 1, 0)),
        (Pf.DEFAULT_MATRIX_AUTO_UPDATE = !0),
        (Pf.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0);
      const Rf = new Ap(),
        Lf = new Ap(),
        Of = new Ap(),
        If = new Ap(),
        Ff = new Ap(),
        Nf = new Ap(),
        Uf = new Ap(),
        kf = new Ap(),
        zf = new Ap(),
        Bf = new Ap();
      let Hf = !1;
      class Vf {
        constructor(t = new Ap(), e = new Ap(), n = new Ap()) {
          (this.a = t), (this.b = e), (this.c = n);
        }
        static getNormal(t, e, n, i) {
          i.subVectors(n, e), Rf.subVectors(t, e), i.cross(Rf);
          const r = i.lengthSq();
          return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
        }
        static getBarycoord(t, e, n, i, r) {
          Rf.subVectors(i, e), Lf.subVectors(n, e), Of.subVectors(t, e);
          const s = Rf.dot(Rf),
            o = Rf.dot(Lf),
            a = Rf.dot(Of),
            l = Lf.dot(Lf),
            c = Lf.dot(Of),
            u = s * l - o * o;
          if (0 === u) return r.set(-2, -1, -1);
          const h = 1 / u,
            d = (l * a - o * c) * h,
            p = (s * c - o * a) * h;
          return r.set(1 - d - p, p, d);
        }
        static containsPoint(t, e, n, i) {
          return (
            this.getBarycoord(t, e, n, i, If),
            If.x >= 0 && If.y >= 0 && If.x + If.y <= 1
          );
        }
        static getUV(t, e, n, i, r, s, o, a) {
          return (
            !1 === Hf &&
              (console.warn(
                "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
              ),
              (Hf = !0)),
            this.getInterpolation(t, e, n, i, r, s, o, a)
          );
        }
        static getInterpolation(t, e, n, i, r, s, o, a) {
          return (
            this.getBarycoord(t, e, n, i, If),
            a.setScalar(0),
            a.addScaledVector(r, If.x),
            a.addScaledVector(s, If.y),
            a.addScaledVector(o, If.z),
            a
          );
        }
        static isFrontFacing(t, e, n, i) {
          return (
            Rf.subVectors(n, e), Lf.subVectors(t, e), Rf.cross(Lf).dot(i) < 0
          );
        }
        set(t, e, n) {
          return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
        }
        setFromPointsAndIndices(t, e, n, i) {
          return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
        }
        setFromAttributeAndIndices(t, e, n, i) {
          return (
            this.a.fromBufferAttribute(t, e),
            this.b.fromBufferAttribute(t, n),
            this.c.fromBufferAttribute(t, i),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
        }
        getArea() {
          return (
            Rf.subVectors(this.c, this.b),
            Lf.subVectors(this.a, this.b),
            0.5 * Rf.cross(Lf).length()
          );
        }
        getMidpoint(t) {
          return t
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3);
        }
        getNormal(t) {
          return Vf.getNormal(this.a, this.b, this.c, t);
        }
        getPlane(t) {
          return t.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(t, e) {
          return Vf.getBarycoord(t, this.a, this.b, this.c, e);
        }
        getUV(t, e, n, i, r) {
          return (
            !1 === Hf &&
              (console.warn(
                "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
              ),
              (Hf = !0)),
            Vf.getInterpolation(t, this.a, this.b, this.c, e, n, i, r)
          );
        }
        getInterpolation(t, e, n, i, r) {
          return Vf.getInterpolation(t, this.a, this.b, this.c, e, n, i, r);
        }
        containsPoint(t) {
          return Vf.containsPoint(t, this.a, this.b, this.c);
        }
        isFrontFacing(t) {
          return Vf.isFrontFacing(this.a, this.b, this.c, t);
        }
        intersectsBox(t) {
          return t.intersectsTriangle(this);
        }
        closestPointToPoint(t, e) {
          const n = this.a,
            i = this.b,
            r = this.c;
          let s, o;
          Ff.subVectors(i, n), Nf.subVectors(r, n), kf.subVectors(t, n);
          const a = Ff.dot(kf),
            l = Nf.dot(kf);
          if (a <= 0 && l <= 0) return e.copy(n);
          zf.subVectors(t, i);
          const c = Ff.dot(zf),
            u = Nf.dot(zf);
          if (c >= 0 && u <= c) return e.copy(i);
          const h = a * u - c * l;
          if (h <= 0 && a >= 0 && c <= 0)
            return (s = a / (a - c)), e.copy(n).addScaledVector(Ff, s);
          Bf.subVectors(t, r);
          const d = Ff.dot(Bf),
            p = Nf.dot(Bf);
          if (p >= 0 && d <= p) return e.copy(r);
          const f = d * l - a * p;
          if (f <= 0 && l >= 0 && p <= 0)
            return (o = l / (l - p)), e.copy(n).addScaledVector(Nf, o);
          const m = c * p - d * u;
          if (m <= 0 && u - c >= 0 && d - p >= 0)
            return (
              Uf.subVectors(r, i),
              (o = (u - c) / (u - c + (d - p))),
              e.copy(i).addScaledVector(Uf, o)
            );
          const g = 1 / (m + f + h);
          return (
            (s = f * g),
            (o = h * g),
            e.copy(n).addScaledVector(Ff, s).addScaledVector(Nf, o)
          );
        }
        equals(t) {
          return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
        }
      }
      let Gf = 0;
      class Wf extends Gd {
        constructor() {
          super(),
            (this.isMaterial = !0),
            Object.defineProperty(this, "id", {
              value: Gf++,
            }),
            (this.uuid = qd()),
            (this.name = ""),
            (this.type = "Material"),
            (this.blending = 1),
            (this.side = 0),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.transparent = !1),
            (this.alphaHash = !1),
            (this.blendSrc = 204),
            (this.blendDst = 205),
            (this.blendEquation = jh),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.depthFunc = 3),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = 519),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = kd),
            (this.stencilZFail = kd),
            (this.stencilZPass = kd),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.forceSinglePass = !1),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0),
            (this._alphaTest = 0);
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(t) {
          this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t);
        }
        onBuild() {}
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(t) {
          if (void 0 !== t)
            for (const e in t) {
              const n = t[e];
              if (void 0 === n) {
                console.warn(
                  `THREE.Material: parameter '${e}' has value of undefined.`
                );
                continue;
              }
              const i = this[e];
              void 0 !== i
                ? i && i.isColor
                  ? i.set(n)
                  : i && i.isVector3 && n && n.isVector3
                  ? i.copy(n)
                  : (this[e] = n)
                : console.warn(
                    `THREE.Material: '${e}' is not a property of THREE.${this.type}.`
                  );
            }
        }
        toJSON(t) {
          const e = void 0 === t || "string" == typeof t;
          e &&
            (t = {
              textures: {},
              images: {},
            });
          const n = {
            metadata: {
              version: 4.6,
              type: "Material",
              generator: "Material.toJSON",
            },
          };
          function i(t) {
            const e = [];
            for (const n in t) {
              const i = t[n];
              delete i.metadata, e.push(i);
            }
            return e;
          }
          if (
            ((n.uuid = this.uuid),
            (n.type = this.type),
            "" !== this.name && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            void 0 !== this.roughness && (n.roughness = this.roughness),
            void 0 !== this.metalness && (n.metalness = this.metalness),
            void 0 !== this.sheen && (n.sheen = this.sheen),
            this.sheenColor &&
              this.sheenColor.isColor &&
              (n.sheenColor = this.sheenColor.getHex()),
            void 0 !== this.sheenRoughness &&
              (n.sheenRoughness = this.sheenRoughness),
            this.emissive &&
              this.emissive.isColor &&
              (n.emissive = this.emissive.getHex()),
            this.emissiveIntensity &&
              1 !== this.emissiveIntensity &&
              (n.emissiveIntensity = this.emissiveIntensity),
            this.specular &&
              this.specular.isColor &&
              (n.specular = this.specular.getHex()),
            void 0 !== this.specularIntensity &&
              (n.specularIntensity = this.specularIntensity),
            this.specularColor &&
              this.specularColor.isColor &&
              (n.specularColor = this.specularColor.getHex()),
            void 0 !== this.shininess && (n.shininess = this.shininess),
            void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
            void 0 !== this.clearcoatRoughness &&
              (n.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap &&
              this.clearcoatMap.isTexture &&
              (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
            this.clearcoatRoughnessMap &&
              this.clearcoatRoughnessMap.isTexture &&
              (n.clearcoatRoughnessMap =
                this.clearcoatRoughnessMap.toJSON(t).uuid),
            this.clearcoatNormalMap &&
              this.clearcoatNormalMap.isTexture &&
              ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
              (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
            void 0 !== this.iridescence && (n.iridescence = this.iridescence),
            void 0 !== this.iridescenceIOR &&
              (n.iridescenceIOR = this.iridescenceIOR),
            void 0 !== this.iridescenceThicknessRange &&
              (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
            this.iridescenceMap &&
              this.iridescenceMap.isTexture &&
              (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid),
            this.iridescenceThicknessMap &&
              this.iridescenceThicknessMap.isTexture &&
              (n.iridescenceThicknessMap =
                this.iridescenceThicknessMap.toJSON(t).uuid),
            void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy),
            void 0 !== this.anisotropyRotation &&
              (n.anisotropyRotation = this.anisotropyRotation),
            this.anisotropyMap &&
              this.anisotropyMap.isTexture &&
              (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
            this.matcap &&
              this.matcap.isTexture &&
              (n.matcap = this.matcap.toJSON(t).uuid),
            this.alphaMap &&
              this.alphaMap.isTexture &&
              (n.alphaMap = this.alphaMap.toJSON(t).uuid),
            this.lightMap &&
              this.lightMap.isTexture &&
              ((n.lightMap = this.lightMap.toJSON(t).uuid),
              (n.lightMapIntensity = this.lightMapIntensity)),
            this.aoMap &&
              this.aoMap.isTexture &&
              ((n.aoMap = this.aoMap.toJSON(t).uuid),
              (n.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
              this.bumpMap.isTexture &&
              ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
              (n.bumpScale = this.bumpScale)),
            this.normalMap &&
              this.normalMap.isTexture &&
              ((n.normalMap = this.normalMap.toJSON(t).uuid),
              (n.normalMapType = this.normalMapType),
              (n.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
              (n.displacementScale = this.displacementScale),
              (n.displacementBias = this.displacementBias)),
            this.roughnessMap &&
              this.roughnessMap.isTexture &&
              (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
            this.metalnessMap &&
              this.metalnessMap.isTexture &&
              (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
            this.emissiveMap &&
              this.emissiveMap.isTexture &&
              (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
            this.specularMap &&
              this.specularMap.isTexture &&
              (n.specularMap = this.specularMap.toJSON(t).uuid),
            this.specularIntensityMap &&
              this.specularIntensityMap.isTexture &&
              (n.specularIntensityMap =
                this.specularIntensityMap.toJSON(t).uuid),
            this.specularColorMap &&
              this.specularColorMap.isTexture &&
              (n.specularColorMap = this.specularColorMap.toJSON(t).uuid),
            this.envMap &&
              this.envMap.isTexture &&
              ((n.envMap = this.envMap.toJSON(t).uuid),
              void 0 !== this.combine && (n.combine = this.combine)),
            void 0 !== this.envMapIntensity &&
              (n.envMapIntensity = this.envMapIntensity),
            void 0 !== this.reflectivity &&
              (n.reflectivity = this.reflectivity),
            void 0 !== this.refractionRatio &&
              (n.refractionRatio = this.refractionRatio),
            this.gradientMap &&
              this.gradientMap.isTexture &&
              (n.gradientMap = this.gradientMap.toJSON(t).uuid),
            void 0 !== this.transmission &&
              (n.transmission = this.transmission),
            this.transmissionMap &&
              this.transmissionMap.isTexture &&
              (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
            void 0 !== this.thickness && (n.thickness = this.thickness),
            this.thicknessMap &&
              this.thicknessMap.isTexture &&
              (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
            void 0 !== this.attenuationDistance &&
              this.attenuationDistance !== 1 / 0 &&
              (n.attenuationDistance = this.attenuationDistance),
            void 0 !== this.attenuationColor &&
              (n.attenuationColor = this.attenuationColor.getHex()),
            void 0 !== this.size && (n.size = this.size),
            null !== this.shadowSide && (n.shadowSide = this.shadowSide),
            void 0 !== this.sizeAttenuation &&
              (n.sizeAttenuation = this.sizeAttenuation),
            1 !== this.blending && (n.blending = this.blending),
            0 !== this.side && (n.side = this.side),
            !0 === this.vertexColors && (n.vertexColors = !0),
            this.opacity < 1 && (n.opacity = this.opacity),
            !0 === this.transparent && (n.transparent = !0),
            (n.depthFunc = this.depthFunc),
            (n.depthTest = this.depthTest),
            (n.depthWrite = this.depthWrite),
            (n.colorWrite = this.colorWrite),
            (n.stencilWrite = this.stencilWrite),
            (n.stencilWriteMask = this.stencilWriteMask),
            (n.stencilFunc = this.stencilFunc),
            (n.stencilRef = this.stencilRef),
            (n.stencilFuncMask = this.stencilFuncMask),
            (n.stencilFail = this.stencilFail),
            (n.stencilZFail = this.stencilZFail),
            (n.stencilZPass = this.stencilZPass),
            void 0 !== this.rotation &&
              0 !== this.rotation &&
              (n.rotation = this.rotation),
            !0 === this.polygonOffset && (n.polygonOffset = !0),
            0 !== this.polygonOffsetFactor &&
              (n.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits &&
              (n.polygonOffsetUnits = this.polygonOffsetUnits),
            void 0 !== this.linewidth &&
              1 !== this.linewidth &&
              (n.linewidth = this.linewidth),
            void 0 !== this.dashSize && (n.dashSize = this.dashSize),
            void 0 !== this.gapSize && (n.gapSize = this.gapSize),
            void 0 !== this.scale && (n.scale = this.scale),
            !0 === this.dithering && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            !0 === this.alphaHash && (n.alphaHash = !0),
            !0 === this.alphaToCoverage && (n.alphaToCoverage = !0),
            !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0),
            !0 === this.forceSinglePass && (n.forceSinglePass = !0),
            !0 === this.wireframe && (n.wireframe = !0),
            this.wireframeLinewidth > 1 &&
              (n.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap &&
              (n.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin &&
              (n.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.flatShading && (n.flatShading = !0),
            !1 === this.visible && (n.visible = !1),
            !1 === this.toneMapped && (n.toneMapped = !1),
            !1 === this.fog && (n.fog = !1),
            Object.keys(this.userData).length > 0 &&
              (n.userData = this.userData),
            e)
          ) {
            const e = i(t.textures),
              r = i(t.images);
            e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r);
          }
          return n;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          (this.name = t.name),
            (this.blending = t.blending),
            (this.side = t.side),
            (this.vertexColors = t.vertexColors),
            (this.opacity = t.opacity),
            (this.transparent = t.transparent),
            (this.blendSrc = t.blendSrc),
            (this.blendDst = t.blendDst),
            (this.blendEquation = t.blendEquation),
            (this.blendSrcAlpha = t.blendSrcAlpha),
            (this.blendDstAlpha = t.blendDstAlpha),
            (this.blendEquationAlpha = t.blendEquationAlpha),
            (this.depthFunc = t.depthFunc),
            (this.depthTest = t.depthTest),
            (this.depthWrite = t.depthWrite),
            (this.stencilWriteMask = t.stencilWriteMask),
            (this.stencilFunc = t.stencilFunc),
            (this.stencilRef = t.stencilRef),
            (this.stencilFuncMask = t.stencilFuncMask),
            (this.stencilFail = t.stencilFail),
            (this.stencilZFail = t.stencilZFail),
            (this.stencilZPass = t.stencilZPass),
            (this.stencilWrite = t.stencilWrite);
          const e = t.clippingPlanes;
          let n = null;
          if (null !== e) {
            const t = e.length;
            n = new Array(t);
            for (let i = 0; i !== t; ++i) n[i] = e[i].clone();
          }
          return (
            (this.clippingPlanes = n),
            (this.clipIntersection = t.clipIntersection),
            (this.clipShadows = t.clipShadows),
            (this.shadowSide = t.shadowSide),
            (this.colorWrite = t.colorWrite),
            (this.precision = t.precision),
            (this.polygonOffset = t.polygonOffset),
            (this.polygonOffsetFactor = t.polygonOffsetFactor),
            (this.polygonOffsetUnits = t.polygonOffsetUnits),
            (this.dithering = t.dithering),
            (this.alphaTest = t.alphaTest),
            (this.alphaHash = t.alphaHash),
            (this.alphaToCoverage = t.alphaToCoverage),
            (this.premultipliedAlpha = t.premultipliedAlpha),
            (this.forceSinglePass = t.forceSinglePass),
            (this.visible = t.visible),
            (this.toneMapped = t.toneMapped),
            (this.userData = JSON.parse(JSON.stringify(t.userData))),
            this
          );
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose",
          });
        }
        set needsUpdate(t) {
          !0 === t && this.version++;
        }
      }
      const jf = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        Xf = {
          h: 0,
          s: 0,
          l: 0,
        },
        qf = {
          h: 0,
          s: 0,
          l: 0,
        };
      function Yf(t, e, n) {
        return (
          n < 0 && (n += 1),
          n > 1 && (n -= 1),
          n < 1 / 6
            ? t + 6 * (e - t) * n
            : n < 0.5
            ? e
            : n < 2 / 3
            ? t + 6 * (e - t) * (2 / 3 - n)
            : t
        );
      }
      class Kf {
        constructor(t, e, n) {
          return (
            (this.isColor = !0),
            (this.r = 1),
            (this.g = 1),
            (this.b = 1),
            this.set(t, e, n)
          );
        }
        set(t, e, n) {
          if (void 0 === e && void 0 === n) {
            const e = t;
            e && e.isColor
              ? this.copy(e)
              : "number" == typeof e
              ? this.setHex(e)
              : "string" == typeof e && this.setStyle(e);
          } else this.setRGB(t, e, n);
          return this;
        }
        setScalar(t) {
          return (this.r = t), (this.g = t), (this.b = t), this;
        }
        setHex(t, e = Pd) {
          return (
            (t = Math.floor(t)),
            (this.r = ((t >> 16) & 255) / 255),
            (this.g = ((t >> 8) & 255) / 255),
            (this.b = (255 & t) / 255),
            dp.toWorkingColorSpace(this, e),
            this
          );
        }
        setRGB(t, e, n, i = dp.workingColorSpace) {
          return (
            (this.r = t),
            (this.g = e),
            (this.b = n),
            dp.toWorkingColorSpace(this, i),
            this
          );
        }
        setHSL(t, e, n, i = dp.workingColorSpace) {
          if (
            ((t = (function (t, e) {
              return ((t % e) + e) % e;
            })(t, 1)),
            (e = Yd(e, 0, 1)),
            (n = Yd(n, 0, 1)),
            0 === e)
          )
            this.r = this.g = this.b = n;
          else {
            const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
              r = 2 * n - i;
            (this.r = Yf(r, i, t + 1 / 3)),
              (this.g = Yf(r, i, t)),
              (this.b = Yf(r, i, t - 1 / 3));
          }
          return dp.toWorkingColorSpace(this, i), this;
        }
        setStyle(t, e = Pd) {
          function n(e) {
            void 0 !== e &&
              parseFloat(e) < 1 &&
              console.warn(
                "THREE.Color: Alpha component of " + t + " will be ignored."
              );
          }
          let i;
          if ((i = /^(\w+)\(([^\)]*)\)/.exec(t))) {
            let r;
            const s = i[1],
              o = i[2];
            switch (s) {
              case "rgb":
              case "rgba":
                if (
                  (r =
                    /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      o
                    ))
                )
                  return (
                    n(r[4]),
                    this.setRGB(
                      Math.min(255, parseInt(r[1], 10)) / 255,
                      Math.min(255, parseInt(r[2], 10)) / 255,
                      Math.min(255, parseInt(r[3], 10)) / 255,
                      e
                    )
                  );
                if (
                  (r =
                    /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      o
                    ))
                )
                  return (
                    n(r[4]),
                    this.setRGB(
                      Math.min(100, parseInt(r[1], 10)) / 100,
                      Math.min(100, parseInt(r[2], 10)) / 100,
                      Math.min(100, parseInt(r[3], 10)) / 100,
                      e
                    )
                  );
                break;
              case "hsl":
              case "hsla":
                if (
                  (r =
                    /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      o
                    ))
                )
                  return (
                    n(r[4]),
                    this.setHSL(
                      parseFloat(r[1]) / 360,
                      parseFloat(r[2]) / 100,
                      parseFloat(r[3]) / 100,
                      e
                    )
                  );
                break;
              default:
                console.warn("THREE.Color: Unknown color model " + t);
            }
          } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(t))) {
            const n = i[1],
              r = n.length;
            if (3 === r)
              return this.setRGB(
                parseInt(n.charAt(0), 16) / 15,
                parseInt(n.charAt(1), 16) / 15,
                parseInt(n.charAt(2), 16) / 15,
                e
              );
            if (6 === r) return this.setHex(parseInt(n, 16), e);
            console.warn("THREE.Color: Invalid hex color " + t);
          } else if (t && t.length > 0) return this.setColorName(t, e);
          return this;
        }
        setColorName(t, e = Pd) {
          const n = jf[t.toLowerCase()];
          return (
            void 0 !== n
              ? this.setHex(n, e)
              : console.warn("THREE.Color: Unknown color " + t),
            this
          );
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(t) {
          return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
        }
        copySRGBToLinear(t) {
          return (
            (this.r = pp(t.r)), (this.g = pp(t.g)), (this.b = pp(t.b)), this
          );
        }
        copyLinearToSRGB(t) {
          return (
            (this.r = fp(t.r)), (this.g = fp(t.g)), (this.b = fp(t.b)), this
          );
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex(t = Pd) {
          return (
            dp.fromWorkingColorSpace(Zf.copy(this), t),
            65536 * Math.round(Yd(255 * Zf.r, 0, 255)) +
              256 * Math.round(Yd(255 * Zf.g, 0, 255)) +
              Math.round(Yd(255 * Zf.b, 0, 255))
          );
        }
        getHexString(t = Pd) {
          return ("000000" + this.getHex(t).toString(16)).slice(-6);
        }
        getHSL(t, e = dp.workingColorSpace) {
          dp.fromWorkingColorSpace(Zf.copy(this), e);
          const n = Zf.r,
            i = Zf.g,
            r = Zf.b,
            s = Math.max(n, i, r),
            o = Math.min(n, i, r);
          let a, l;
          const c = (o + s) / 2;
          if (o === s) (a = 0), (l = 0);
          else {
            const t = s - o;
            switch (((l = c <= 0.5 ? t / (s + o) : t / (2 - s - o)), s)) {
              case n:
                a = (i - r) / t + (i < r ? 6 : 0);
                break;
              case i:
                a = (r - n) / t + 2;
                break;
              case r:
                a = (n - i) / t + 4;
            }
            a /= 6;
          }
          return (t.h = a), (t.s = l), (t.l = c), t;
        }
        getRGB(t, e = dp.workingColorSpace) {
          return (
            dp.fromWorkingColorSpace(Zf.copy(this), e),
            (t.r = Zf.r),
            (t.g = Zf.g),
            (t.b = Zf.b),
            t
          );
        }
        getStyle(t = Pd) {
          dp.fromWorkingColorSpace(Zf.copy(this), t);
          const e = Zf.r,
            n = Zf.g,
            i = Zf.b;
          return t !== Pd
            ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`
            : `rgb(${Math.round(255 * e)},${Math.round(255 * n)},${Math.round(
                255 * i
              )})`;
        }
        offsetHSL(t, e, n) {
          return this.getHSL(Xf), this.setHSL(Xf.h + t, Xf.s + e, Xf.l + n);
        }
        add(t) {
          return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
        }
        addColors(t, e) {
          return (
            (this.r = t.r + e.r),
            (this.g = t.g + e.g),
            (this.b = t.b + e.b),
            this
          );
        }
        addScalar(t) {
          return (this.r += t), (this.g += t), (this.b += t), this;
        }
        sub(t) {
          return (
            (this.r = Math.max(0, this.r - t.r)),
            (this.g = Math.max(0, this.g - t.g)),
            (this.b = Math.max(0, this.b - t.b)),
            this
          );
        }
        multiply(t) {
          return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
        }
        multiplyScalar(t) {
          return (this.r *= t), (this.g *= t), (this.b *= t), this;
        }
        lerp(t, e) {
          return (
            (this.r += (t.r - this.r) * e),
            (this.g += (t.g - this.g) * e),
            (this.b += (t.b - this.b) * e),
            this
          );
        }
        lerpColors(t, e, n) {
          return (
            (this.r = t.r + (e.r - t.r) * n),
            (this.g = t.g + (e.g - t.g) * n),
            (this.b = t.b + (e.b - t.b) * n),
            this
          );
        }
        lerpHSL(t, e) {
          this.getHSL(Xf), t.getHSL(qf);
          const n = Kd(Xf.h, qf.h, e),
            i = Kd(Xf.s, qf.s, e),
            r = Kd(Xf.l, qf.l, e);
          return this.setHSL(n, i, r), this;
        }
        setFromVector3(t) {
          return (this.r = t.x), (this.g = t.y), (this.b = t.z), this;
        }
        applyMatrix3(t) {
          const e = this.r,
            n = this.g,
            i = this.b,
            r = t.elements;
          return (
            (this.r = r[0] * e + r[3] * n + r[6] * i),
            (this.g = r[1] * e + r[4] * n + r[7] * i),
            (this.b = r[2] * e + r[5] * n + r[8] * i),
            this
          );
        }
        equals(t) {
          return t.r === this.r && t.g === this.g && t.b === this.b;
        }
        fromArray(t, e = 0) {
          return (
            (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this
          );
        }
        toArray(t = [], e = 0) {
          return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
        }
        fromBufferAttribute(t, e) {
          return (
            (this.r = t.getX(e)),
            (this.g = t.getY(e)),
            (this.b = t.getZ(e)),
            this
          );
        }
        toJSON() {
          return this.getHex();
        }
        *[Symbol.iterator]() {
          yield this.r, yield this.g, yield this.b;
        }
      }
      const Zf = new Kf();
      Kf.NAMES = jf;
      class $f extends Wf {
        constructor(t) {
          super(),
            (this.isMeshBasicMaterial = !0),
            (this.type = "MeshBasicMaterial"),
            (this.color = new Kf(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.combine = Xh),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.fog = !0),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            this.color.copy(t.color),
            (this.map = t.map),
            (this.lightMap = t.lightMap),
            (this.lightMapIntensity = t.lightMapIntensity),
            (this.aoMap = t.aoMap),
            (this.aoMapIntensity = t.aoMapIntensity),
            (this.specularMap = t.specularMap),
            (this.alphaMap = t.alphaMap),
            (this.envMap = t.envMap),
            (this.combine = t.combine),
            (this.reflectivity = t.reflectivity),
            (this.refractionRatio = t.refractionRatio),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.wireframeLinecap = t.wireframeLinecap),
            (this.wireframeLinejoin = t.wireframeLinejoin),
            (this.fog = t.fog),
            this
          );
        }
      }
      const Jf = new Ap(),
        Qf = new tp();
      class tm {
        constructor(t, e, n = !1) {
          if (Array.isArray(t))
            throw new TypeError(
              "THREE.BufferAttribute: array should be a Typed Array."
            );
          (this.isBufferAttribute = !0),
            (this.name = ""),
            (this.array = t),
            (this.itemSize = e),
            (this.count = void 0 !== t ? t.length / e : 0),
            (this.normalized = n),
            (this.usage = 35044),
            (this.updateRange = {
              offset: 0,
              count: -1,
            }),
            (this.gpuType = fd),
            (this.version = 0);
        }
        onUploadCallback() {}
        set needsUpdate(t) {
          !0 === t && this.version++;
        }
        setUsage(t) {
          return (this.usage = t), this;
        }
        copy(t) {
          return (
            (this.name = t.name),
            (this.array = new t.array.constructor(t.array)),
            (this.itemSize = t.itemSize),
            (this.count = t.count),
            (this.normalized = t.normalized),
            (this.usage = t.usage),
            (this.gpuType = t.gpuType),
            this
          );
        }
        copyAt(t, e, n) {
          (t *= this.itemSize), (n *= e.itemSize);
          for (let i = 0, r = this.itemSize; i < r; i++)
            this.array[t + i] = e.array[n + i];
          return this;
        }
        copyArray(t) {
          return this.array.set(t), this;
        }
        applyMatrix3(t) {
          if (2 === this.itemSize)
            for (let e = 0, n = this.count; e < n; e++)
              Qf.fromBufferAttribute(this, e),
                Qf.applyMatrix3(t),
                this.setXY(e, Qf.x, Qf.y);
          else if (3 === this.itemSize)
            for (let e = 0, n = this.count; e < n; e++)
              Jf.fromBufferAttribute(this, e),
                Jf.applyMatrix3(t),
                this.setXYZ(e, Jf.x, Jf.y, Jf.z);
          return this;
        }
        applyMatrix4(t) {
          for (let e = 0, n = this.count; e < n; e++)
            Jf.fromBufferAttribute(this, e),
              Jf.applyMatrix4(t),
              this.setXYZ(e, Jf.x, Jf.y, Jf.z);
          return this;
        }
        applyNormalMatrix(t) {
          for (let e = 0, n = this.count; e < n; e++)
            Jf.fromBufferAttribute(this, e),
              Jf.applyNormalMatrix(t),
              this.setXYZ(e, Jf.x, Jf.y, Jf.z);
          return this;
        }
        transformDirection(t) {
          for (let e = 0, n = this.count; e < n; e++)
            Jf.fromBufferAttribute(this, e),
              Jf.transformDirection(t),
              this.setXYZ(e, Jf.x, Jf.y, Jf.z);
          return this;
        }
        set(t, e = 0) {
          return this.array.set(t, e), this;
        }
        getComponent(t, e) {
          let n = this.array[t * this.itemSize + e];
          return this.normalized && (n = Jd(n, this.array)), n;
        }
        setComponent(t, e, n) {
          return (
            this.normalized && (n = Qd(n, this.array)),
            (this.array[t * this.itemSize + e] = n),
            this
          );
        }
        getX(t) {
          let e = this.array[t * this.itemSize];
          return this.normalized && (e = Jd(e, this.array)), e;
        }
        setX(t, e) {
          return (
            this.normalized && (e = Qd(e, this.array)),
            (this.array[t * this.itemSize] = e),
            this
          );
        }
        getY(t) {
          let e = this.array[t * this.itemSize + 1];
          return this.normalized && (e = Jd(e, this.array)), e;
        }
        setY(t, e) {
          return (
            this.normalized && (e = Qd(e, this.array)),
            (this.array[t * this.itemSize + 1] = e),
            this
          );
        }
        getZ(t) {
          let e = this.array[t * this.itemSize + 2];
          return this.normalized && (e = Jd(e, this.array)), e;
        }
        setZ(t, e) {
          return (
            this.normalized && (e = Qd(e, this.array)),
            (this.array[t * this.itemSize + 2] = e),
            this
          );
        }
        getW(t) {
          let e = this.array[t * this.itemSize + 3];
          return this.normalized && (e = Jd(e, this.array)), e;
        }
        setW(t, e) {
          return (
            this.normalized && (e = Qd(e, this.array)),
            (this.array[t * this.itemSize + 3] = e),
            this
          );
        }
        setXY(t, e, n) {
          return (
            (t *= this.itemSize),
            this.normalized &&
              ((e = Qd(e, this.array)), (n = Qd(n, this.array))),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            this
          );
        }
        setXYZ(t, e, n, i) {
          return (
            (t *= this.itemSize),
            this.normalized &&
              ((e = Qd(e, this.array)),
              (n = Qd(n, this.array)),
              (i = Qd(i, this.array))),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            (this.array[t + 2] = i),
            this
          );
        }
        setXYZW(t, e, n, i, r) {
          return (
            (t *= this.itemSize),
            this.normalized &&
              ((e = Qd(e, this.array)),
              (n = Qd(n, this.array)),
              (i = Qd(i, this.array)),
              (r = Qd(r, this.array))),
            (this.array[t + 0] = e),
            (this.array[t + 1] = n),
            (this.array[t + 2] = i),
            (this.array[t + 3] = r),
            this
          );
        }
        onUpload(t) {
          return (this.onUploadCallback = t), this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const t = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized,
          };
          return (
            "" !== this.name && (t.name = this.name),
            35044 !== this.usage && (t.usage = this.usage),
            (0 === this.updateRange.offset && -1 === this.updateRange.count) ||
              (t.updateRange = this.updateRange),
            t
          );
        }
      }
      class em extends tm {
        constructor(t, e, n) {
          super(new Uint16Array(t), e, n);
        }
      }
      class nm extends tm {
        constructor(t, e, n) {
          super(new Uint32Array(t), e, n);
        }
      }
      class im extends tm {
        constructor(t, e, n) {
          super(new Float32Array(t), e, n);
        }
      }
      let rm = 0;
      const sm = new sf(),
        om = new Pf(),
        am = new Ap(),
        lm = new Rp(),
        cm = new Rp(),
        um = new Ap();
      class hm extends Gd {
        constructor() {
          super(),
            (this.isBufferGeometry = !0),
            Object.defineProperty(this, "id", {
              value: rm++,
            }),
            (this.uuid = qd()),
            (this.name = ""),
            (this.type = "BufferGeometry"),
            (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.morphTargetsRelative = !1),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.drawRange = {
              start: 0,
              count: 1 / 0,
            }),
            (this.userData = {});
        }
        getIndex() {
          return this.index;
        }
        setIndex(t) {
          return (
            Array.isArray(t)
              ? (this.index = new (ip(t) ? nm : em)(t, 1))
              : (this.index = t),
            this
          );
        }
        getAttribute(t) {
          return this.attributes[t];
        }
        setAttribute(t, e) {
          return (this.attributes[t] = e), this;
        }
        deleteAttribute(t) {
          return delete this.attributes[t], this;
        }
        hasAttribute(t) {
          return void 0 !== this.attributes[t];
        }
        addGroup(t, e, n = 0) {
          this.groups.push({
            start: t,
            count: e,
            materialIndex: n,
          });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(t, e) {
          (this.drawRange.start = t), (this.drawRange.count = e);
        }
        applyMatrix4(t) {
          const e = this.attributes.position;
          void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
          const n = this.attributes.normal;
          if (void 0 !== n) {
            const e = new ep().getNormalMatrix(t);
            n.applyNormalMatrix(e), (n.needsUpdate = !0);
          }
          const i = this.attributes.tangent;
          return (
            void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
          );
        }
        applyQuaternion(t) {
          return sm.makeRotationFromQuaternion(t), this.applyMatrix4(sm), this;
        }
        rotateX(t) {
          return sm.makeRotationX(t), this.applyMatrix4(sm), this;
        }
        rotateY(t) {
          return sm.makeRotationY(t), this.applyMatrix4(sm), this;
        }
        rotateZ(t) {
          return sm.makeRotationZ(t), this.applyMatrix4(sm), this;
        }
        translate(t, e, n) {
          return sm.makeTranslation(t, e, n), this.applyMatrix4(sm), this;
        }
        scale(t, e, n) {
          return sm.makeScale(t, e, n), this.applyMatrix4(sm), this;
        }
        lookAt(t) {
          return (
            om.lookAt(t), om.updateMatrix(), this.applyMatrix4(om.matrix), this
          );
        }
        center() {
          return (
            this.computeBoundingBox(),
            this.boundingBox.getCenter(am).negate(),
            this.translate(am.x, am.y, am.z),
            this
          );
        }
        setFromPoints(t) {
          const e = [];
          for (let n = 0, i = t.length; n < i; n++) {
            const i = t[n];
            e.push(i.x, i.y, i.z || 0);
          }
          return this.setAttribute("position", new im(e, 3)), this;
        }
        computeBoundingBox() {
          null === this.boundingBox && (this.boundingBox = new Rp());
          const t = this.attributes.position,
            e = this.morphAttributes.position;
          if (t && t.isGLBufferAttribute)
            return (
              console.error(
                'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                this
              ),
              void this.boundingBox.set(
                new Ap(-1 / 0, -1 / 0, -1 / 0),
                new Ap(1 / 0, 1 / 0, 1 / 0)
              )
            );
          if (void 0 !== t) {
            if ((this.boundingBox.setFromBufferAttribute(t), e))
              for (let t = 0, n = e.length; t < n; t++) {
                const n = e[t];
                lm.setFromBufferAttribute(n),
                  this.morphTargetsRelative
                    ? (um.addVectors(this.boundingBox.min, lm.min),
                      this.boundingBox.expandByPoint(um),
                      um.addVectors(this.boundingBox.max, lm.max),
                      this.boundingBox.expandByPoint(um))
                    : (this.boundingBox.expandByPoint(lm.min),
                      this.boundingBox.expandByPoint(lm.max));
              }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) ||
            isNaN(this.boundingBox.min.y) ||
            isNaN(this.boundingBox.min.z)) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
              this
            );
        }
        computeBoundingSphere() {
          null === this.boundingSphere && (this.boundingSphere = new Kp());
          const t = this.attributes.position,
            e = this.morphAttributes.position;
          if (t && t.isGLBufferAttribute)
            return (
              console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                this
              ),
              void this.boundingSphere.set(new Ap(), 1 / 0)
            );
          if (t) {
            const n = this.boundingSphere.center;
            if ((lm.setFromBufferAttribute(t), e))
              for (let t = 0, n = e.length; t < n; t++) {
                const n = e[t];
                cm.setFromBufferAttribute(n),
                  this.morphTargetsRelative
                    ? (um.addVectors(lm.min, cm.min),
                      lm.expandByPoint(um),
                      um.addVectors(lm.max, cm.max),
                      lm.expandByPoint(um))
                    : (lm.expandByPoint(cm.min), lm.expandByPoint(cm.max));
              }
            lm.getCenter(n);
            let i = 0;
            for (let e = 0, r = t.count; e < r; e++)
              um.fromBufferAttribute(t, e),
                (i = Math.max(i, n.distanceToSquared(um)));
            if (e)
              for (let r = 0, s = e.length; r < s; r++) {
                const s = e[r],
                  o = this.morphTargetsRelative;
                for (let e = 0, r = s.count; e < r; e++)
                  um.fromBufferAttribute(s, e),
                    o && (am.fromBufferAttribute(t, e), um.add(am)),
                    (i = Math.max(i, n.distanceToSquared(um)));
              }
            (this.boundingSphere.radius = Math.sqrt(i)),
              isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                );
          }
        }
        computeTangents() {
          const t = this.index,
            e = this.attributes;
          if (
            null === t ||
            void 0 === e.position ||
            void 0 === e.normal ||
            void 0 === e.uv
          )
            return void console.error(
              "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
            );
          const n = t.array,
            i = e.position.array,
            r = e.normal.array,
            s = e.uv.array,
            o = i.length / 3;
          !1 === this.hasAttribute("tangent") &&
            this.setAttribute("tangent", new tm(new Float32Array(4 * o), 4));
          const a = this.getAttribute("tangent").array,
            l = [],
            c = [];
          for (let t = 0; t < o; t++) (l[t] = new Ap()), (c[t] = new Ap());
          const u = new Ap(),
            h = new Ap(),
            d = new Ap(),
            p = new tp(),
            f = new tp(),
            m = new tp(),
            g = new Ap(),
            v = new Ap();
          function _(t, e, n) {
            u.fromArray(i, 3 * t),
              h.fromArray(i, 3 * e),
              d.fromArray(i, 3 * n),
              p.fromArray(s, 2 * t),
              f.fromArray(s, 2 * e),
              m.fromArray(s, 2 * n),
              h.sub(u),
              d.sub(u),
              f.sub(p),
              m.sub(p);
            const r = 1 / (f.x * m.y - m.x * f.y);
            isFinite(r) &&
              (g
                .copy(h)
                .multiplyScalar(m.y)
                .addScaledVector(d, -f.y)
                .multiplyScalar(r),
              v
                .copy(d)
                .multiplyScalar(f.x)
                .addScaledVector(h, -m.x)
                .multiplyScalar(r),
              l[t].add(g),
              l[e].add(g),
              l[n].add(g),
              c[t].add(v),
              c[e].add(v),
              c[n].add(v));
          }
          let y = this.groups;
          0 === y.length &&
            (y = [
              {
                start: 0,
                count: n.length,
              },
            ]);
          for (let t = 0, e = y.length; t < e; ++t) {
            const e = y[t],
              i = e.start;
            for (let t = i, r = i + e.count; t < r; t += 3)
              _(n[t + 0], n[t + 1], n[t + 2]);
          }
          const x = new Ap(),
            b = new Ap(),
            S = new Ap(),
            E = new Ap();
          function T(t) {
            S.fromArray(r, 3 * t), E.copy(S);
            const e = l[t];
            x.copy(e),
              x.sub(S.multiplyScalar(S.dot(e))).normalize(),
              b.crossVectors(E, e);
            const n = b.dot(c[t]) < 0 ? -1 : 1;
            (a[4 * t] = x.x),
              (a[4 * t + 1] = x.y),
              (a[4 * t + 2] = x.z),
              (a[4 * t + 3] = n);
          }
          for (let t = 0, e = y.length; t < e; ++t) {
            const e = y[t],
              i = e.start;
            for (let t = i, r = i + e.count; t < r; t += 3)
              T(n[t + 0]), T(n[t + 1]), T(n[t + 2]);
          }
        }
        computeVertexNormals() {
          const t = this.index,
            e = this.getAttribute("position");
          if (void 0 !== e) {
            let n = this.getAttribute("normal");
            if (void 0 === n)
              (n = new tm(new Float32Array(3 * e.count), 3)),
                this.setAttribute("normal", n);
            else for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
            const i = new Ap(),
              r = new Ap(),
              s = new Ap(),
              o = new Ap(),
              a = new Ap(),
              l = new Ap(),
              c = new Ap(),
              u = new Ap();
            if (t)
              for (let h = 0, d = t.count; h < d; h += 3) {
                const d = t.getX(h + 0),
                  p = t.getX(h + 1),
                  f = t.getX(h + 2);
                i.fromBufferAttribute(e, d),
                  r.fromBufferAttribute(e, p),
                  s.fromBufferAttribute(e, f),
                  c.subVectors(s, r),
                  u.subVectors(i, r),
                  c.cross(u),
                  o.fromBufferAttribute(n, d),
                  a.fromBufferAttribute(n, p),
                  l.fromBufferAttribute(n, f),
                  o.add(c),
                  a.add(c),
                  l.add(c),
                  n.setXYZ(d, o.x, o.y, o.z),
                  n.setXYZ(p, a.x, a.y, a.z),
                  n.setXYZ(f, l.x, l.y, l.z);
              }
            else
              for (let t = 0, o = e.count; t < o; t += 3)
                i.fromBufferAttribute(e, t + 0),
                  r.fromBufferAttribute(e, t + 1),
                  s.fromBufferAttribute(e, t + 2),
                  c.subVectors(s, r),
                  u.subVectors(i, r),
                  c.cross(u),
                  n.setXYZ(t + 0, c.x, c.y, c.z),
                  n.setXYZ(t + 1, c.x, c.y, c.z),
                  n.setXYZ(t + 2, c.x, c.y, c.z);
            this.normalizeNormals(), (n.needsUpdate = !0);
          }
        }
        normalizeNormals() {
          const t = this.attributes.normal;
          for (let e = 0, n = t.count; e < n; e++)
            um.fromBufferAttribute(t, e),
              um.normalize(),
              t.setXYZ(e, um.x, um.y, um.z);
        }
        toNonIndexed() {
          function t(t, e) {
            const n = t.array,
              i = t.itemSize,
              r = t.normalized,
              s = new n.constructor(e.length * i);
            let o = 0,
              a = 0;
            for (let r = 0, l = e.length; r < l; r++) {
              o = t.isInterleavedBufferAttribute
                ? e[r] * t.data.stride + t.offset
                : e[r] * i;
              for (let t = 0; t < i; t++) s[a++] = n[o++];
            }
            return new tm(s, i, r);
          }
          if (null === this.index)
            return (
              console.warn(
                "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
              ),
              this
            );
          const e = new hm(),
            n = this.index.array,
            i = this.attributes;
          for (const r in i) {
            const s = t(i[r], n);
            e.setAttribute(r, s);
          }
          const r = this.morphAttributes;
          for (const i in r) {
            const s = [],
              o = r[i];
            for (let e = 0, i = o.length; e < i; e++) {
              const i = t(o[e], n);
              s.push(i);
            }
            e.morphAttributes[i] = s;
          }
          e.morphTargetsRelative = this.morphTargetsRelative;
          const s = this.groups;
          for (let t = 0, n = s.length; t < n; t++) {
            const n = s[t];
            e.addGroup(n.start, n.count, n.materialIndex);
          }
          return e;
        }
        toJSON() {
          const t = {
            metadata: {
              version: 4.6,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON",
            },
          };
          if (
            ((t.uuid = this.uuid),
            (t.type = this.type),
            "" !== this.name && (t.name = this.name),
            Object.keys(this.userData).length > 0 &&
              (t.userData = this.userData),
            void 0 !== this.parameters)
          ) {
            const e = this.parameters;
            for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
            return t;
          }
          t.data = {
            attributes: {},
          };
          const e = this.index;
          null !== e &&
            (t.data.index = {
              type: e.array.constructor.name,
              array: Array.prototype.slice.call(e.array),
            });
          const n = this.attributes;
          for (const e in n) {
            const i = n[e];
            t.data.attributes[e] = i.toJSON(t.data);
          }
          const i = {};
          let r = !1;
          for (const e in this.morphAttributes) {
            const n = this.morphAttributes[e],
              s = [];
            for (let e = 0, i = n.length; e < i; e++) {
              const i = n[e];
              s.push(i.toJSON(t.data));
            }
            s.length > 0 && ((i[e] = s), (r = !0));
          }
          r &&
            ((t.data.morphAttributes = i),
            (t.data.morphTargetsRelative = this.morphTargetsRelative));
          const s = this.groups;
          s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
          const o = this.boundingSphere;
          return (
            null !== o &&
              (t.data.boundingSphere = {
                center: o.center.toArray(),
                radius: o.radius,
              }),
            t
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(t) {
          (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null);
          const e = {};
          this.name = t.name;
          const n = t.index;
          null !== n && this.setIndex(n.clone(e));
          const i = t.attributes;
          for (const t in i) {
            const n = i[t];
            this.setAttribute(t, n.clone(e));
          }
          const r = t.morphAttributes;
          for (const t in r) {
            const n = [],
              i = r[t];
            for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
            this.morphAttributes[t] = n;
          }
          this.morphTargetsRelative = t.morphTargetsRelative;
          const s = t.groups;
          for (let t = 0, e = s.length; t < e; t++) {
            const e = s[t];
            this.addGroup(e.start, e.count, e.materialIndex);
          }
          const o = t.boundingBox;
          null !== o && (this.boundingBox = o.clone());
          const a = t.boundingSphere;
          return (
            null !== a && (this.boundingSphere = a.clone()),
            (this.drawRange.start = t.drawRange.start),
            (this.drawRange.count = t.drawRange.count),
            (this.userData = t.userData),
            this
          );
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose",
          });
        }
      }
      const dm = new sf(),
        pm = new rf(),
        fm = new Kp(),
        mm = new Ap(),
        gm = new Ap(),
        vm = new Ap(),
        _m = new Ap(),
        ym = new Ap(),
        xm = new Ap(),
        bm = new tp(),
        Sm = new tp(),
        Em = new tp(),
        Tm = new Ap(),
        Mm = new Ap(),
        wm = new Ap(),
        Dm = new Ap(),
        Am = new Ap();
      class Cm extends Pf {
        constructor(t = new hm(), e = new $f()) {
          super(),
            (this.isMesh = !0),
            (this.type = "Mesh"),
            (this.geometry = t),
            (this.material = e),
            this.updateMorphTargets();
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            void 0 !== t.morphTargetInfluences &&
              (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
            void 0 !== t.morphTargetDictionary &&
              (this.morphTargetDictionary = Object.assign(
                {},
                t.morphTargetDictionary
              )),
            (this.material = Array.isArray(t.material)
              ? t.material.slice()
              : t.material),
            (this.geometry = t.geometry),
            this
          );
        }
        updateMorphTargets() {
          const t = this.geometry.morphAttributes,
            e = Object.keys(t);
          if (e.length > 0) {
            const n = t[e[0]];
            if (void 0 !== n) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let t = 0, e = n.length; t < e; t++) {
                const e = n[t].name || String(t);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[e] = t);
              }
            }
          }
        }
        getVertexPosition(t, e) {
          const n = this.geometry,
            i = n.attributes.position,
            r = n.morphAttributes.position,
            s = n.morphTargetsRelative;
          e.fromBufferAttribute(i, t);
          const o = this.morphTargetInfluences;
          if (r && o) {
            xm.set(0, 0, 0);
            for (let n = 0, i = r.length; n < i; n++) {
              const i = o[n],
                a = r[n];
              0 !== i &&
                (ym.fromBufferAttribute(a, t),
                s
                  ? xm.addScaledVector(ym, i)
                  : xm.addScaledVector(ym.sub(e), i));
            }
            e.add(xm);
          }
          return e;
        }
        raycast(t, e) {
          const n = this.geometry,
            i = this.material,
            r = this.matrixWorld;
          if (void 0 !== i) {
            if (
              (null === n.boundingSphere && n.computeBoundingSphere(),
              fm.copy(n.boundingSphere),
              fm.applyMatrix4(r),
              pm.copy(t.ray).recast(t.near),
              !1 === fm.containsPoint(pm.origin))
            ) {
              if (null === pm.intersectSphere(fm, mm)) return;
              if (pm.origin.distanceToSquared(mm) > (t.far - t.near) ** 2)
                return;
            }
            dm.copy(r).invert(),
              pm.copy(t.ray).applyMatrix4(dm),
              (null !== n.boundingBox &&
                !1 === pm.intersectsBox(n.boundingBox)) ||
                this._computeIntersections(t, e, pm);
          }
        }
        _computeIntersections(t, e, n) {
          let i;
          const r = this.geometry,
            s = this.material,
            o = r.index,
            a = r.attributes.position,
            l = r.attributes.uv,
            c = r.attributes.uv1,
            u = r.attributes.normal,
            h = r.groups,
            d = r.drawRange;
          if (null !== o)
            if (Array.isArray(s))
              for (let r = 0, a = h.length; r < a; r++) {
                const a = h[r],
                  p = s[a.materialIndex];
                for (
                  let r = Math.max(a.start, d.start),
                    s = Math.min(
                      o.count,
                      Math.min(a.start + a.count, d.start + d.count)
                    );
                  r < s;
                  r += 3
                )
                  (i = Pm(
                    this,
                    p,
                    t,
                    n,
                    l,
                    c,
                    u,
                    o.getX(r),
                    o.getX(r + 1),
                    o.getX(r + 2)
                  )),
                    i &&
                      ((i.faceIndex = Math.floor(r / 3)),
                      (i.face.materialIndex = a.materialIndex),
                      e.push(i));
              }
            else
              for (
                let r = Math.max(0, d.start),
                  a = Math.min(o.count, d.start + d.count);
                r < a;
                r += 3
              )
                (i = Pm(
                  this,
                  s,
                  t,
                  n,
                  l,
                  c,
                  u,
                  o.getX(r),
                  o.getX(r + 1),
                  o.getX(r + 2)
                )),
                  i && ((i.faceIndex = Math.floor(r / 3)), e.push(i));
          else if (void 0 !== a)
            if (Array.isArray(s))
              for (let r = 0, o = h.length; r < o; r++) {
                const o = h[r],
                  p = s[o.materialIndex];
                for (
                  let r = Math.max(o.start, d.start),
                    s = Math.min(
                      a.count,
                      Math.min(o.start + o.count, d.start + d.count)
                    );
                  r < s;
                  r += 3
                )
                  (i = Pm(this, p, t, n, l, c, u, r, r + 1, r + 2)),
                    i &&
                      ((i.faceIndex = Math.floor(r / 3)),
                      (i.face.materialIndex = o.materialIndex),
                      e.push(i));
              }
            else
              for (
                let r = Math.max(0, d.start),
                  o = Math.min(a.count, d.start + d.count);
                r < o;
                r += 3
              )
                (i = Pm(this, s, t, n, l, c, u, r, r + 1, r + 2)),
                  i && ((i.faceIndex = Math.floor(r / 3)), e.push(i));
        }
      }
      function Pm(t, e, n, i, r, s, o, a, l, c) {
        t.getVertexPosition(a, gm),
          t.getVertexPosition(l, vm),
          t.getVertexPosition(c, _m);
        const u = (function (t, e, n, i, r, s, o, a) {
          let l;
          if (
            ((l =
              1 === e.side
                ? i.intersectTriangle(o, s, r, !0, a)
                : i.intersectTriangle(r, s, o, 0 === e.side, a)),
            null === l)
          )
            return null;
          Am.copy(a), Am.applyMatrix4(t.matrixWorld);
          const c = n.ray.origin.distanceTo(Am);
          return c < n.near || c > n.far
            ? null
            : {
                distance: c,
                point: Am.clone(),
                object: t,
              };
        })(t, e, n, i, gm, vm, _m, Dm);
        if (u) {
          r &&
            (bm.fromBufferAttribute(r, a),
            Sm.fromBufferAttribute(r, l),
            Em.fromBufferAttribute(r, c),
            (u.uv = Vf.getInterpolation(Dm, gm, vm, _m, bm, Sm, Em, new tp()))),
            s &&
              (bm.fromBufferAttribute(s, a),
              Sm.fromBufferAttribute(s, l),
              Em.fromBufferAttribute(s, c),
              (u.uv1 = Vf.getInterpolation(
                Dm,
                gm,
                vm,
                _m,
                bm,
                Sm,
                Em,
                new tp()
              )),
              (u.uv2 = u.uv1)),
            o &&
              (Tm.fromBufferAttribute(o, a),
              Mm.fromBufferAttribute(o, l),
              wm.fromBufferAttribute(o, c),
              (u.normal = Vf.getInterpolation(
                Dm,
                gm,
                vm,
                _m,
                Tm,
                Mm,
                wm,
                new Ap()
              )),
              u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
          const t = {
            a: a,
            b: l,
            c: c,
            normal: new Ap(),
            materialIndex: 0,
          };
          Vf.getNormal(gm, vm, _m, t.normal), (u.face = t);
        }
        return u;
      }
      class Rm extends hm {
        constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
          super(),
            (this.type = "BoxGeometry"),
            (this.parameters = {
              width: t,
              height: e,
              depth: n,
              widthSegments: i,
              heightSegments: r,
              depthSegments: s,
            });
          const o = this;
          (i = Math.floor(i)), (r = Math.floor(r)), (s = Math.floor(s));
          const a = [],
            l = [],
            c = [],
            u = [];
          let h = 0,
            d = 0;
          function p(t, e, n, i, r, s, p, f, m, g, v) {
            const _ = s / m,
              y = p / g,
              x = s / 2,
              b = p / 2,
              S = f / 2,
              E = m + 1,
              T = g + 1;
            let M = 0,
              w = 0;
            const D = new Ap();
            for (let s = 0; s < T; s++) {
              const o = s * y - b;
              for (let a = 0; a < E; a++) {
                const h = a * _ - x;
                (D[t] = h * i),
                  (D[e] = o * r),
                  (D[n] = S),
                  l.push(D.x, D.y, D.z),
                  (D[t] = 0),
                  (D[e] = 0),
                  (D[n] = f > 0 ? 1 : -1),
                  c.push(D.x, D.y, D.z),
                  u.push(a / m),
                  u.push(1 - s / g),
                  (M += 1);
              }
            }
            for (let t = 0; t < g; t++)
              for (let e = 0; e < m; e++) {
                const n = h + e + E * t,
                  i = h + e + E * (t + 1),
                  r = h + (e + 1) + E * (t + 1),
                  s = h + (e + 1) + E * t;
                a.push(n, i, s), a.push(i, r, s), (w += 6);
              }
            o.addGroup(d, w, v), (d += w), (h += M);
          }
          p("z", "y", "x", -1, -1, n, e, t, s, r, 0),
            p("z", "y", "x", 1, -1, n, e, -t, s, r, 1),
            p("x", "z", "y", 1, 1, t, n, e, i, s, 2),
            p("x", "z", "y", 1, -1, t, n, -e, i, s, 3),
            p("x", "y", "z", 1, -1, t, e, n, i, r, 4),
            p("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
            this.setIndex(a),
            this.setAttribute("position", new im(l, 3)),
            this.setAttribute("normal", new im(c, 3)),
            this.setAttribute("uv", new im(u, 2));
        }
        copy(t) {
          return (
            super.copy(t),
            (this.parameters = Object.assign({}, t.parameters)),
            this
          );
        }
        static fromJSON(t) {
          return new Rm(
            t.width,
            t.height,
            t.depth,
            t.widthSegments,
            t.heightSegments,
            t.depthSegments
          );
        }
      }
      function Lm(t) {
        const e = {};
        for (const n in t) {
          e[n] = {};
          for (const i in t[n]) {
            const r = t[n][i];
            r &&
            (r.isColor ||
              r.isMatrix3 ||
              r.isMatrix4 ||
              r.isVector2 ||
              r.isVector3 ||
              r.isVector4 ||
              r.isTexture ||
              r.isQuaternion)
              ? r.isRenderTargetTexture
                ? (console.warn(
                    "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
                  ),
                  (e[n][i] = null))
                : (e[n][i] = r.clone())
              : Array.isArray(r)
              ? (e[n][i] = r.slice())
              : (e[n][i] = r);
          }
        }
        return e;
      }
      function Om(t) {
        const e = {};
        for (let n = 0; n < t.length; n++) {
          const i = Lm(t[n]);
          for (const t in i) e[t] = i[t];
        }
        return e;
      }
      function Im(t) {
        return null === t.getRenderTarget()
          ? t.outputColorSpace
          : dp.workingColorSpace;
      }
      const Fm = {
        clone: Lm,
        merge: Om,
      };
      class Nm extends Wf {
        constructor(t) {
          super(),
            (this.isShaderMaterial = !0),
            (this.type = "ShaderMaterial"),
            (this.defines = {}),
            (this.uniforms = {}),
            (this.uniformsGroups = []),
            (this.vertexShader =
              "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
            (this.fragmentShader =
              "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
            (this.linewidth = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.lights = !1),
            (this.clipping = !1),
            (this.forceSinglePass = !0),
            (this.extensions = {
              derivatives: !1,
              fragDepth: !1,
              drawBuffers: !1,
              shaderTextureLOD: !1,
            }),
            (this.defaultAttributeValues = {
              color: [1, 1, 1],
              uv: [0, 0],
              uv1: [0, 0],
            }),
            (this.index0AttributeName = void 0),
            (this.uniformsNeedUpdate = !1),
            (this.glslVersion = null),
            void 0 !== t && this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.fragmentShader = t.fragmentShader),
            (this.vertexShader = t.vertexShader),
            (this.uniforms = Lm(t.uniforms)),
            (this.uniformsGroups = (function (t) {
              const e = [];
              for (let n = 0; n < t.length; n++) e.push(t[n].clone());
              return e;
            })(t.uniformsGroups)),
            (this.defines = Object.assign({}, t.defines)),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            (this.fog = t.fog),
            (this.lights = t.lights),
            (this.clipping = t.clipping),
            (this.extensions = Object.assign({}, t.extensions)),
            (this.glslVersion = t.glslVersion),
            this
          );
        }
        toJSON(t) {
          const e = super.toJSON(t);
          (e.glslVersion = this.glslVersion), (e.uniforms = {});
          for (const n in this.uniforms) {
            const i = this.uniforms[n].value;
            i && i.isTexture
              ? (e.uniforms[n] = {
                  type: "t",
                  value: i.toJSON(t).uuid,
                })
              : i && i.isColor
              ? (e.uniforms[n] = {
                  type: "c",
                  value: i.getHex(),
                })
              : i && i.isVector2
              ? (e.uniforms[n] = {
                  type: "v2",
                  value: i.toArray(),
                })
              : i && i.isVector3
              ? (e.uniforms[n] = {
                  type: "v3",
                  value: i.toArray(),
                })
              : i && i.isVector4
              ? (e.uniforms[n] = {
                  type: "v4",
                  value: i.toArray(),
                })
              : i && i.isMatrix3
              ? (e.uniforms[n] = {
                  type: "m3",
                  value: i.toArray(),
                })
              : i && i.isMatrix4
              ? (e.uniforms[n] = {
                  type: "m4",
                  value: i.toArray(),
                })
              : (e.uniforms[n] = {
                  value: i,
                });
          }
          Object.keys(this.defines).length > 0 && (e.defines = this.defines),
            (e.vertexShader = this.vertexShader),
            (e.fragmentShader = this.fragmentShader),
            (e.lights = this.lights),
            (e.clipping = this.clipping);
          const n = {};
          for (const t in this.extensions)
            !0 === this.extensions[t] && (n[t] = !0);
          return Object.keys(n).length > 0 && (e.extensions = n), e;
        }
      }
      class Um extends Pf {
        constructor() {
          super(),
            (this.isCamera = !0),
            (this.type = "Camera"),
            (this.matrixWorldInverse = new sf()),
            (this.projectionMatrix = new sf()),
            (this.projectionMatrixInverse = new sf()),
            (this.coordinateSystem = Hd);
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            this.matrixWorldInverse.copy(t.matrixWorldInverse),
            this.projectionMatrix.copy(t.projectionMatrix),
            this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
            (this.coordinateSystem = t.coordinateSystem),
            this
          );
        }
        getWorldDirection(t) {
          return super.getWorldDirection(t).negate();
        }
        updateMatrixWorld(t) {
          super.updateMatrixWorld(t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(t, e) {
          super.updateWorldMatrix(t, e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class km extends Um {
        constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
          super(),
            (this.isPerspectiveCamera = !0),
            (this.type = "PerspectiveCamera"),
            (this.fov = t),
            (this.zoom = 1),
            (this.near = n),
            (this.far = i),
            (this.focus = 10),
            (this.aspect = e),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix();
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            (this.fov = t.fov),
            (this.zoom = t.zoom),
            (this.near = t.near),
            (this.far = t.far),
            (this.focus = t.focus),
            (this.aspect = t.aspect),
            (this.view = null === t.view ? null : Object.assign({}, t.view)),
            (this.filmGauge = t.filmGauge),
            (this.filmOffset = t.filmOffset),
            this
          );
        }
        setFocalLength(t) {
          const e = (0.5 * this.getFilmHeight()) / t;
          (this.fov = 2 * Xd * Math.atan(e)), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const t = Math.tan(0.5 * jd * this.fov);
          return (0.5 * this.getFilmHeight()) / t;
        }
        getEffectiveFOV() {
          return 2 * Xd * Math.atan(Math.tan(0.5 * jd * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        setViewOffset(t, e, n, i, r, s) {
          (this.aspect = t / e),
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
            (this.view.enabled = !0),
            (this.view.fullWidth = t),
            (this.view.fullHeight = e),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = s),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const t = this.near;
          let e = (t * Math.tan(0.5 * jd * this.fov)) / this.zoom,
            n = 2 * e,
            i = this.aspect * n,
            r = -0.5 * i;
          const s = this.view;
          if (null !== this.view && this.view.enabled) {
            const t = s.fullWidth,
              o = s.fullHeight;
            (r += (s.offsetX * i) / t),
              (e -= (s.offsetY * n) / o),
              (i *= s.width / t),
              (n *= s.height / o);
          }
          const o = this.filmOffset;
          0 !== o && (r += (t * o) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
              r,
              r + i,
              e,
              e - n,
              t,
              this.far,
              this.coordinateSystem
            ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (
            (e.object.fov = this.fov),
            (e.object.zoom = this.zoom),
            (e.object.near = this.near),
            (e.object.far = this.far),
            (e.object.focus = this.focus),
            (e.object.aspect = this.aspect),
            null !== this.view &&
              (e.object.view = Object.assign({}, this.view)),
            (e.object.filmGauge = this.filmGauge),
            (e.object.filmOffset = this.filmOffset),
            e
          );
        }
      }
      const zm = -90;
      class Bm extends Pf {
        constructor(t, e, n) {
          super(),
            (this.type = "CubeCamera"),
            (this.renderTarget = n),
            (this.coordinateSystem = null),
            (this.activeMipmapLevel = 0);
          const i = new km(zm, 1, t, e);
          (i.layers = this.layers), this.add(i);
          const r = new km(zm, 1, t, e);
          (r.layers = this.layers), this.add(r);
          const s = new km(zm, 1, t, e);
          (s.layers = this.layers), this.add(s);
          const o = new km(zm, 1, t, e);
          (o.layers = this.layers), this.add(o);
          const a = new km(zm, 1, t, e);
          (a.layers = this.layers), this.add(a);
          const l = new km(zm, 1, t, e);
          (l.layers = this.layers), this.add(l);
        }
        updateCoordinateSystem() {
          const t = this.coordinateSystem,
            e = this.children.concat(),
            [n, i, r, s, o, a] = e;
          for (const t of e) this.remove(t);
          if (t === Hd)
            n.up.set(0, 1, 0),
              n.lookAt(1, 0, 0),
              i.up.set(0, 1, 0),
              i.lookAt(-1, 0, 0),
              r.up.set(0, 0, -1),
              r.lookAt(0, 1, 0),
              s.up.set(0, 0, 1),
              s.lookAt(0, -1, 0),
              o.up.set(0, 1, 0),
              o.lookAt(0, 0, 1),
              a.up.set(0, 1, 0),
              a.lookAt(0, 0, -1);
          else {
            if (t !== Vd)
              throw new Error(
                "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
                  t
              );
            n.up.set(0, -1, 0),
              n.lookAt(-1, 0, 0),
              i.up.set(0, -1, 0),
              i.lookAt(1, 0, 0),
              r.up.set(0, 0, 1),
              r.lookAt(0, 1, 0),
              s.up.set(0, 0, -1),
              s.lookAt(0, -1, 0),
              o.up.set(0, -1, 0),
              o.lookAt(0, 0, 1),
              a.up.set(0, -1, 0),
              a.lookAt(0, 0, -1);
          }
          for (const t of e) this.add(t), t.updateMatrixWorld();
        }
        update(t, e) {
          null === this.parent && this.updateMatrixWorld();
          const { renderTarget: n, activeMipmapLevel: i } = this;
          this.coordinateSystem !== t.coordinateSystem &&
            ((this.coordinateSystem = t.coordinateSystem),
            this.updateCoordinateSystem());
          const [r, s, o, a, l, c] = this.children,
            u = t.getRenderTarget(),
            h = t.getActiveCubeFace(),
            d = t.getActiveMipmapLevel(),
            p = t.xr.enabled;
          t.xr.enabled = !1;
          const f = n.texture.generateMipmaps;
          (n.texture.generateMipmaps = !1),
            t.setRenderTarget(n, 0, i),
            t.render(e, r),
            t.setRenderTarget(n, 1, i),
            t.render(e, s),
            t.setRenderTarget(n, 2, i),
            t.render(e, o),
            t.setRenderTarget(n, 3, i),
            t.render(e, a),
            t.setRenderTarget(n, 4, i),
            t.render(e, l),
            (n.texture.generateMipmaps = f),
            t.setRenderTarget(n, 5, i),
            t.render(e, c),
            t.setRenderTarget(u, h, d),
            (t.xr.enabled = p),
            (n.texture.needsPMREMUpdate = !0);
        }
      }
      class Hm extends bp {
        constructor(t, e, n, i, r, s, o, a, l, c) {
          super(
            (t = void 0 !== t ? t : []),
            (e = void 0 !== e ? e : ed),
            n,
            i,
            r,
            s,
            o,
            a,
            l,
            c
          ),
            (this.isCubeTexture = !0),
            (this.flipY = !1);
        }
        get images() {
          return this.image;
        }
        set images(t) {
          this.image = t;
        }
      }
      class Vm extends Tp {
        constructor(t = 1, e = {}) {
          super(t, t, e), (this.isWebGLCubeRenderTarget = !0);
          const n = {
              width: t,
              height: t,
              depth: 1,
            },
            i = [n, n, n, n, n, n];
          void 0 !== e.encoding &&
            (ap(
              "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."
            ),
            (e.colorSpace = e.encoding === Ad ? Pd : Cd)),
            (this.texture = new Hm(
              i,
              e.mapping,
              e.wrapS,
              e.wrapT,
              e.magFilter,
              e.minFilter,
              e.format,
              e.type,
              e.anisotropy,
              e.colorSpace
            )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.generateMipmaps =
              void 0 !== e.generateMipmaps && e.generateMipmaps),
            (this.texture.minFilter =
              void 0 !== e.minFilter ? e.minFilter : cd);
        }
        fromEquirectangularTexture(t, e) {
          (this.texture.type = e.type),
            (this.texture.colorSpace = e.colorSpace),
            (this.texture.generateMipmaps = e.generateMipmaps),
            (this.texture.minFilter = e.minFilter),
            (this.texture.magFilter = e.magFilter);
          const n = {
              tEquirect: {
                value: null,
              },
            },
            i =
              "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
            r =
              "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
            s = new Rm(5, 5, 5),
            o = new Nm({
              name: "CubemapFromEquirect",
              uniforms: Lm(n),
              vertexShader: i,
              fragmentShader: r,
              side: 1,
              blending: 0,
            });
          o.uniforms.tEquirect.value = e;
          const a = new Cm(s, o),
            l = e.minFilter;
          return (
            e.minFilter === ud && (e.minFilter = cd),
            new Bm(1, 10, this).update(t, a),
            (e.minFilter = l),
            a.geometry.dispose(),
            a.material.dispose(),
            this
          );
        }
        clear(t, e, n, i) {
          const r = t.getRenderTarget();
          for (let r = 0; r < 6; r++)
            t.setRenderTarget(this, r), t.clear(e, n, i);
          t.setRenderTarget(r);
        }
      }
      const Gm = new Ap(),
        Wm = new Ap(),
        jm = new ep();
      class Xm {
        constructor(t = new Ap(1, 0, 0), e = 0) {
          (this.isPlane = !0), (this.normal = t), (this.constant = e);
        }
        set(t, e) {
          return this.normal.copy(t), (this.constant = e), this;
        }
        setComponents(t, e, n, i) {
          return this.normal.set(t, e, n), (this.constant = i), this;
        }
        setFromNormalAndCoplanarPoint(t, e) {
          return (
            this.normal.copy(t), (this.constant = -e.dot(this.normal)), this
          );
        }
        setFromCoplanarPoints(t, e, n) {
          const i = Gm.subVectors(n, e).cross(Wm.subVectors(t, e)).normalize();
          return this.setFromNormalAndCoplanarPoint(i, t), this;
        }
        copy(t) {
          return this.normal.copy(t.normal), (this.constant = t.constant), this;
        }
        normalize() {
          const t = 1 / this.normal.length();
          return this.normal.multiplyScalar(t), (this.constant *= t), this;
        }
        negate() {
          return (this.constant *= -1), this.normal.negate(), this;
        }
        distanceToPoint(t) {
          return this.normal.dot(t) + this.constant;
        }
        distanceToSphere(t) {
          return this.distanceToPoint(t.center) - t.radius;
        }
        projectPoint(t, e) {
          return e
            .copy(t)
            .addScaledVector(this.normal, -this.distanceToPoint(t));
        }
        intersectLine(t, e) {
          const n = t.delta(Gm),
            i = this.normal.dot(n);
          if (0 === i)
            return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
          const r = -(t.start.dot(this.normal) + this.constant) / i;
          return r < 0 || r > 1 ? null : e.copy(t.start).addScaledVector(n, r);
        }
        intersectsLine(t) {
          const e = this.distanceToPoint(t.start),
            n = this.distanceToPoint(t.end);
          return (e < 0 && n > 0) || (n < 0 && e > 0);
        }
        intersectsBox(t) {
          return t.intersectsPlane(this);
        }
        intersectsSphere(t) {
          return t.intersectsPlane(this);
        }
        coplanarPoint(t) {
          return t.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(t, e) {
          const n = e || jm.getNormalMatrix(t),
            i = this.coplanarPoint(Gm).applyMatrix4(t),
            r = this.normal.applyMatrix3(n).normalize();
          return (this.constant = -i.dot(r)), this;
        }
        translate(t) {
          return (this.constant -= t.dot(this.normal)), this;
        }
        equals(t) {
          return t.normal.equals(this.normal) && t.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const qm = new Kp(),
        Ym = new Ap();
      class Km {
        constructor(
          t = new Xm(),
          e = new Xm(),
          n = new Xm(),
          i = new Xm(),
          r = new Xm(),
          s = new Xm()
        ) {
          this.planes = [t, e, n, i, r, s];
        }
        set(t, e, n, i, r, s) {
          const o = this.planes;
          return (
            o[0].copy(t),
            o[1].copy(e),
            o[2].copy(n),
            o[3].copy(i),
            o[4].copy(r),
            o[5].copy(s),
            this
          );
        }
        copy(t) {
          const e = this.planes;
          for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
          return this;
        }
        setFromProjectionMatrix(t, e = 2e3) {
          const n = this.planes,
            i = t.elements,
            r = i[0],
            s = i[1],
            o = i[2],
            a = i[3],
            l = i[4],
            c = i[5],
            u = i[6],
            h = i[7],
            d = i[8],
            p = i[9],
            f = i[10],
            m = i[11],
            g = i[12],
            v = i[13],
            _ = i[14],
            y = i[15];
          if (
            (n[0].setComponents(a - r, h - l, m - d, y - g).normalize(),
            n[1].setComponents(a + r, h + l, m + d, y + g).normalize(),
            n[2].setComponents(a + s, h + c, m + p, y + v).normalize(),
            n[3].setComponents(a - s, h - c, m - p, y - v).normalize(),
            n[4].setComponents(a - o, h - u, m - f, y - _).normalize(),
            e === Hd)
          )
            n[5].setComponents(a + o, h + u, m + f, y + _).normalize();
          else {
            if (e !== Vd)
              throw new Error(
                "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
                  e
              );
            n[5].setComponents(o, u, f, _).normalize();
          }
          return this;
        }
        intersectsObject(t) {
          if (void 0 !== t.boundingSphere)
            null === t.boundingSphere && t.computeBoundingSphere(),
              qm.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
          else {
            const e = t.geometry;
            null === e.boundingSphere && e.computeBoundingSphere(),
              qm.copy(e.boundingSphere).applyMatrix4(t.matrixWorld);
          }
          return this.intersectsSphere(qm);
        }
        intersectsSprite(t) {
          return (
            qm.center.set(0, 0, 0),
            (qm.radius = 0.7071067811865476),
            qm.applyMatrix4(t.matrixWorld),
            this.intersectsSphere(qm)
          );
        }
        intersectsSphere(t) {
          const e = this.planes,
            n = t.center,
            i = -t.radius;
          for (let t = 0; t < 6; t++)
            if (e[t].distanceToPoint(n) < i) return !1;
          return !0;
        }
        intersectsBox(t) {
          const e = this.planes;
          for (let n = 0; n < 6; n++) {
            const i = e[n];
            if (
              ((Ym.x = i.normal.x > 0 ? t.max.x : t.min.x),
              (Ym.y = i.normal.y > 0 ? t.max.y : t.min.y),
              (Ym.z = i.normal.z > 0 ? t.max.z : t.min.z),
              i.distanceToPoint(Ym) < 0)
            )
              return !1;
          }
          return !0;
        }
        containsPoint(t) {
          const e = this.planes;
          for (let n = 0; n < 6; n++)
            if (e[n].distanceToPoint(t) < 0) return !1;
          return !0;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      function Zm() {
        let t = null,
          e = !1,
          n = null,
          i = null;
        function r(e, s) {
          n(e, s), (i = t.requestAnimationFrame(r));
        }
        return {
          start: function () {
            !0 !== e &&
              null !== n &&
              ((i = t.requestAnimationFrame(r)), (e = !0));
          },
          stop: function () {
            t.cancelAnimationFrame(i), (e = !1);
          },
          setAnimationLoop: function (t) {
            n = t;
          },
          setContext: function (e) {
            t = e;
          },
        };
      }
      function $m(t, e) {
        const n = e.isWebGL2,
          i = new WeakMap();
        return {
          get: function (t) {
            return t.isInterleavedBufferAttribute && (t = t.data), i.get(t);
          },
          remove: function (e) {
            e.isInterleavedBufferAttribute && (e = e.data);
            const n = i.get(e);
            n && (t.deleteBuffer(n.buffer), i.delete(e));
          },
          update: function (e, r) {
            if (e.isGLBufferAttribute) {
              const t = i.get(e);
              return void (
                (!t || t.version < e.version) &&
                i.set(e, {
                  buffer: e.buffer,
                  type: e.type,
                  bytesPerElement: e.elementSize,
                  version: e.version,
                })
              );
            }
            e.isInterleavedBufferAttribute && (e = e.data);
            const s = i.get(e);
            void 0 === s
              ? i.set(
                  e,
                  (function (e, i) {
                    const r = e.array,
                      s = e.usage,
                      o = t.createBuffer();
                    let a;
                    if (
                      (t.bindBuffer(i, o),
                      t.bufferData(i, r, s),
                      e.onUploadCallback(),
                      r instanceof Float32Array)
                    )
                      a = t.FLOAT;
                    else if (r instanceof Uint16Array)
                      if (e.isFloat16BufferAttribute) {
                        if (!n)
                          throw new Error(
                            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                          );
                        a = t.HALF_FLOAT;
                      } else a = t.UNSIGNED_SHORT;
                    else if (r instanceof Int16Array) a = t.SHORT;
                    else if (r instanceof Uint32Array) a = t.UNSIGNED_INT;
                    else if (r instanceof Int32Array) a = t.INT;
                    else if (r instanceof Int8Array) a = t.BYTE;
                    else if (r instanceof Uint8Array) a = t.UNSIGNED_BYTE;
                    else {
                      if (!(r instanceof Uint8ClampedArray))
                        throw new Error(
                          "THREE.WebGLAttributes: Unsupported buffer data format: " +
                            r
                        );
                      a = t.UNSIGNED_BYTE;
                    }
                    return {
                      buffer: o,
                      type: a,
                      bytesPerElement: r.BYTES_PER_ELEMENT,
                      version: e.version,
                    };
                  })(e, r)
                )
              : s.version < e.version &&
                ((function (e, i, r) {
                  const s = i.array,
                    o = i.updateRange;
                  t.bindBuffer(r, e),
                    -1 === o.count
                      ? t.bufferSubData(r, 0, s)
                      : (n
                          ? t.bufferSubData(
                              r,
                              o.offset * s.BYTES_PER_ELEMENT,
                              s,
                              o.offset,
                              o.count
                            )
                          : t.bufferSubData(
                              r,
                              o.offset * s.BYTES_PER_ELEMENT,
                              s.subarray(o.offset, o.offset + o.count)
                            ),
                        (o.count = -1)),
                    i.onUploadCallback();
                })(s.buffer, e, r),
                (s.version = e.version));
          },
        };
      }
      class Jm extends hm {
        constructor(t = 1, e = 1, n = 1, i = 1) {
          super(),
            (this.type = "PlaneGeometry"),
            (this.parameters = {
              width: t,
              height: e,
              widthSegments: n,
              heightSegments: i,
            });
          const r = t / 2,
            s = e / 2,
            o = Math.floor(n),
            a = Math.floor(i),
            l = o + 1,
            c = a + 1,
            u = t / o,
            h = e / a,
            d = [],
            p = [],
            f = [],
            m = [];
          for (let t = 0; t < c; t++) {
            const e = t * h - s;
            for (let n = 0; n < l; n++) {
              const i = n * u - r;
              p.push(i, -e, 0),
                f.push(0, 0, 1),
                m.push(n / o),
                m.push(1 - t / a);
            }
          }
          for (let t = 0; t < a; t++)
            for (let e = 0; e < o; e++) {
              const n = e + l * t,
                i = e + l * (t + 1),
                r = e + 1 + l * (t + 1),
                s = e + 1 + l * t;
              d.push(n, i, s), d.push(i, r, s);
            }
          this.setIndex(d),
            this.setAttribute("position", new im(p, 3)),
            this.setAttribute("normal", new im(f, 3)),
            this.setAttribute("uv", new im(m, 2));
        }
        copy(t) {
          return (
            super.copy(t),
            (this.parameters = Object.assign({}, t.parameters)),
            this
          );
        }
        static fromJSON(t) {
          return new Jm(t.width, t.height, t.widthSegments, t.heightSegments);
        }
      }
      const Qm = {
          alphahash_fragment:
            "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
          alphahash_pars_fragment:
            "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
          alphamap_fragment:
            "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
          alphamap_pars_fragment:
            "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          alphatest_fragment:
            "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
          alphatest_pars_fragment:
            "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
          aomap_fragment:
            "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
          aomap_pars_fragment:
            "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
          begin_vertex:
            "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
          beginnormal_vertex:
            "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
          bsdfs:
            "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
          iridescence_fragment:
            "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
          bumpmap_pars_fragment:
            "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
          clipping_planes_fragment:
            "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
          clipping_planes_pars_fragment:
            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
          clipping_planes_pars_vertex:
            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
          clipping_planes_vertex:
            "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
          color_fragment:
            "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
          color_pars_fragment:
            "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
          color_pars_vertex:
            "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
          color_vertex:
            "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
          common:
            "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
          cube_uv_reflection_fragment:
            "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
          defaultnormal_vertex:
            "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
          displacementmap_pars_vertex:
            "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
          displacementmap_vertex:
            "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
          emissivemap_fragment:
            "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
          emissivemap_pars_fragment:
            "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
          colorspace_fragment:
            "gl_FragColor = linearToOutputTexel( gl_FragColor );",
          colorspace_pars_fragment:
            "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}",
          envmap_fragment:
            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
          envmap_common_pars_fragment:
            "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
          envmap_pars_fragment:
            "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
          envmap_pars_vertex:
            "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
          envmap_physical_pars_fragment:
            "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
          envmap_vertex:
            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
          fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
          fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
          fog_fragment:
            "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
          fog_pars_fragment:
            "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
          gradientmap_pars_fragment:
            "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
          lightmap_fragment:
            "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
          lightmap_pars_fragment:
            "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
          lights_lambert_fragment:
            "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
          lights_lambert_pars_fragment:
            "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
          lights_pars_begin:
            "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
          lights_toon_fragment:
            "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
          lights_toon_pars_fragment:
            "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
          lights_phong_fragment:
            "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
          lights_phong_pars_fragment:
            "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
          lights_physical_fragment:
            "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tanisotropyV /= material.anisotropy;\n\tmaterial.anisotropy = saturate( material.anisotropy );\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;\n#endif",
          lights_physical_pars_fragment:
            "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
          lights_fragment_begin:
            "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal;\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
          lights_fragment_maps:
            "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
          lights_fragment_end:
            "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
          logdepthbuf_fragment:
            "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
          logdepthbuf_pars_fragment:
            "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
          logdepthbuf_pars_vertex:
            "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
          logdepthbuf_vertex:
            "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
          map_fragment:
            "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
          map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
          map_particle_fragment:
            "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
          map_particle_pars_fragment:
            "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          metalnessmap_fragment:
            "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
          metalnessmap_pars_fragment:
            "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
          morphcolor_vertex:
            "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
          morphnormal_vertex:
            "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
          morphtarget_pars_vertex:
            "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
          morphtarget_vertex:
            "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
          normal_fragment_begin:
            "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
          normal_fragment_maps:
            "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
          normal_pars_fragment:
            "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
          normal_pars_vertex:
            "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
          normal_vertex:
            "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
          normalmap_pars_fragment:
            "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
          clearcoat_normal_fragment_begin:
            "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
          clearcoat_normal_fragment_maps:
            "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
          clearcoat_pars_fragment:
            "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
          iridescence_pars_fragment:
            "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
          opaque_fragment:
            "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
          packing:
            "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
          premultiplied_alpha_fragment:
            "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
          project_vertex:
            "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
          dithering_fragment:
            "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
          dithering_pars_fragment:
            "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
          roughnessmap_fragment:
            "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
          roughnessmap_pars_fragment:
            "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
          shadowmap_pars_fragment:
            "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
          shadowmap_pars_vertex:
            "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
          shadowmap_vertex:
            "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
          shadowmask_pars_fragment:
            "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
          skinbase_vertex:
            "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
          skinning_pars_vertex:
            "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
          skinning_vertex:
            "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
          skinnormal_vertex:
            "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
          specularmap_fragment:
            "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
          specularmap_pars_fragment:
            "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
          tonemapping_fragment:
            "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
          tonemapping_pars_fragment:
            "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
          transmission_fragment:
            "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
          transmission_pars_fragment:
            "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
          uv_pars_fragment:
            "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
          uv_pars_vertex:
            "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
          uv_vertex:
            "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
          worldpos_vertex:
            "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
          background_vert:
            "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
          background_frag:
            "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
          backgroundCube_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
          backgroundCube_frag:
            "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
          cube_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
          cube_frag:
            "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
          depth_vert:
            "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
          depth_frag:
            "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
          distanceRGBA_vert:
            "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
          distanceRGBA_frag:
            "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
          equirect_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
          equirect_frag:
            "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
          linedashed_vert:
            "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          linedashed_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          meshbasic_vert:
            "#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
          meshbasic_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshlambert_vert:
            "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshlambert_frag:
            "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshmatcap_vert:
            "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
          meshmatcap_frag:
            "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshnormal_vert:
            "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
          meshnormal_frag:
            "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
          meshphong_vert:
            "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshphong_frag:
            "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshphysical_vert:
            "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
          meshphysical_frag:
            "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshtoon_vert:
            "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshtoon_frag:
            "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          points_vert:
            "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
          points_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          shadow_vert:
            "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          shadow_frag:
            "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
          sprite_vert:
            "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          sprite_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
        },
        tg = {
          common: {
            diffuse: {
              value: new Kf(16777215),
            },
            opacity: {
              value: 1,
            },
            map: {
              value: null,
            },
            mapTransform: {
              value: new ep(),
            },
            alphaMap: {
              value: null,
            },
            alphaMapTransform: {
              value: new ep(),
            },
            alphaTest: {
              value: 0,
            },
          },
          specularmap: {
            specularMap: {
              value: null,
            },
            specularMapTransform: {
              value: new ep(),
            },
          },
          envmap: {
            envMap: {
              value: null,
            },
            flipEnvMap: {
              value: -1,
            },
            reflectivity: {
              value: 1,
            },
            ior: {
              value: 1.5,
            },
            refractionRatio: {
              value: 0.98,
            },
          },
          aomap: {
            aoMap: {
              value: null,
            },
            aoMapIntensity: {
              value: 1,
            },
            aoMapTransform: {
              value: new ep(),
            },
          },
          lightmap: {
            lightMap: {
              value: null,
            },
            lightMapIntensity: {
              value: 1,
            },
            lightMapTransform: {
              value: new ep(),
            },
          },
          bumpmap: {
            bumpMap: {
              value: null,
            },
            bumpMapTransform: {
              value: new ep(),
            },
            bumpScale: {
              value: 1,
            },
          },
          normalmap: {
            normalMap: {
              value: null,
            },
            normalMapTransform: {
              value: new ep(),
            },
            normalScale: {
              value: new tp(1, 1),
            },
          },
          displacementmap: {
            displacementMap: {
              value: null,
            },
            displacementMapTransform: {
              value: new ep(),
            },
            displacementScale: {
              value: 1,
            },
            displacementBias: {
              value: 0,
            },
          },
          emissivemap: {
            emissiveMap: {
              value: null,
            },
            emissiveMapTransform: {
              value: new ep(),
            },
          },
          metalnessmap: {
            metalnessMap: {
              value: null,
            },
            metalnessMapTransform: {
              value: new ep(),
            },
          },
          roughnessmap: {
            roughnessMap: {
              value: null,
            },
            roughnessMapTransform: {
              value: new ep(),
            },
          },
          gradientmap: {
            gradientMap: {
              value: null,
            },
          },
          fog: {
            fogDensity: {
              value: 25e-5,
            },
            fogNear: {
              value: 1,
            },
            fogFar: {
              value: 2e3,
            },
            fogColor: {
              value: new Kf(16777215),
            },
          },
          lights: {
            ambientLightColor: {
              value: [],
            },
            lightProbe: {
              value: [],
            },
            directionalLights: {
              value: [],
              properties: {
                direction: {},
                color: {},
              },
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            directionalShadowMap: {
              value: [],
            },
            directionalShadowMatrix: {
              value: [],
            },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
              },
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            spotLightMap: {
              value: [],
            },
            spotShadowMap: {
              value: [],
            },
            spotLightMatrix: {
              value: [],
            },
            pointLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                decay: {},
                distance: {},
              },
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: {
              value: [],
            },
            pointShadowMatrix: {
              value: [],
            },
            hemisphereLights: {
              value: [],
              properties: {
                direction: {},
                skyColor: {},
                groundColor: {},
              },
            },
            rectAreaLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                width: {},
                height: {},
              },
            },
            ltc_1: {
              value: null,
            },
            ltc_2: {
              value: null,
            },
          },
          points: {
            diffuse: {
              value: new Kf(16777215),
            },
            opacity: {
              value: 1,
            },
            size: {
              value: 1,
            },
            scale: {
              value: 1,
            },
            map: {
              value: null,
            },
            alphaMap: {
              value: null,
            },
            alphaMapTransform: {
              value: new ep(),
            },
            alphaTest: {
              value: 0,
            },
            uvTransform: {
              value: new ep(),
            },
          },
          sprite: {
            diffuse: {
              value: new Kf(16777215),
            },
            opacity: {
              value: 1,
            },
            center: {
              value: new tp(0.5, 0.5),
            },
            rotation: {
              value: 0,
            },
            map: {
              value: null,
            },
            mapTransform: {
              value: new ep(),
            },
            alphaMap: {
              value: null,
            },
            alphaMapTransform: {
              value: new ep(),
            },
            alphaTest: {
              value: 0,
            },
          },
        },
        eg = {
          basic: {
            uniforms: Om([
              tg.common,
              tg.specularmap,
              tg.envmap,
              tg.aomap,
              tg.lightmap,
              tg.fog,
            ]),
            vertexShader: Qm.meshbasic_vert,
            fragmentShader: Qm.meshbasic_frag,
          },
          lambert: {
            uniforms: Om([
              tg.common,
              tg.specularmap,
              tg.envmap,
              tg.aomap,
              tg.lightmap,
              tg.emissivemap,
              tg.bumpmap,
              tg.normalmap,
              tg.displacementmap,
              tg.fog,
              tg.lights,
              {
                emissive: {
                  value: new Kf(0),
                },
              },
            ]),
            vertexShader: Qm.meshlambert_vert,
            fragmentShader: Qm.meshlambert_frag,
          },
          phong: {
            uniforms: Om([
              tg.common,
              tg.specularmap,
              tg.envmap,
              tg.aomap,
              tg.lightmap,
              tg.emissivemap,
              tg.bumpmap,
              tg.normalmap,
              tg.displacementmap,
              tg.fog,
              tg.lights,
              {
                emissive: {
                  value: new Kf(0),
                },
                specular: {
                  value: new Kf(1118481),
                },
                shininess: {
                  value: 30,
                },
              },
            ]),
            vertexShader: Qm.meshphong_vert,
            fragmentShader: Qm.meshphong_frag,
          },
          standard: {
            uniforms: Om([
              tg.common,
              tg.envmap,
              tg.aomap,
              tg.lightmap,
              tg.emissivemap,
              tg.bumpmap,
              tg.normalmap,
              tg.displacementmap,
              tg.roughnessmap,
              tg.metalnessmap,
              tg.fog,
              tg.lights,
              {
                emissive: {
                  value: new Kf(0),
                },
                roughness: {
                  value: 1,
                },
                metalness: {
                  value: 0,
                },
                envMapIntensity: {
                  value: 1,
                },
              },
            ]),
            vertexShader: Qm.meshphysical_vert,
            fragmentShader: Qm.meshphysical_frag,
          },
          toon: {
            uniforms: Om([
              tg.common,
              tg.aomap,
              tg.lightmap,
              tg.emissivemap,
              tg.bumpmap,
              tg.normalmap,
              tg.displacementmap,
              tg.gradientmap,
              tg.fog,
              tg.lights,
              {
                emissive: {
                  value: new Kf(0),
                },
              },
            ]),
            vertexShader: Qm.meshtoon_vert,
            fragmentShader: Qm.meshtoon_frag,
          },
          matcap: {
            uniforms: Om([
              tg.common,
              tg.bumpmap,
              tg.normalmap,
              tg.displacementmap,
              tg.fog,
              {
                matcap: {
                  value: null,
                },
              },
            ]),
            vertexShader: Qm.meshmatcap_vert,
            fragmentShader: Qm.meshmatcap_frag,
          },
          points: {
            uniforms: Om([tg.points, tg.fog]),
            vertexShader: Qm.points_vert,
            fragmentShader: Qm.points_frag,
          },
          dashed: {
            uniforms: Om([
              tg.common,
              tg.fog,
              {
                scale: {
                  value: 1,
                },
                dashSize: {
                  value: 1,
                },
                totalSize: {
                  value: 2,
                },
              },
            ]),
            vertexShader: Qm.linedashed_vert,
            fragmentShader: Qm.linedashed_frag,
          },
          depth: {
            uniforms: Om([tg.common, tg.displacementmap]),
            vertexShader: Qm.depth_vert,
            fragmentShader: Qm.depth_frag,
          },
          normal: {
            uniforms: Om([
              tg.common,
              tg.bumpmap,
              tg.normalmap,
              tg.displacementmap,
              {
                opacity: {
                  value: 1,
                },
              },
            ]),
            vertexShader: Qm.meshnormal_vert,
            fragmentShader: Qm.meshnormal_frag,
          },
          sprite: {
            uniforms: Om([tg.sprite, tg.fog]),
            vertexShader: Qm.sprite_vert,
            fragmentShader: Qm.sprite_frag,
          },
          background: {
            uniforms: {
              uvTransform: {
                value: new ep(),
              },
              t2D: {
                value: null,
              },
              backgroundIntensity: {
                value: 1,
              },
            },
            vertexShader: Qm.background_vert,
            fragmentShader: Qm.background_frag,
          },
          backgroundCube: {
            uniforms: {
              envMap: {
                value: null,
              },
              flipEnvMap: {
                value: -1,
              },
              backgroundBlurriness: {
                value: 0,
              },
              backgroundIntensity: {
                value: 1,
              },
            },
            vertexShader: Qm.backgroundCube_vert,
            fragmentShader: Qm.backgroundCube_frag,
          },
          cube: {
            uniforms: {
              tCube: {
                value: null,
              },
              tFlip: {
                value: -1,
              },
              opacity: {
                value: 1,
              },
            },
            vertexShader: Qm.cube_vert,
            fragmentShader: Qm.cube_frag,
          },
          equirect: {
            uniforms: {
              tEquirect: {
                value: null,
              },
            },
            vertexShader: Qm.equirect_vert,
            fragmentShader: Qm.equirect_frag,
          },
          distanceRGBA: {
            uniforms: Om([
              tg.common,
              tg.displacementmap,
              {
                referencePosition: {
                  value: new Ap(),
                },
                nearDistance: {
                  value: 1,
                },
                farDistance: {
                  value: 1e3,
                },
              },
            ]),
            vertexShader: Qm.distanceRGBA_vert,
            fragmentShader: Qm.distanceRGBA_frag,
          },
          shadow: {
            uniforms: Om([
              tg.lights,
              tg.fog,
              {
                color: {
                  value: new Kf(0),
                },
                opacity: {
                  value: 1,
                },
              },
            ]),
            vertexShader: Qm.shadow_vert,
            fragmentShader: Qm.shadow_frag,
          },
        };
      eg.physical = {
        uniforms: Om([
          eg.standard.uniforms,
          {
            clearcoat: {
              value: 0,
            },
            clearcoatMap: {
              value: null,
            },
            clearcoatMapTransform: {
              value: new ep(),
            },
            clearcoatNormalMap: {
              value: null,
            },
            clearcoatNormalMapTransform: {
              value: new ep(),
            },
            clearcoatNormalScale: {
              value: new tp(1, 1),
            },
            clearcoatRoughness: {
              value: 0,
            },
            clearcoatRoughnessMap: {
              value: null,
            },
            clearcoatRoughnessMapTransform: {
              value: new ep(),
            },
            iridescence: {
              value: 0,
            },
            iridescenceMap: {
              value: null,
            },
            iridescenceMapTransform: {
              value: new ep(),
            },
            iridescenceIOR: {
              value: 1.3,
            },
            iridescenceThicknessMinimum: {
              value: 100,
            },
            iridescenceThicknessMaximum: {
              value: 400,
            },
            iridescenceThicknessMap: {
              value: null,
            },
            iridescenceThicknessMapTransform: {
              value: new ep(),
            },
            sheen: {
              value: 0,
            },
            sheenColor: {
              value: new Kf(0),
            },
            sheenColorMap: {
              value: null,
            },
            sheenColorMapTransform: {
              value: new ep(),
            },
            sheenRoughness: {
              value: 1,
            },
            sheenRoughnessMap: {
              value: null,
            },
            sheenRoughnessMapTransform: {
              value: new ep(),
            },
            transmission: {
              value: 0,
            },
            transmissionMap: {
              value: null,
            },
            transmissionMapTransform: {
              value: new ep(),
            },
            transmissionSamplerSize: {
              value: new tp(),
            },
            transmissionSamplerMap: {
              value: null,
            },
            thickness: {
              value: 0,
            },
            thicknessMap: {
              value: null,
            },
            thicknessMapTransform: {
              value: new ep(),
            },
            attenuationDistance: {
              value: 0,
            },
            attenuationColor: {
              value: new Kf(0),
            },
            specularColor: {
              value: new Kf(1, 1, 1),
            },
            specularColorMap: {
              value: null,
            },
            specularColorMapTransform: {
              value: new ep(),
            },
            specularIntensity: {
              value: 1,
            },
            specularIntensityMap: {
              value: null,
            },
            specularIntensityMapTransform: {
              value: new ep(),
            },
            anisotropyVector: {
              value: new tp(),
            },
            anisotropyMap: {
              value: null,
            },
            anisotropyMapTransform: {
              value: new ep(),
            },
          },
        ]),
        vertexShader: Qm.meshphysical_vert,
        fragmentShader: Qm.meshphysical_frag,
      };
      const ng = {
        r: 0,
        b: 0,
        g: 0,
      };
      function ig(t, e, n, i, r, s, o) {
        const a = new Kf(0);
        let l,
          c,
          u = !0 === s ? 0 : 1,
          h = null,
          d = 0,
          p = null;
        function f(e, n) {
          e.getRGB(ng, Im(t)), i.buffers.color.setClear(ng.r, ng.g, ng.b, n, o);
        }
        return {
          getClearColor: function () {
            return a;
          },
          setClearColor: function (t, e = 1) {
            a.set(t), (u = e), f(a, u);
          },
          getClearAlpha: function () {
            return u;
          },
          setClearAlpha: function (t) {
            (u = t), f(a, u);
          },
          render: function (s, m) {
            let g = !1,
              v = !0 === m.isScene ? m.background : null;
            v &&
              v.isTexture &&
              (v = (m.backgroundBlurriness > 0 ? n : e).get(v)),
              null === v ? f(a, u) : v && v.isColor && (f(v, 1), (g = !0));
            const _ = t.xr.getEnvironmentBlendMode();
            "additive" === _
              ? i.buffers.color.setClear(0, 0, 0, 1, o)
              : "alpha-blend" === _ && i.buffers.color.setClear(0, 0, 0, 0, o),
              (t.autoClear || g) &&
                t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
              v && (v.isCubeTexture || v.mapping === id)
                ? (void 0 === c &&
                    ((c = new Cm(
                      new Rm(1, 1, 1),
                      new Nm({
                        name: "BackgroundCubeMaterial",
                        uniforms: Lm(eg.backgroundCube.uniforms),
                        vertexShader: eg.backgroundCube.vertexShader,
                        fragmentShader: eg.backgroundCube.fragmentShader,
                        side: 1,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      })
                    )),
                    c.geometry.deleteAttribute("normal"),
                    c.geometry.deleteAttribute("uv"),
                    (c.onBeforeRender = function (t, e, n) {
                      this.matrixWorld.copyPosition(n.matrixWorld);
                    }),
                    Object.defineProperty(c.material, "envMap", {
                      get: function () {
                        return this.uniforms.envMap.value;
                      },
                    }),
                    r.update(c)),
                  (c.material.uniforms.envMap.value = v),
                  (c.material.uniforms.flipEnvMap.value =
                    v.isCubeTexture && !1 === v.isRenderTargetTexture ? -1 : 1),
                  (c.material.uniforms.backgroundBlurriness.value =
                    m.backgroundBlurriness),
                  (c.material.uniforms.backgroundIntensity.value =
                    m.backgroundIntensity),
                  (c.material.toneMapped = dp.getTransfer(v.colorSpace) !== Fd),
                  (h === v && d === v.version && p === t.toneMapping) ||
                    ((c.material.needsUpdate = !0),
                    (h = v),
                    (d = v.version),
                    (p = t.toneMapping)),
                  c.layers.enableAll(),
                  s.unshift(c, c.geometry, c.material, 0, 0, null))
                : v &&
                  v.isTexture &&
                  (void 0 === l &&
                    ((l = new Cm(
                      new Jm(2, 2),
                      new Nm({
                        name: "BackgroundMaterial",
                        uniforms: Lm(eg.background.uniforms),
                        vertexShader: eg.background.vertexShader,
                        fragmentShader: eg.background.fragmentShader,
                        side: 0,
                        depthTest: !1,
                        depthWrite: !1,
                        fog: !1,
                      })
                    )),
                    l.geometry.deleteAttribute("normal"),
                    Object.defineProperty(l.material, "map", {
                      get: function () {
                        return this.uniforms.t2D.value;
                      },
                    }),
                    r.update(l)),
                  (l.material.uniforms.t2D.value = v),
                  (l.material.uniforms.backgroundIntensity.value =
                    m.backgroundIntensity),
                  (l.material.toneMapped = dp.getTransfer(v.colorSpace) !== Fd),
                  !0 === v.matrixAutoUpdate && v.updateMatrix(),
                  l.material.uniforms.uvTransform.value.copy(v.matrix),
                  (h === v && d === v.version && p === t.toneMapping) ||
                    ((l.material.needsUpdate = !0),
                    (h = v),
                    (d = v.version),
                    (p = t.toneMapping)),
                  l.layers.enableAll(),
                  s.unshift(l, l.geometry, l.material, 0, 0, null));
          },
        };
      }
      function rg(t, e, n, i) {
        const r = t.getParameter(t.MAX_VERTEX_ATTRIBS),
          s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
          o = i.isWebGL2 || null !== s,
          a = {},
          l = p(null);
        let c = l,
          u = !1;
        function h(e) {
          return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e);
        }
        function d(e) {
          return i.isWebGL2
            ? t.deleteVertexArray(e)
            : s.deleteVertexArrayOES(e);
        }
        function p(t) {
          const e = [],
            n = [],
            i = [];
          for (let t = 0; t < r; t++) (e[t] = 0), (n[t] = 0), (i[t] = 0);
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: e,
            enabledAttributes: n,
            attributeDivisors: i,
            object: t,
            attributes: {},
            index: null,
          };
        }
        function f() {
          const t = c.newAttributes;
          for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
        }
        function m(t) {
          g(t, 0);
        }
        function g(n, r) {
          const s = c.newAttributes,
            o = c.enabledAttributes,
            a = c.attributeDivisors;
          (s[n] = 1),
            0 === o[n] && (t.enableVertexAttribArray(n), (o[n] = 1)),
            a[n] !== r &&
              ((i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
                i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
              ](n, r),
              (a[n] = r));
        }
        function v() {
          const e = c.newAttributes,
            n = c.enabledAttributes;
          for (let i = 0, r = n.length; i < r; i++)
            n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0));
        }
        function _(e, n, i, r, s, o, a) {
          !0 === a
            ? t.vertexAttribIPointer(e, n, i, s, o)
            : t.vertexAttribPointer(e, n, i, r, s, o);
        }
        function y() {
          x(), (u = !0), c !== l && ((c = l), h(c.object));
        }
        function x() {
          (l.geometry = null), (l.program = null), (l.wireframe = !1);
        }
        return {
          setup: function (r, l, d, y, x) {
            let b = !1;
            if (o) {
              const e = (function (e, n, r) {
                const o = !0 === r.wireframe;
                let l = a[e.id];
                void 0 === l && ((l = {}), (a[e.id] = l));
                let c = l[n.id];
                void 0 === c && ((c = {}), (l[n.id] = c));
                let u = c[o];
                return (
                  void 0 === u &&
                    ((u = p(
                      i.isWebGL2
                        ? t.createVertexArray()
                        : s.createVertexArrayOES()
                    )),
                    (c[o] = u)),
                  u
                );
              })(y, d, l);
              c !== e && ((c = e), h(c.object)),
                (b = (function (t, e, n, i) {
                  const r = c.attributes,
                    s = e.attributes;
                  let o = 0;
                  const a = n.getAttributes();
                  for (const e in a)
                    if (a[e].location >= 0) {
                      const n = r[e];
                      let i = s[e];
                      if (
                        (void 0 === i &&
                          ("instanceMatrix" === e &&
                            t.instanceMatrix &&
                            (i = t.instanceMatrix),
                          "instanceColor" === e &&
                            t.instanceColor &&
                            (i = t.instanceColor)),
                        void 0 === n)
                      )
                        return !0;
                      if (n.attribute !== i) return !0;
                      if (i && n.data !== i.data) return !0;
                      o++;
                    }
                  return c.attributesNum !== o || c.index !== i;
                })(r, y, d, x)),
                b &&
                  (function (t, e, n, i) {
                    const r = {},
                      s = e.attributes;
                    let o = 0;
                    const a = n.getAttributes();
                    for (const e in a)
                      if (a[e].location >= 0) {
                        let n = s[e];
                        void 0 === n &&
                          ("instanceMatrix" === e &&
                            t.instanceMatrix &&
                            (n = t.instanceMatrix),
                          "instanceColor" === e &&
                            t.instanceColor &&
                            (n = t.instanceColor));
                        const i = {};
                        (i.attribute = n),
                          n && n.data && (i.data = n.data),
                          (r[e] = i),
                          o++;
                      }
                    (c.attributes = r), (c.attributesNum = o), (c.index = i);
                  })(r, y, d, x);
            } else {
              const t = !0 === l.wireframe;
              (c.geometry === y.id &&
                c.program === d.id &&
                c.wireframe === t) ||
                ((c.geometry = y.id),
                (c.program = d.id),
                (c.wireframe = t),
                (b = !0));
            }
            null !== x && n.update(x, t.ELEMENT_ARRAY_BUFFER),
              (b || u) &&
                ((u = !1),
                (function (r, s, o, a) {
                  if (
                    !1 === i.isWebGL2 &&
                    (r.isInstancedMesh || a.isInstancedBufferGeometry) &&
                    null === e.get("ANGLE_instanced_arrays")
                  )
                    return;
                  f();
                  const l = a.attributes,
                    c = o.getAttributes(),
                    u = s.defaultAttributeValues;
                  for (const e in c) {
                    const s = c[e];
                    if (s.location >= 0) {
                      let o = l[e];
                      if (
                        (void 0 === o &&
                          ("instanceMatrix" === e &&
                            r.instanceMatrix &&
                            (o = r.instanceMatrix),
                          "instanceColor" === e &&
                            r.instanceColor &&
                            (o = r.instanceColor)),
                        void 0 !== o)
                      ) {
                        const e = o.normalized,
                          l = o.itemSize,
                          c = n.get(o);
                        if (void 0 === c) continue;
                        const u = c.buffer,
                          h = c.type,
                          d = c.bytesPerElement,
                          p =
                            !0 === i.isWebGL2 &&
                            (h === t.INT ||
                              h === t.UNSIGNED_INT ||
                              1013 === o.gpuType);
                        if (o.isInterleavedBufferAttribute) {
                          const n = o.data,
                            i = n.stride,
                            c = o.offset;
                          if (n.isInstancedInterleavedBuffer) {
                            for (let t = 0; t < s.locationSize; t++)
                              g(s.location + t, n.meshPerAttribute);
                            !0 !== r.isInstancedMesh &&
                              void 0 === a._maxInstanceCount &&
                              (a._maxInstanceCount =
                                n.meshPerAttribute * n.count);
                          } else
                            for (let t = 0; t < s.locationSize; t++)
                              m(s.location + t);
                          t.bindBuffer(t.ARRAY_BUFFER, u);
                          for (let t = 0; t < s.locationSize; t++)
                            _(
                              s.location + t,
                              l / s.locationSize,
                              h,
                              e,
                              i * d,
                              (c + (l / s.locationSize) * t) * d,
                              p
                            );
                        } else {
                          if (o.isInstancedBufferAttribute) {
                            for (let t = 0; t < s.locationSize; t++)
                              g(s.location + t, o.meshPerAttribute);
                            !0 !== r.isInstancedMesh &&
                              void 0 === a._maxInstanceCount &&
                              (a._maxInstanceCount =
                                o.meshPerAttribute * o.count);
                          } else
                            for (let t = 0; t < s.locationSize; t++)
                              m(s.location + t);
                          t.bindBuffer(t.ARRAY_BUFFER, u);
                          for (let t = 0; t < s.locationSize; t++)
                            _(
                              s.location + t,
                              l / s.locationSize,
                              h,
                              e,
                              l * d,
                              (l / s.locationSize) * t * d,
                              p
                            );
                        }
                      } else if (void 0 !== u) {
                        const n = u[e];
                        if (void 0 !== n)
                          switch (n.length) {
                            case 2:
                              t.vertexAttrib2fv(s.location, n);
                              break;
                            case 3:
                              t.vertexAttrib3fv(s.location, n);
                              break;
                            case 4:
                              t.vertexAttrib4fv(s.location, n);
                              break;
                            default:
                              t.vertexAttrib1fv(s.location, n);
                          }
                      }
                    }
                  }
                  v();
                })(r, l, d, y),
                null !== x &&
                  t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, n.get(x).buffer));
          },
          reset: y,
          resetDefaultState: x,
          dispose: function () {
            y();
            for (const t in a) {
              const e = a[t];
              for (const t in e) {
                const n = e[t];
                for (const t in n) d(n[t].object), delete n[t];
                delete e[t];
              }
              delete a[t];
            }
          },
          releaseStatesOfGeometry: function (t) {
            if (void 0 === a[t.id]) return;
            const e = a[t.id];
            for (const t in e) {
              const n = e[t];
              for (const t in n) d(n[t].object), delete n[t];
              delete e[t];
            }
            delete a[t.id];
          },
          releaseStatesOfProgram: function (t) {
            for (const e in a) {
              const n = a[e];
              if (void 0 === n[t.id]) continue;
              const i = n[t.id];
              for (const t in i) d(i[t].object), delete i[t];
              delete n[t.id];
            }
          },
          initAttributes: f,
          enableAttribute: m,
          disableUnusedAttributes: v,
        };
      }
      function sg(t, e, n, i) {
        const r = i.isWebGL2;
        let s;
        (this.setMode = function (t) {
          s = t;
        }),
          (this.render = function (e, i) {
            t.drawArrays(s, e, i), n.update(i, s, 1);
          }),
          (this.renderInstances = function (i, o, a) {
            if (0 === a) return;
            let l, c;
            if (r) (l = t), (c = "drawArraysInstanced");
            else if (
              ((l = e.get("ANGLE_instanced_arrays")),
              (c = "drawArraysInstancedANGLE"),
              null === l)
            )
              return void console.error(
                "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
              );
            l[c](s, i, o, a), n.update(o, s, a);
          });
      }
      function og(t, e, n) {
        let i;
        function r(e) {
          if ("highp" === e) {
            if (
              t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT)
                .precision > 0 &&
              t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT)
                .precision > 0
            )
              return "highp";
            e = "mediump";
          }
          return "mediump" === e &&
            t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT)
              .precision > 0 &&
            t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT)
              .precision > 0
            ? "mediump"
            : "lowp";
        }
        const s =
          "undefined" != typeof WebGL2RenderingContext &&
          "WebGL2RenderingContext" === t.constructor.name;
        let o = void 0 !== n.precision ? n.precision : "highp";
        const a = r(o);
        a !== o &&
          (console.warn(
            "THREE.WebGLRenderer:",
            o,
            "not supported, using",
            a,
            "instead."
          ),
          (o = a));
        const l = s || e.has("WEBGL_draw_buffers"),
          c = !0 === n.logarithmicDepthBuffer,
          u = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
          h = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
          d = t.getParameter(t.MAX_TEXTURE_SIZE),
          p = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
          f = t.getParameter(t.MAX_VERTEX_ATTRIBS),
          m = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
          g = t.getParameter(t.MAX_VARYING_VECTORS),
          v = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
          _ = h > 0,
          y = s || e.has("OES_texture_float");
        return {
          isWebGL2: s,
          drawBuffers: l,
          getMaxAnisotropy: function () {
            if (void 0 !== i) return i;
            if (!0 === e.has("EXT_texture_filter_anisotropic")) {
              const n = e.get("EXT_texture_filter_anisotropic");
              i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else i = 0;
            return i;
          },
          getMaxPrecision: r,
          precision: o,
          logarithmicDepthBuffer: c,
          maxTextures: u,
          maxVertexTextures: h,
          maxTextureSize: d,
          maxCubemapSize: p,
          maxAttributes: f,
          maxVertexUniforms: m,
          maxVaryings: g,
          maxFragmentUniforms: v,
          vertexTextures: _,
          floatFragmentTextures: y,
          floatVertexTextures: _ && y,
          maxSamples: s ? t.getParameter(t.MAX_SAMPLES) : 0,
        };
      }
      function ag(t) {
        const e = this;
        let n = null,
          i = 0,
          r = !1,
          s = !1;
        const o = new Xm(),
          a = new ep(),
          l = {
            value: null,
            needsUpdate: !1,
          };
        function c(t, n, i, r) {
          const s = null !== t ? t.length : 0;
          let c = null;
          if (0 !== s) {
            if (((c = l.value), !0 !== r || null === c)) {
              const e = i + 4 * s,
                r = n.matrixWorldInverse;
              a.getNormalMatrix(r),
                (null === c || c.length < e) && (c = new Float32Array(e));
              for (let e = 0, n = i; e !== s; ++e, n += 4)
                o.copy(t[e]).applyMatrix4(r, a),
                  o.normal.toArray(c, n),
                  (c[n + 3] = o.constant);
            }
            (l.value = c), (l.needsUpdate = !0);
          }
          return (e.numPlanes = s), (e.numIntersection = 0), c;
        }
        (this.uniform = l),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (t, e) {
            const n = 0 !== t.length || e || 0 !== i || r;
            return (r = e), (i = t.length), n;
          }),
          (this.beginShadows = function () {
            (s = !0), c(null);
          }),
          (this.endShadows = function () {
            s = !1;
          }),
          (this.setGlobalState = function (t, e) {
            n = c(t, e, 0);
          }),
          (this.setState = function (o, a, u) {
            const h = o.clippingPlanes,
              d = o.clipIntersection,
              p = o.clipShadows,
              f = t.get(o);
            if (!r || null === h || 0 === h.length || (s && !p))
              s
                ? c(null)
                : (l.value !== n && ((l.value = n), (l.needsUpdate = i > 0)),
                  (e.numPlanes = i),
                  (e.numIntersection = 0));
            else {
              const t = s ? 0 : i,
                e = 4 * t;
              let r = f.clippingState || null;
              (l.value = r), (r = c(h, a, e, u));
              for (let t = 0; t !== e; ++t) r[t] = n[t];
              (f.clippingState = r),
                (this.numIntersection = d ? this.numPlanes : 0),
                (this.numPlanes += t);
            }
          });
      }
      function lg(t) {
        let e = new WeakMap();
        function n(t, e) {
          return (
            303 === e ? (t.mapping = ed) : 304 === e && (t.mapping = nd), t
          );
        }
        function i(t) {
          const n = t.target;
          n.removeEventListener("dispose", i);
          const r = e.get(n);
          void 0 !== r && (e.delete(n), r.dispose());
        }
        return {
          get: function (r) {
            if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
              const s = r.mapping;
              if (303 === s || 304 === s) {
                if (e.has(r)) return n(e.get(r).texture, r.mapping);
                {
                  const s = r.image;
                  if (s && s.height > 0) {
                    const o = new Vm(s.height / 2);
                    return (
                      o.fromEquirectangularTexture(t, r),
                      e.set(r, o),
                      r.addEventListener("dispose", i),
                      n(o.texture, r.mapping)
                    );
                  }
                  return null;
                }
              }
            }
            return r;
          },
          dispose: function () {
            e = new WeakMap();
          },
        };
      }
      class cg extends Um {
        constructor(t = -1, e = 1, n = 1, i = -1, r = 0.1, s = 2e3) {
          super(),
            (this.isOrthographicCamera = !0),
            (this.type = "OrthographicCamera"),
            (this.zoom = 1),
            (this.view = null),
            (this.left = t),
            (this.right = e),
            (this.top = n),
            (this.bottom = i),
            (this.near = r),
            (this.far = s),
            this.updateProjectionMatrix();
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            (this.left = t.left),
            (this.right = t.right),
            (this.top = t.top),
            (this.bottom = t.bottom),
            (this.near = t.near),
            (this.far = t.far),
            (this.zoom = t.zoom),
            (this.view = null === t.view ? null : Object.assign({}, t.view)),
            this
          );
        }
        setViewOffset(t, e, n, i, r, s) {
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = t),
            (this.view.fullHeight = e),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = s),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const t = (this.right - this.left) / (2 * this.zoom),
            e = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            i = (this.top + this.bottom) / 2;
          let r = n - t,
            s = n + t,
            o = i + e,
            a = i - e;
          if (null !== this.view && this.view.enabled) {
            const t =
                (this.right - this.left) / this.view.fullWidth / this.zoom,
              e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            (r += t * this.view.offsetX),
              (s = r + t * this.view.width),
              (o -= e * this.view.offsetY),
              (a = o - e * this.view.height);
          }
          this.projectionMatrix.makeOrthographic(
            r,
            s,
            o,
            a,
            this.near,
            this.far,
            this.coordinateSystem
          ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (
            (e.object.zoom = this.zoom),
            (e.object.left = this.left),
            (e.object.right = this.right),
            (e.object.top = this.top),
            (e.object.bottom = this.bottom),
            (e.object.near = this.near),
            (e.object.far = this.far),
            null !== this.view &&
              (e.object.view = Object.assign({}, this.view)),
            e
          );
        }
      }
      const ug = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
        hg = new cg(),
        dg = new Kf();
      let pg = null;
      const fg = (1 + Math.sqrt(5)) / 2,
        mg = 1 / fg,
        gg = [
          new Ap(1, 1, 1),
          new Ap(-1, 1, 1),
          new Ap(1, 1, -1),
          new Ap(-1, 1, -1),
          new Ap(0, fg, mg),
          new Ap(0, fg, -mg),
          new Ap(mg, 0, fg),
          new Ap(-mg, 0, fg),
          new Ap(fg, mg, 0),
          new Ap(-fg, mg, 0),
        ];
      class vg {
        constructor(t) {
          (this._renderer = t),
            (this._pingPongRenderTarget = null),
            (this._lodMax = 0),
            (this._cubeSize = 0),
            (this._lodPlanes = []),
            (this._sizeLods = []),
            (this._sigmas = []),
            (this._blurMaterial = null),
            (this._cubemapMaterial = null),
            (this._equirectMaterial = null),
            this._compileMaterial(this._blurMaterial);
        }
        fromScene(t, e = 0, n = 0.1, i = 100) {
          (pg = this._renderer.getRenderTarget()), this._setSize(256);
          const r = this._allocateTargets();
          return (
            (r.depthBuffer = !0),
            this._sceneToCubeUV(t, n, i, r),
            e > 0 && this._blur(r, 0, 0, e),
            this._applyPMREM(r),
            this._cleanup(r),
            r
          );
        }
        fromEquirectangular(t, e = null) {
          return this._fromTexture(t, e);
        }
        fromCubemap(t, e = null) {
          return this._fromTexture(t, e);
        }
        compileCubemapShader() {
          null === this._cubemapMaterial &&
            ((this._cubemapMaterial = bg()),
            this._compileMaterial(this._cubemapMaterial));
        }
        compileEquirectangularShader() {
          null === this._equirectMaterial &&
            ((this._equirectMaterial = xg()),
            this._compileMaterial(this._equirectMaterial));
        }
        dispose() {
          this._dispose(),
            null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
            null !== this._equirectMaterial && this._equirectMaterial.dispose();
        }
        _setSize(t) {
          (this._lodMax = Math.floor(Math.log2(t))),
            (this._cubeSize = Math.pow(2, this._lodMax));
        }
        _dispose() {
          null !== this._blurMaterial && this._blurMaterial.dispose(),
            null !== this._pingPongRenderTarget &&
              this._pingPongRenderTarget.dispose();
          for (let t = 0; t < this._lodPlanes.length; t++)
            this._lodPlanes[t].dispose();
        }
        _cleanup(t) {
          this._renderer.setRenderTarget(pg),
            (t.scissorTest = !1),
            yg(t, 0, 0, t.width, t.height);
        }
        _fromTexture(t, e) {
          t.mapping === ed || t.mapping === nd
            ? this._setSize(
                0 === t.image.length
                  ? 16
                  : t.image[0].width || t.image[0].image.width
              )
            : this._setSize(t.image.width / 4),
            (pg = this._renderer.getRenderTarget());
          const n = e || this._allocateTargets();
          return (
            this._textureToCubeUV(t, n),
            this._applyPMREM(n),
            this._cleanup(n),
            n
          );
        }
        _allocateTargets() {
          const t = 3 * Math.max(this._cubeSize, 112),
            e = 4 * this._cubeSize,
            n = {
              magFilter: cd,
              minFilter: cd,
              generateMipmaps: !1,
              type: md,
              format: vd,
              colorSpace: Rd,
              depthBuffer: !1,
            },
            i = _g(t, e, n);
          if (
            null === this._pingPongRenderTarget ||
            this._pingPongRenderTarget.width !== t ||
            this._pingPongRenderTarget.height !== e
          ) {
            null !== this._pingPongRenderTarget && this._dispose(),
              (this._pingPongRenderTarget = _g(t, e, n));
            const { _lodMax: i } = this;
            ({
              sizeLods: this._sizeLods,
              lodPlanes: this._lodPlanes,
              sigmas: this._sigmas,
            } = (function (t) {
              const e = [],
                n = [],
                i = [];
              let r = t;
              const s = t - 4 + 1 + ug.length;
              for (let o = 0; o < s; o++) {
                const s = Math.pow(2, r);
                n.push(s);
                let a = 1 / s;
                o > t - 4 ? (a = ug[o - t + 4 - 1]) : 0 === o && (a = 0),
                  i.push(a);
                const l = 1 / (s - 2),
                  c = -l,
                  u = 1 + l,
                  h = [c, c, u, c, u, u, c, c, u, u, c, u],
                  d = 6,
                  p = 6,
                  f = 3,
                  m = 2,
                  g = 1,
                  v = new Float32Array(f * p * d),
                  _ = new Float32Array(m * p * d),
                  y = new Float32Array(g * p * d);
                for (let t = 0; t < d; t++) {
                  const e = ((t % 3) * 2) / 3 - 1,
                    n = t > 2 ? 0 : -1,
                    i = [
                      e,
                      n,
                      0,
                      e + 2 / 3,
                      n,
                      0,
                      e + 2 / 3,
                      n + 1,
                      0,
                      e,
                      n,
                      0,
                      e + 2 / 3,
                      n + 1,
                      0,
                      e,
                      n + 1,
                      0,
                    ];
                  v.set(i, f * p * t), _.set(h, m * p * t);
                  const r = [t, t, t, t, t, t];
                  y.set(r, g * p * t);
                }
                const x = new hm();
                x.setAttribute("position", new tm(v, f)),
                  x.setAttribute("uv", new tm(_, m)),
                  x.setAttribute("faceIndex", new tm(y, g)),
                  e.push(x),
                  r > 4 && r--;
              }
              return {
                lodPlanes: e,
                sizeLods: n,
                sigmas: i,
              };
            })(i)),
              (this._blurMaterial = (function (t, e, n) {
                const i = new Float32Array(20),
                  r = new Ap(0, 1, 0);
                return new Nm({
                  name: "SphericalGaussianBlur",
                  defines: {
                    n: 20,
                    CUBEUV_TEXEL_WIDTH: 1 / e,
                    CUBEUV_TEXEL_HEIGHT: 1 / n,
                    CUBEUV_MAX_MIP: `${t}.0`,
                  },
                  uniforms: {
                    envMap: {
                      value: null,
                    },
                    samples: {
                      value: 1,
                    },
                    weights: {
                      value: i,
                    },
                    latitudinal: {
                      value: !1,
                    },
                    dTheta: {
                      value: 0,
                    },
                    mipInt: {
                      value: 0,
                    },
                    poleAxis: {
                      value: r,
                    },
                  },
                  vertexShader:
                    "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                  fragmentShader:
                    "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                  blending: 0,
                  depthTest: !1,
                  depthWrite: !1,
                });
              })(i, t, e));
          }
          return i;
        }
        _compileMaterial(t) {
          const e = new Cm(this._lodPlanes[0], t);
          this._renderer.compile(e, hg);
        }
        _sceneToCubeUV(t, e, n, i) {
          const r = new km(90, 1, e, n),
            s = [1, -1, 1, 1, 1, 1],
            o = [1, 1, 1, -1, -1, -1],
            a = this._renderer,
            l = a.autoClear,
            c = a.toneMapping;
          a.getClearColor(dg), (a.toneMapping = Kh), (a.autoClear = !1);
          const u = new $f({
              name: "PMREM.Background",
              side: 1,
              depthWrite: !1,
              depthTest: !1,
            }),
            h = new Cm(new Rm(), u);
          let d = !1;
          const p = t.background;
          p
            ? p.isColor && (u.color.copy(p), (t.background = null), (d = !0))
            : (u.color.copy(dg), (d = !0));
          for (let e = 0; e < 6; e++) {
            const n = e % 3;
            0 === n
              ? (r.up.set(0, s[e], 0), r.lookAt(o[e], 0, 0))
              : 1 === n
              ? (r.up.set(0, 0, s[e]), r.lookAt(0, o[e], 0))
              : (r.up.set(0, s[e], 0), r.lookAt(0, 0, o[e]));
            const l = this._cubeSize;
            yg(i, n * l, e > 2 ? l : 0, l, l),
              a.setRenderTarget(i),
              d && a.render(h, r),
              a.render(t, r);
          }
          h.geometry.dispose(),
            h.material.dispose(),
            (a.toneMapping = c),
            (a.autoClear = l),
            (t.background = p);
        }
        _textureToCubeUV(t, e) {
          const n = this._renderer,
            i = t.mapping === ed || t.mapping === nd;
          i
            ? (null === this._cubemapMaterial && (this._cubemapMaterial = bg()),
              (this._cubemapMaterial.uniforms.flipEnvMap.value =
                !1 === t.isRenderTargetTexture ? -1 : 1))
            : null === this._equirectMaterial &&
              (this._equirectMaterial = xg());
          const r = i ? this._cubemapMaterial : this._equirectMaterial,
            s = new Cm(this._lodPlanes[0], r);
          r.uniforms.envMap.value = t;
          const o = this._cubeSize;
          yg(e, 0, 0, 3 * o, 2 * o), n.setRenderTarget(e), n.render(s, hg);
        }
        _applyPMREM(t) {
          const e = this._renderer,
            n = e.autoClear;
          e.autoClear = !1;
          for (let e = 1; e < this._lodPlanes.length; e++) {
            const n = Math.sqrt(
                this._sigmas[e] * this._sigmas[e] -
                  this._sigmas[e - 1] * this._sigmas[e - 1]
              ),
              i = gg[(e - 1) % gg.length];
            this._blur(t, e - 1, e, n, i);
          }
          e.autoClear = n;
        }
        _blur(t, e, n, i, r) {
          const s = this._pingPongRenderTarget;
          this._halfBlur(t, s, e, n, i, "latitudinal", r),
            this._halfBlur(s, t, n, n, i, "longitudinal", r);
        }
        _halfBlur(t, e, n, i, r, s, o) {
          const a = this._renderer,
            l = this._blurMaterial;
          "latitudinal" !== s &&
            "longitudinal" !== s &&
            console.error(
              "blur direction must be either latitudinal or longitudinal!"
            );
          const c = new Cm(this._lodPlanes[i], l),
            u = l.uniforms,
            h = this._sizeLods[n] - 1,
            d = isFinite(r) ? Math.PI / (2 * h) : (2 * Math.PI) / 39,
            p = r / d,
            f = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
          f > 20 &&
            console.warn(
              `sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`
            );
          const m = [];
          let g = 0;
          for (let t = 0; t < 20; ++t) {
            const e = t / p,
              n = Math.exp((-e * e) / 2);
            m.push(n), 0 === t ? (g += n) : t < f && (g += 2 * n);
          }
          for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
          (u.envMap.value = t.texture),
            (u.samples.value = f),
            (u.weights.value = m),
            (u.latitudinal.value = "latitudinal" === s),
            o && (u.poleAxis.value = o);
          const { _lodMax: v } = this;
          (u.dTheta.value = d), (u.mipInt.value = v - n);
          const _ = this._sizeLods[i];
          yg(
            e,
            3 * _ * (i > v - 4 ? i - v + 4 : 0),
            4 * (this._cubeSize - _),
            3 * _,
            2 * _
          ),
            a.setRenderTarget(e),
            a.render(c, hg);
        }
      }
      function _g(t, e, n) {
        const i = new Tp(t, e, n);
        return (
          (i.texture.mapping = id),
          (i.texture.name = "PMREM.cubeUv"),
          (i.scissorTest = !0),
          i
        );
      }
      function yg(t, e, n, i, r) {
        t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
      }
      function xg() {
        return new Nm({
          name: "EquirectangularToCubeUV",
          uniforms: {
            envMap: {
              value: null,
            },
          },
          vertexShader:
            "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
          fragmentShader:
            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
          blending: 0,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function bg() {
        return new Nm({
          name: "CubemapToCubeUV",
          uniforms: {
            envMap: {
              value: null,
            },
            flipEnvMap: {
              value: -1,
            },
          },
          vertexShader:
            "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
          fragmentShader:
            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
          blending: 0,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function Sg(t) {
        let e = new WeakMap(),
          n = null;
        function i(t) {
          const n = t.target;
          n.removeEventListener("dispose", i);
          const r = e.get(n);
          void 0 !== r && (e.delete(n), r.dispose());
        }
        return {
          get: function (r) {
            if (r && r.isTexture) {
              const s = r.mapping,
                o = 303 === s || 304 === s,
                a = s === ed || s === nd;
              if (o || a) {
                if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
                  r.needsPMREMUpdate = !1;
                  let i = e.get(r);
                  return (
                    null === n && (n = new vg(t)),
                    (i = o ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i)),
                    e.set(r, i),
                    i.texture
                  );
                }
                if (e.has(r)) return e.get(r).texture;
                {
                  const s = r.image;
                  if (
                    (o && s && s.height > 0) ||
                    (a &&
                      s &&
                      (function (t) {
                        let e = 0;
                        for (let n = 0; n < 6; n++) void 0 !== t[n] && e++;
                        return 6 === e;
                      })(s))
                  ) {
                    null === n && (n = new vg(t));
                    const s = o ? n.fromEquirectangular(r) : n.fromCubemap(r);
                    return (
                      e.set(r, s), r.addEventListener("dispose", i), s.texture
                    );
                  }
                  return null;
                }
              }
            }
            return r;
          },
          dispose: function () {
            (e = new WeakMap()), null !== n && (n.dispose(), (n = null));
          },
        };
      }
      function Eg(t) {
        const e = {};
        function n(n) {
          if (void 0 !== e[n]) return e[n];
          let i;
          switch (n) {
            case "WEBGL_depth_texture":
              i =
                t.getExtension("WEBGL_depth_texture") ||
                t.getExtension("MOZ_WEBGL_depth_texture") ||
                t.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              i =
                t.getExtension("EXT_texture_filter_anisotropic") ||
                t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              i =
                t.getExtension("WEBGL_compressed_texture_s3tc") ||
                t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              i =
                t.getExtension("WEBGL_compressed_texture_pvrtc") ||
                t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              i = t.getExtension(n);
          }
          return (e[n] = i), i;
        }
        return {
          has: function (t) {
            return null !== n(t);
          },
          init: function (t) {
            t.isWebGL2
              ? n("EXT_color_buffer_float")
              : (n("WEBGL_depth_texture"),
                n("OES_texture_float"),
                n("OES_texture_half_float"),
                n("OES_texture_half_float_linear"),
                n("OES_standard_derivatives"),
                n("OES_element_index_uint"),
                n("OES_vertex_array_object"),
                n("ANGLE_instanced_arrays")),
              n("OES_texture_float_linear"),
              n("EXT_color_buffer_half_float"),
              n("WEBGL_multisampled_render_to_texture");
          },
          get: function (t) {
            const e = n(t);
            return (
              null === e &&
                console.warn(
                  "THREE.WebGLRenderer: " + t + " extension not supported."
                ),
              e
            );
          },
        };
      }
      function Tg(t, e, n, i) {
        const r = {},
          s = new WeakMap();
        function o(t) {
          const a = t.target;
          null !== a.index && e.remove(a.index);
          for (const t in a.attributes) e.remove(a.attributes[t]);
          for (const t in a.morphAttributes) {
            const n = a.morphAttributes[t];
            for (let t = 0, i = n.length; t < i; t++) e.remove(n[t]);
          }
          a.removeEventListener("dispose", o), delete r[a.id];
          const l = s.get(a);
          l && (e.remove(l), s.delete(a)),
            i.releaseStatesOfGeometry(a),
            !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount,
            n.memory.geometries--;
        }
        function a(t) {
          const n = [],
            i = t.index,
            r = t.attributes.position;
          let o = 0;
          if (null !== i) {
            const t = i.array;
            o = i.version;
            for (let e = 0, i = t.length; e < i; e += 3) {
              const i = t[e + 0],
                r = t[e + 1],
                s = t[e + 2];
              n.push(i, r, r, s, s, i);
            }
          } else {
            if (void 0 === r) return;
            {
              const t = r.array;
              o = r.version;
              for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                const t = e + 0,
                  i = e + 1,
                  r = e + 2;
                n.push(t, i, i, r, r, t);
              }
            }
          }
          const a = new (ip(n) ? nm : em)(n, 1);
          a.version = o;
          const l = s.get(t);
          l && e.remove(l), s.set(t, a);
        }
        return {
          get: function (t, e) {
            return (
              !0 === r[e.id] ||
                (e.addEventListener("dispose", o),
                (r[e.id] = !0),
                n.memory.geometries++),
              e
            );
          },
          update: function (n) {
            const i = n.attributes;
            for (const n in i) e.update(i[n], t.ARRAY_BUFFER);
            const r = n.morphAttributes;
            for (const n in r) {
              const i = r[n];
              for (let n = 0, r = i.length; n < r; n++)
                e.update(i[n], t.ARRAY_BUFFER);
            }
          },
          getWireframeAttribute: function (t) {
            const e = s.get(t);
            if (e) {
              const n = t.index;
              null !== n && e.version < n.version && a(t);
            } else a(t);
            return s.get(t);
          },
        };
      }
      function Mg(t, e, n, i) {
        const r = i.isWebGL2;
        let s, o, a;
        (this.setMode = function (t) {
          s = t;
        }),
          (this.setIndex = function (t) {
            (o = t.type), (a = t.bytesPerElement);
          }),
          (this.render = function (e, i) {
            t.drawElements(s, i, o, e * a), n.update(i, s, 1);
          }),
          (this.renderInstances = function (i, l, c) {
            if (0 === c) return;
            let u, h;
            if (r) (u = t), (h = "drawElementsInstanced");
            else if (
              ((u = e.get("ANGLE_instanced_arrays")),
              (h = "drawElementsInstancedANGLE"),
              null === u)
            )
              return void console.error(
                "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
              );
            u[h](s, l, o, i * a, c), n.update(l, s, c);
          });
      }
      function wg(t) {
        const e = {
          frame: 0,
          calls: 0,
          triangles: 0,
          points: 0,
          lines: 0,
        };
        return {
          memory: {
            geometries: 0,
            textures: 0,
          },
          render: e,
          programs: null,
          autoReset: !0,
          reset: function () {
            (e.calls = 0), (e.triangles = 0), (e.points = 0), (e.lines = 0);
          },
          update: function (n, i, r) {
            switch ((e.calls++, i)) {
              case t.TRIANGLES:
                e.triangles += r * (n / 3);
                break;
              case t.LINES:
                e.lines += r * (n / 2);
                break;
              case t.LINE_STRIP:
                e.lines += r * (n - 1);
                break;
              case t.LINE_LOOP:
                e.lines += r * n;
                break;
              case t.POINTS:
                e.points += r * n;
                break;
              default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", i);
            }
          },
        };
      }
      function Dg(t, e) {
        return t[0] - e[0];
      }
      function Ag(t, e) {
        return Math.abs(e[1]) - Math.abs(t[1]);
      }
      function Cg(t, e, n) {
        const i = {},
          r = new Float32Array(8),
          s = new WeakMap(),
          o = new Sp(),
          a = [];
        for (let t = 0; t < 8; t++) a[t] = [t, 0];
        return {
          update: function (l, c, u) {
            const h = l.morphTargetInfluences;
            if (!0 === e.isWebGL2) {
              const d =
                  c.morphAttributes.position ||
                  c.morphAttributes.normal ||
                  c.morphAttributes.color,
                p = void 0 !== d ? d.length : 0;
              let f = s.get(c);
              if (void 0 === f || f.count !== p) {
                void 0 !== f && f.texture.dispose();
                const v = void 0 !== c.morphAttributes.position,
                  _ = void 0 !== c.morphAttributes.normal,
                  y = void 0 !== c.morphAttributes.color,
                  x = c.morphAttributes.position || [],
                  b = c.morphAttributes.normal || [],
                  S = c.morphAttributes.color || [];
                let E = 0;
                !0 === v && (E = 1), !0 === _ && (E = 2), !0 === y && (E = 3);
                let T = c.attributes.position.count * E,
                  M = 1;
                T > e.maxTextureSize &&
                  ((M = Math.ceil(T / e.maxTextureSize)),
                  (T = e.maxTextureSize));
                const w = new Float32Array(T * M * 4 * p),
                  D = new Mp(w, T, M, p);
                (D.type = fd), (D.needsUpdate = !0);
                const A = 4 * E;
                for (let P = 0; P < p; P++) {
                  const R = x[P],
                    L = b[P],
                    O = S[P],
                    I = T * M * 4 * P;
                  for (let F = 0; F < R.count; F++) {
                    const N = F * A;
                    !0 === v &&
                      (o.fromBufferAttribute(R, F),
                      (w[I + N + 0] = o.x),
                      (w[I + N + 1] = o.y),
                      (w[I + N + 2] = o.z),
                      (w[I + N + 3] = 0)),
                      !0 === _ &&
                        (o.fromBufferAttribute(L, F),
                        (w[I + N + 4] = o.x),
                        (w[I + N + 5] = o.y),
                        (w[I + N + 6] = o.z),
                        (w[I + N + 7] = 0)),
                      !0 === y &&
                        (o.fromBufferAttribute(O, F),
                        (w[I + N + 8] = o.x),
                        (w[I + N + 9] = o.y),
                        (w[I + N + 10] = o.z),
                        (w[I + N + 11] = 4 === O.itemSize ? o.w : 1));
                  }
                }
                function C() {
                  D.dispose(), s.delete(c), c.removeEventListener("dispose", C);
                }
                (f = {
                  count: p,
                  texture: D,
                  size: new tp(T, M),
                }),
                  s.set(c, f),
                  c.addEventListener("dispose", C);
              }
              let m = 0;
              for (let U = 0; U < h.length; U++) m += h[U];
              const g = c.morphTargetsRelative ? 1 : 1 - m;
              u.getUniforms().setValue(t, "morphTargetBaseInfluence", g),
                u.getUniforms().setValue(t, "morphTargetInfluences", h),
                u
                  .getUniforms()
                  .setValue(t, "morphTargetsTexture", f.texture, n),
                u.getUniforms().setValue(t, "morphTargetsTextureSize", f.size);
            } else {
              const k = void 0 === h ? 0 : h.length;
              let z = i[c.id];
              if (void 0 === z || z.length !== k) {
                z = [];
                for (let W = 0; W < k; W++) z[W] = [W, 0];
                i[c.id] = z;
              }
              for (let j = 0; j < k; j++) {
                const X = z[j];
                (X[0] = j), (X[1] = h[j]);
              }
              z.sort(Ag);
              for (let q = 0; q < 8; q++)
                q < k && z[q][1]
                  ? ((a[q][0] = z[q][0]), (a[q][1] = z[q][1]))
                  : ((a[q][0] = Number.MAX_SAFE_INTEGER), (a[q][1] = 0));
              a.sort(Dg);
              const B = c.morphAttributes.position,
                H = c.morphAttributes.normal;
              let V = 0;
              for (let Y = 0; Y < 8; Y++) {
                const K = a[Y],
                  Z = K[0],
                  $ = K[1];
                Z !== Number.MAX_SAFE_INTEGER && $
                  ? (B &&
                      c.getAttribute("morphTarget" + Y) !== B[Z] &&
                      c.setAttribute("morphTarget" + Y, B[Z]),
                    H &&
                      c.getAttribute("morphNormal" + Y) !== H[Z] &&
                      c.setAttribute("morphNormal" + Y, H[Z]),
                    (r[Y] = $),
                    (V += $))
                  : (B &&
                      !0 === c.hasAttribute("morphTarget" + Y) &&
                      c.deleteAttribute("morphTarget" + Y),
                    H &&
                      !0 === c.hasAttribute("morphNormal" + Y) &&
                      c.deleteAttribute("morphNormal" + Y),
                    (r[Y] = 0));
              }
              const G = c.morphTargetsRelative ? 1 : 1 - V;
              u.getUniforms().setValue(t, "morphTargetBaseInfluence", G),
                u.getUniforms().setValue(t, "morphTargetInfluences", r);
            }
          },
        };
      }
      function Pg(t, e, n, i) {
        let r = new WeakMap();
        function s(t) {
          const e = t.target;
          e.removeEventListener("dispose", s),
            n.remove(e.instanceMatrix),
            null !== e.instanceColor && n.remove(e.instanceColor);
        }
        return {
          update: function (o) {
            const a = i.render.frame,
              l = o.geometry,
              c = e.get(o, l);
            if (
              (r.get(c) !== a && (e.update(c), r.set(c, a)),
              o.isInstancedMesh &&
                (!1 === o.hasEventListener("dispose", s) &&
                  o.addEventListener("dispose", s),
                r.get(o) !== a &&
                  (n.update(o.instanceMatrix, t.ARRAY_BUFFER),
                  null !== o.instanceColor &&
                    n.update(o.instanceColor, t.ARRAY_BUFFER),
                  r.set(o, a))),
              o.isSkinnedMesh)
            ) {
              const t = o.skeleton;
              r.get(t) !== a && (t.update(), r.set(t, a));
            }
            return c;
          },
          dispose: function () {
            r = new WeakMap();
          },
        };
      }
      const Rg = new bp(),
        Lg = new Mp(),
        Og = new wp(),
        Ig = new Hm(),
        Fg = [],
        Ng = [],
        Ug = new Float32Array(16),
        kg = new Float32Array(9),
        zg = new Float32Array(4);
      function Bg(t, e, n) {
        const i = t[0];
        if (i <= 0 || i > 0) return t;
        const r = e * n;
        let s = Fg[r];
        if (
          (void 0 === s && ((s = new Float32Array(r)), (Fg[r] = s)), 0 !== e)
        ) {
          i.toArray(s, 0);
          for (let i = 1, r = 0; i !== e; ++i) (r += n), t[i].toArray(s, r);
        }
        return s;
      }
      function Hg(t, e) {
        if (t.length !== e.length) return !1;
        for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;
        return !0;
      }
      function Vg(t, e) {
        for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
      }
      function Gg(t, e) {
        let n = Ng[e];
        void 0 === n && ((n = new Int32Array(e)), (Ng[e] = n));
        for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
        return n;
      }
      function Wg(t, e) {
        const n = this.cache;
        n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
      }
      function jg(t, e) {
        const n = this.cache;
        if (void 0 !== e.x)
          (n[0] === e.x && n[1] === e.y) ||
            (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
        else {
          if (Hg(n, e)) return;
          t.uniform2fv(this.addr, e), Vg(n, e);
        }
      }
      function Xg(t, e) {
        const n = this.cache;
        if (void 0 !== e.x)
          (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
            (t.uniform3f(this.addr, e.x, e.y, e.z),
            (n[0] = e.x),
            (n[1] = e.y),
            (n[2] = e.z));
        else if (void 0 !== e.r)
          (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
            (t.uniform3f(this.addr, e.r, e.g, e.b),
            (n[0] = e.r),
            (n[1] = e.g),
            (n[2] = e.b));
        else {
          if (Hg(n, e)) return;
          t.uniform3fv(this.addr, e), Vg(n, e);
        }
      }
      function qg(t, e) {
        const n = this.cache;
        if (void 0 !== e.x)
          (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
            (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
            (n[0] = e.x),
            (n[1] = e.y),
            (n[2] = e.z),
            (n[3] = e.w));
        else {
          if (Hg(n, e)) return;
          t.uniform4fv(this.addr, e), Vg(n, e);
        }
      }
      function Yg(t, e) {
        const n = this.cache,
          i = e.elements;
        if (void 0 === i) {
          if (Hg(n, e)) return;
          t.uniformMatrix2fv(this.addr, !1, e), Vg(n, e);
        } else {
          if (Hg(n, i)) return;
          zg.set(i), t.uniformMatrix2fv(this.addr, !1, zg), Vg(n, i);
        }
      }
      function Kg(t, e) {
        const n = this.cache,
          i = e.elements;
        if (void 0 === i) {
          if (Hg(n, e)) return;
          t.uniformMatrix3fv(this.addr, !1, e), Vg(n, e);
        } else {
          if (Hg(n, i)) return;
          kg.set(i), t.uniformMatrix3fv(this.addr, !1, kg), Vg(n, i);
        }
      }
      function Zg(t, e) {
        const n = this.cache,
          i = e.elements;
        if (void 0 === i) {
          if (Hg(n, e)) return;
          t.uniformMatrix4fv(this.addr, !1, e), Vg(n, e);
        } else {
          if (Hg(n, i)) return;
          Ug.set(i), t.uniformMatrix4fv(this.addr, !1, Ug), Vg(n, i);
        }
      }
      function $g(t, e) {
        const n = this.cache;
        n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
      }
      function Jg(t, e) {
        const n = this.cache;
        if (void 0 !== e.x)
          (n[0] === e.x && n[1] === e.y) ||
            (t.uniform2i(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
        else {
          if (Hg(n, e)) return;
          t.uniform2iv(this.addr, e), Vg(n, e);
        }
      }
      function Qg(t, e) {
        const n = this.cache;
        if (void 0 !== e.x)
          (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
            (t.uniform3i(this.addr, e.x, e.y, e.z),
            (n[0] = e.x),
            (n[1] = e.y),
            (n[2] = e.z));
        else {
          if (Hg(n, e)) return;
          t.uniform3iv(this.addr, e), Vg(n, e);
        }
      }
      function tv(t, e) {
        const n = this.cache;
        if (void 0 !== e.x)
          (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
            (t.uniform4i(this.addr, e.x, e.y, e.z, e.w),
            (n[0] = e.x),
            (n[1] = e.y),
            (n[2] = e.z),
            (n[3] = e.w));
        else {
          if (Hg(n, e)) return;
          t.uniform4iv(this.addr, e), Vg(n, e);
        }
      }
      function ev(t, e) {
        const n = this.cache;
        n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
      }
      function nv(t, e) {
        const n = this.cache;
        if (void 0 !== e.x)
          (n[0] === e.x && n[1] === e.y) ||
            (t.uniform2ui(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
        else {
          if (Hg(n, e)) return;
          t.uniform2uiv(this.addr, e), Vg(n, e);
        }
      }
      function iv(t, e) {
        const n = this.cache;
        if (void 0 !== e.x)
          (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
            (t.uniform3ui(this.addr, e.x, e.y, e.z),
            (n[0] = e.x),
            (n[1] = e.y),
            (n[2] = e.z));
        else {
          if (Hg(n, e)) return;
          t.uniform3uiv(this.addr, e), Vg(n, e);
        }
      }
      function rv(t, e) {
        const n = this.cache;
        if (void 0 !== e.x)
          (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
            (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
            (n[0] = e.x),
            (n[1] = e.y),
            (n[2] = e.z),
            (n[3] = e.w));
        else {
          if (Hg(n, e)) return;
          t.uniform4uiv(this.addr, e), Vg(n, e);
        }
      }
      function sv(t, e, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
          n.setTexture2D(e || Rg, r);
      }
      function ov(t, e, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
          n.setTexture3D(e || Og, r);
      }
      function av(t, e, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
          n.setTextureCube(e || Ig, r);
      }
      function lv(t, e, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
          n.setTexture2DArray(e || Lg, r);
      }
      function cv(t, e) {
        t.uniform1fv(this.addr, e);
      }
      function uv(t, e) {
        const n = Bg(e, this.size, 2);
        t.uniform2fv(this.addr, n);
      }
      function hv(t, e) {
        const n = Bg(e, this.size, 3);
        t.uniform3fv(this.addr, n);
      }
      function dv(t, e) {
        const n = Bg(e, this.size, 4);
        t.uniform4fv(this.addr, n);
      }
      function pv(t, e) {
        const n = Bg(e, this.size, 4);
        t.uniformMatrix2fv(this.addr, !1, n);
      }
      function fv(t, e) {
        const n = Bg(e, this.size, 9);
        t.uniformMatrix3fv(this.addr, !1, n);
      }
      function mv(t, e) {
        const n = Bg(e, this.size, 16);
        t.uniformMatrix4fv(this.addr, !1, n);
      }
      function gv(t, e) {
        t.uniform1iv(this.addr, e);
      }
      function vv(t, e) {
        t.uniform2iv(this.addr, e);
      }
      function _v(t, e) {
        t.uniform3iv(this.addr, e);
      }
      function yv(t, e) {
        t.uniform4iv(this.addr, e);
      }
      function xv(t, e) {
        t.uniform1uiv(this.addr, e);
      }
      function bv(t, e) {
        t.uniform2uiv(this.addr, e);
      }
      function Sv(t, e) {
        t.uniform3uiv(this.addr, e);
      }
      function Ev(t, e) {
        t.uniform4uiv(this.addr, e);
      }
      function Tv(t, e, n) {
        const i = this.cache,
          r = e.length,
          s = Gg(n, r);
        Hg(i, s) || (t.uniform1iv(this.addr, s), Vg(i, s));
        for (let t = 0; t !== r; ++t) n.setTexture2D(e[t] || Rg, s[t]);
      }
      function Mv(t, e, n) {
        const i = this.cache,
          r = e.length,
          s = Gg(n, r);
        Hg(i, s) || (t.uniform1iv(this.addr, s), Vg(i, s));
        for (let t = 0; t !== r; ++t) n.setTexture3D(e[t] || Og, s[t]);
      }
      function wv(t, e, n) {
        const i = this.cache,
          r = e.length,
          s = Gg(n, r);
        Hg(i, s) || (t.uniform1iv(this.addr, s), Vg(i, s));
        for (let t = 0; t !== r; ++t) n.setTextureCube(e[t] || Ig, s[t]);
      }
      function Dv(t, e, n) {
        const i = this.cache,
          r = e.length,
          s = Gg(n, r);
        Hg(i, s) || (t.uniform1iv(this.addr, s), Vg(i, s));
        for (let t = 0; t !== r; ++t) n.setTexture2DArray(e[t] || Lg, s[t]);
      }
      class Av {
        constructor(t, e, n) {
          (this.id = t),
            (this.addr = n),
            (this.cache = []),
            (this.setValue = (function (t) {
              switch (t) {
                case 5126:
                  return Wg;
                case 35664:
                  return jg;
                case 35665:
                  return Xg;
                case 35666:
                  return qg;
                case 35674:
                  return Yg;
                case 35675:
                  return Kg;
                case 35676:
                  return Zg;
                case 5124:
                case 35670:
                  return $g;
                case 35667:
                case 35671:
                  return Jg;
                case 35668:
                case 35672:
                  return Qg;
                case 35669:
                case 35673:
                  return tv;
                case 5125:
                  return ev;
                case 36294:
                  return nv;
                case 36295:
                  return iv;
                case 36296:
                  return rv;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                  return sv;
                case 35679:
                case 36299:
                case 36307:
                  return ov;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                  return av;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                  return lv;
              }
            })(e.type));
        }
      }
      class Cv {
        constructor(t, e, n) {
          (this.id = t),
            (this.addr = n),
            (this.cache = []),
            (this.size = e.size),
            (this.setValue = (function (t) {
              switch (t) {
                case 5126:
                  return cv;
                case 35664:
                  return uv;
                case 35665:
                  return hv;
                case 35666:
                  return dv;
                case 35674:
                  return pv;
                case 35675:
                  return fv;
                case 35676:
                  return mv;
                case 5124:
                case 35670:
                  return gv;
                case 35667:
                case 35671:
                  return vv;
                case 35668:
                case 35672:
                  return _v;
                case 35669:
                case 35673:
                  return yv;
                case 5125:
                  return xv;
                case 36294:
                  return bv;
                case 36295:
                  return Sv;
                case 36296:
                  return Ev;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                  return Tv;
                case 35679:
                case 36299:
                case 36307:
                  return Mv;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                  return wv;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                  return Dv;
              }
            })(e.type));
        }
      }
      class Pv {
        constructor(t) {
          (this.id = t), (this.seq = []), (this.map = {});
        }
        setValue(t, e, n) {
          const i = this.seq;
          for (let r = 0, s = i.length; r !== s; ++r) {
            const s = i[r];
            s.setValue(t, e[s.id], n);
          }
        }
      }
      const Rv = /(\w+)(\])?(\[|\.)?/g;
      function Lv(t, e) {
        t.seq.push(e), (t.map[e.id] = e);
      }
      function Ov(t, e, n) {
        const i = t.name,
          r = i.length;
        for (Rv.lastIndex = 0; ; ) {
          const s = Rv.exec(i),
            o = Rv.lastIndex;
          let a = s[1];
          const l = "]" === s[2],
            c = s[3];
          if ((l && (a |= 0), void 0 === c || ("[" === c && o + 2 === r))) {
            Lv(n, void 0 === c ? new Av(a, t, e) : new Cv(a, t, e));
            break;
          }
          {
            let t = n.map[a];
            void 0 === t && ((t = new Pv(a)), Lv(n, t)), (n = t);
          }
        }
      }
      class Iv {
        constructor(t, e) {
          (this.seq = []), (this.map = {});
          const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
          for (let i = 0; i < n; ++i) {
            const n = t.getActiveUniform(e, i);
            Ov(n, t.getUniformLocation(e, n.name), this);
          }
        }
        setValue(t, e, n, i) {
          const r = this.map[e];
          void 0 !== r && r.setValue(t, n, i);
        }
        setOptional(t, e, n) {
          const i = e[n];
          void 0 !== i && this.setValue(t, n, i);
        }
        static upload(t, e, n, i) {
          for (let r = 0, s = e.length; r !== s; ++r) {
            const s = e[r],
              o = n[s.id];
            !1 !== o.needsUpdate && s.setValue(t, o.value, i);
          }
        }
        static seqWithValue(t, e) {
          const n = [];
          for (let i = 0, r = t.length; i !== r; ++i) {
            const r = t[i];
            r.id in e && n.push(r);
          }
          return n;
        }
      }
      function Fv(t, e, n) {
        const i = t.createShader(e);
        return t.shaderSource(i, n), t.compileShader(i), i;
      }
      let Nv = 0;
      function Uv(t, e, n) {
        const i = t.getShaderParameter(e, t.COMPILE_STATUS),
          r = t.getShaderInfoLog(e).trim();
        if (i && "" === r) return "";
        const s = /ERROR: 0:(\d+)/.exec(r);
        if (s) {
          const i = parseInt(s[1]);
          return (
            n.toUpperCase() +
            "\n\n" +
            r +
            "\n\n" +
            (function (t, e) {
              const n = t.split("\n"),
                i = [],
                r = Math.max(e - 6, 0),
                s = Math.min(e + 6, n.length);
              for (let t = r; t < s; t++) {
                const r = t + 1;
                i.push(`${r === e ? ">" : " "} ${r}: ${n[t]}`);
              }
              return i.join("\n");
            })(t.getShaderSource(e), i)
          );
        }
        return r;
      }
      function kv(t, e) {
        const n = (function (t) {
          const e = dp.getPrimaries(dp.workingColorSpace),
            n = dp.getPrimaries(t);
          let i;
          switch (
            (e === n
              ? (i = "")
              : e === Ud && n === Nd
              ? (i = "LinearDisplayP3ToLinearSRGB")
              : e === Nd && n === Ud && (i = "LinearSRGBToLinearDisplayP3"),
            t)
          ) {
            case Rd:
            case Od:
              return [i, "LinearTransferOETF"];
            case Pd:
            case Ld:
              return [i, "sRGBTransferOETF"];
            default:
              return (
                console.warn("THREE.WebGLProgram: Unsupported color space:", t),
                [i, "LinearTransferOETF"]
              );
          }
        })(e);
        return `vec4 ${t}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }`;
      }
      function zv(t, e) {
        let n;
        switch (e) {
          case Zh:
            n = "Linear";
            break;
          case $h:
            n = "Reinhard";
            break;
          case Jh:
            n = "OptimizedCineon";
            break;
          case Qh:
            n = "ACESFilmic";
            break;
          case td:
            n = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
              (n = "Linear");
        }
        return (
          "vec3 " +
          t +
          "( vec3 color ) { return " +
          n +
          "ToneMapping( color ); }"
        );
      }
      function Bv(t) {
        return "" !== t;
      }
      function Hv(t, e) {
        const n =
          e.numSpotLightShadows +
          e.numSpotLightMaps -
          e.numSpotLightShadowsWithMaps;
        return t
          .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
          .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
          .replace(/NUM_SPOT_LIGHT_COORDS/g, n)
          .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
          .replace(
            /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,
            e.numSpotLightShadowsWithMaps
          )
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
      }
      function Vv(t, e) {
        return t
          .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
          .replace(
            /UNION_CLIPPING_PLANES/g,
            e.numClippingPlanes - e.numClipIntersection
          );
      }
      const Gv = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function Wv(t) {
        return t.replace(Gv, Xv);
      }
      const jv = new Map([
        ["encodings_fragment", "colorspace_fragment"],
        ["encodings_pars_fragment", "colorspace_pars_fragment"],
        ["output_fragment", "opaque_fragment"],
      ]);
      function Xv(t, e) {
        let n = Qm[e];
        if (void 0 === n) {
          const t = jv.get(e);
          if (void 0 === t)
            throw new Error("Can not resolve #include <" + e + ">");
          (n = Qm[t]),
            console.warn(
              'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
              e,
              t
            );
        }
        return Wv(n);
      }
      const qv =
        /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function Yv(t) {
        return t.replace(qv, Kv);
      }
      function Kv(t, e, n, i) {
        let r = "";
        for (let t = parseInt(e); t < parseInt(n); t++)
          r += i
            .replace(/\[\s*i\s*\]/g, "[ " + t + " ]")
            .replace(/UNROLLED_LOOP_INDEX/g, t);
        return r;
      }
      function Zv(t) {
        let e =
          "precision " +
          t.precision +
          " float;\nprecision " +
          t.precision +
          " int;";
        return (
          "highp" === t.precision
            ? (e += "\n#define HIGH_PRECISION")
            : "mediump" === t.precision
            ? (e += "\n#define MEDIUM_PRECISION")
            : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
          e
        );
      }
      function $v(t, e, n, i) {
        const r = t.getContext(),
          s = n.defines;
        let o = n.vertexShader,
          a = n.fragmentShader;
        const l = (function (t) {
            let e = "SHADOWMAP_TYPE_BASIC";
            return (
              t.shadowMapType === Vh
                ? (e = "SHADOWMAP_TYPE_PCF")
                : t.shadowMapType === Gh
                ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
                : t.shadowMapType === Wh && (e = "SHADOWMAP_TYPE_VSM"),
              e
            );
          })(n),
          c = (function (t) {
            let e = "ENVMAP_TYPE_CUBE";
            if (t.envMap)
              switch (t.envMapMode) {
                case ed:
                case nd:
                  e = "ENVMAP_TYPE_CUBE";
                  break;
                case id:
                  e = "ENVMAP_TYPE_CUBE_UV";
              }
            return e;
          })(n),
          u = (function (t) {
            let e = "ENVMAP_MODE_REFLECTION";
            return (
              t.envMap && t.envMapMode === nd && (e = "ENVMAP_MODE_REFRACTION"),
              e
            );
          })(n),
          h = (function (t) {
            let e = "ENVMAP_BLENDING_NONE";
            if (t.envMap)
              switch (t.combine) {
                case Xh:
                  e = "ENVMAP_BLENDING_MULTIPLY";
                  break;
                case qh:
                  e = "ENVMAP_BLENDING_MIX";
                  break;
                case Yh:
                  e = "ENVMAP_BLENDING_ADD";
              }
            return e;
          })(n),
          d = (function (t) {
            const e = t.envMapCubeUVHeight;
            if (null === e) return null;
            const n = Math.log2(e) - 2,
              i = 1 / e;
            return {
              texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
              texelHeight: i,
              maxMip: n,
            };
          })(n),
          p = n.isWebGL2
            ? ""
            : (function (t) {
                return [
                  t.extensionDerivatives ||
                  t.envMapCubeUVHeight ||
                  t.bumpMap ||
                  t.normalMapTangentSpace ||
                  t.clearcoatNormalMap ||
                  t.flatShading ||
                  "physical" === t.shaderID
                    ? "#extension GL_OES_standard_derivatives : enable"
                    : "",
                  (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
                  t.rendererExtensionFragDepth
                    ? "#extension GL_EXT_frag_depth : enable"
                    : "",
                  t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
                    ? "#extension GL_EXT_draw_buffers : require"
                    : "",
                  (t.extensionShaderTextureLOD || t.envMap || t.transmission) &&
                  t.rendererExtensionShaderTextureLod
                    ? "#extension GL_EXT_shader_texture_lod : enable"
                    : "",
                ]
                  .filter(Bv)
                  .join("\n");
              })(n),
          f = (function (t) {
            const e = [];
            for (const n in t) {
              const i = t[n];
              !1 !== i && e.push("#define " + n + " " + i);
            }
            return e.join("\n");
          })(s),
          m = r.createProgram();
        let g,
          v,
          _ = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
        n.isRawShaderMaterial
          ? ((g = [
              "#define SHADER_TYPE " + n.shaderType,
              "#define SHADER_NAME " + n.shaderName,
              f,
            ]
              .filter(Bv)
              .join("\n")),
            g.length > 0 && (g += "\n"),
            (v = [
              p,
              "#define SHADER_TYPE " + n.shaderType,
              "#define SHADER_NAME " + n.shaderName,
              f,
            ]
              .filter(Bv)
              .join("\n")),
            v.length > 0 && (v += "\n"))
          : ((g = [
              Zv(n),
              "#define SHADER_TYPE " + n.shaderType,
              "#define SHADER_NAME " + n.shaderName,
              f,
              n.instancing ? "#define USE_INSTANCING" : "",
              n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
              n.useFog && n.fog ? "#define USE_FOG" : "",
              n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
              n.map ? "#define USE_MAP" : "",
              n.envMap ? "#define USE_ENVMAP" : "",
              n.envMap ? "#define " + u : "",
              n.lightMap ? "#define USE_LIGHTMAP" : "",
              n.aoMap ? "#define USE_AOMAP" : "",
              n.bumpMap ? "#define USE_BUMPMAP" : "",
              n.normalMap ? "#define USE_NORMALMAP" : "",
              n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
              n.normalMapTangentSpace
                ? "#define USE_NORMALMAP_TANGENTSPACE"
                : "",
              n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
              n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              n.anisotropy ? "#define USE_ANISOTROPY" : "",
              n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
              n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              n.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
              n.iridescenceThicknessMap
                ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                : "",
              n.specularMap ? "#define USE_SPECULARMAP" : "",
              n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
              n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
              n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              n.metalnessMap ? "#define USE_METALNESSMAP" : "",
              n.alphaMap ? "#define USE_ALPHAMAP" : "",
              n.alphaHash ? "#define USE_ALPHAHASH" : "",
              n.transmission ? "#define USE_TRANSMISSION" : "",
              n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
              n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
              n.mapUv ? "#define MAP_UV " + n.mapUv : "",
              n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "",
              n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "",
              n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "",
              n.emissiveMapUv
                ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv
                : "",
              n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "",
              n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "",
              n.displacementMapUv
                ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv
                : "",
              n.metalnessMapUv
                ? "#define METALNESSMAP_UV " + n.metalnessMapUv
                : "",
              n.roughnessMapUv
                ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv
                : "",
              n.anisotropyMapUv
                ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv
                : "",
              n.clearcoatMapUv
                ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv
                : "",
              n.clearcoatNormalMapUv
                ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv
                : "",
              n.clearcoatRoughnessMapUv
                ? "#define CLEARCOAT_ROUGHNESSMAP_UV " +
                  n.clearcoatRoughnessMapUv
                : "",
              n.iridescenceMapUv
                ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv
                : "",
              n.iridescenceThicknessMapUv
                ? "#define IRIDESCENCE_THICKNESSMAP_UV " +
                  n.iridescenceThicknessMapUv
                : "",
              n.sheenColorMapUv
                ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv
                : "",
              n.sheenRoughnessMapUv
                ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv
                : "",
              n.specularMapUv
                ? "#define SPECULARMAP_UV " + n.specularMapUv
                : "",
              n.specularColorMapUv
                ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv
                : "",
              n.specularIntensityMapUv
                ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv
                : "",
              n.transmissionMapUv
                ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv
                : "",
              n.thicknessMapUv
                ? "#define THICKNESSMAP_UV " + n.thicknessMapUv
                : "",
              n.vertexTangents && !1 === n.flatShading
                ? "#define USE_TANGENT"
                : "",
              n.vertexColors ? "#define USE_COLOR" : "",
              n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              n.vertexUv1s ? "#define USE_UV1" : "",
              n.vertexUv2s ? "#define USE_UV2" : "",
              n.vertexUv3s ? "#define USE_UV3" : "",
              n.pointsUvs ? "#define USE_POINTS_UV" : "",
              n.flatShading ? "#define FLAT_SHADED" : "",
              n.skinning ? "#define USE_SKINNING" : "",
              n.morphTargets ? "#define USE_MORPHTARGETS" : "",
              n.morphNormals && !1 === n.flatShading
                ? "#define USE_MORPHNORMALS"
                : "",
              n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
              n.morphTargetsCount > 0 && n.isWebGL2
                ? "#define MORPHTARGETS_TEXTURE"
                : "",
              n.morphTargetsCount > 0 && n.isWebGL2
                ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride
                : "",
              n.morphTargetsCount > 0 && n.isWebGL2
                ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount
                : "",
              n.doubleSided ? "#define DOUBLE_SIDED" : "",
              n.flipSided ? "#define FLIP_SIDED" : "",
              n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              n.shadowMapEnabled ? "#define " + l : "",
              n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
              n.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
              n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              "\tattribute mat4 instanceMatrix;",
              "#endif",
              "#ifdef USE_INSTANCING_COLOR",
              "\tattribute vec3 instanceColor;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_UV1",
              "\tattribute vec2 uv1;",
              "#endif",
              "#ifdef USE_UV2",
              "\tattribute vec2 uv2;",
              "#endif",
              "#ifdef USE_UV3",
              "\tattribute vec2 uv3;",
              "#endif",
              "#ifdef USE_TANGENT",
              "\tattribute vec4 tangent;",
              "#endif",
              "#if defined( USE_COLOR_ALPHA )",
              "\tattribute vec4 color;",
              "#elif defined( USE_COLOR )",
              "\tattribute vec3 color;",
              "#endif",
              "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
              "\tattribute vec3 morphTarget0;",
              "\tattribute vec3 morphTarget1;",
              "\tattribute vec3 morphTarget2;",
              "\tattribute vec3 morphTarget3;",
              "\t#ifdef USE_MORPHNORMALS",
              "\t\tattribute vec3 morphNormal0;",
              "\t\tattribute vec3 morphNormal1;",
              "\t\tattribute vec3 morphNormal2;",
              "\t\tattribute vec3 morphNormal3;",
              "\t#else",
              "\t\tattribute vec3 morphTarget4;",
              "\t\tattribute vec3 morphTarget5;",
              "\t\tattribute vec3 morphTarget6;",
              "\t\tattribute vec3 morphTarget7;",
              "\t#endif",
              "#endif",
              "#ifdef USE_SKINNING",
              "\tattribute vec4 skinIndex;",
              "\tattribute vec4 skinWeight;",
              "#endif",
              "\n",
            ]
              .filter(Bv)
              .join("\n")),
            (v = [
              p,
              Zv(n),
              "#define SHADER_TYPE " + n.shaderType,
              "#define SHADER_NAME " + n.shaderName,
              f,
              n.useFog && n.fog ? "#define USE_FOG" : "",
              n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
              n.map ? "#define USE_MAP" : "",
              n.matcap ? "#define USE_MATCAP" : "",
              n.envMap ? "#define USE_ENVMAP" : "",
              n.envMap ? "#define " + c : "",
              n.envMap ? "#define " + u : "",
              n.envMap ? "#define " + h : "",
              d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
              d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
              d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
              n.lightMap ? "#define USE_LIGHTMAP" : "",
              n.aoMap ? "#define USE_AOMAP" : "",
              n.bumpMap ? "#define USE_BUMPMAP" : "",
              n.normalMap ? "#define USE_NORMALMAP" : "",
              n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
              n.normalMapTangentSpace
                ? "#define USE_NORMALMAP_TANGENTSPACE"
                : "",
              n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              n.anisotropy ? "#define USE_ANISOTROPY" : "",
              n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
              n.clearcoat ? "#define USE_CLEARCOAT" : "",
              n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              n.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              n.iridescence ? "#define USE_IRIDESCENCE" : "",
              n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
              n.iridescenceThicknessMap
                ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                : "",
              n.specularMap ? "#define USE_SPECULARMAP" : "",
              n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
              n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
              n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              n.metalnessMap ? "#define USE_METALNESSMAP" : "",
              n.alphaMap ? "#define USE_ALPHAMAP" : "",
              n.alphaTest ? "#define USE_ALPHATEST" : "",
              n.alphaHash ? "#define USE_ALPHAHASH" : "",
              n.sheen ? "#define USE_SHEEN" : "",
              n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
              n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
              n.transmission ? "#define USE_TRANSMISSION" : "",
              n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              n.vertexTangents && !1 === n.flatShading
                ? "#define USE_TANGENT"
                : "",
              n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
              n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              n.vertexUv1s ? "#define USE_UV1" : "",
              n.vertexUv2s ? "#define USE_UV2" : "",
              n.vertexUv3s ? "#define USE_UV3" : "",
              n.pointsUvs ? "#define USE_POINTS_UV" : "",
              n.gradientMap ? "#define USE_GRADIENTMAP" : "",
              n.flatShading ? "#define FLAT_SHADED" : "",
              n.doubleSided ? "#define DOUBLE_SIDED" : "",
              n.flipSided ? "#define FLIP_SIDED" : "",
              n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              n.shadowMapEnabled ? "#define " + l : "",
              n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
              n.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
              n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
              n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                ? "#define USE_LOGDEPTHBUF_EXT"
                : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              n.toneMapping !== Kh ? "#define TONE_MAPPING" : "",
              n.toneMapping !== Kh ? Qm.tonemapping_pars_fragment : "",
              n.toneMapping !== Kh ? zv("toneMapping", n.toneMapping) : "",
              n.dithering ? "#define DITHERING" : "",
              n.opaque ? "#define OPAQUE" : "",
              Qm.colorspace_pars_fragment,
              kv("linearToOutputTexel", n.outputColorSpace),
              n.useDepthPacking
                ? "#define DEPTH_PACKING " + n.depthPacking
                : "",
              "\n",
            ]
              .filter(Bv)
              .join("\n"))),
          (o = Wv(o)),
          (o = Hv(o, n)),
          (o = Vv(o, n)),
          (a = Wv(a)),
          (a = Hv(a, n)),
          (a = Vv(a, n)),
          (o = Yv(o)),
          (a = Yv(a)),
          n.isWebGL2 &&
            !0 !== n.isRawShaderMaterial &&
            ((_ = "#version 300 es\n"),
            (g =
              [
                "precision mediump sampler2DArray;",
                "#define attribute in",
                "#define varying out",
                "#define texture2D texture",
              ].join("\n") +
              "\n" +
              g),
            (v =
              [
                "#define varying in",
                n.glslVersion === zd
                  ? ""
                  : "layout(location = 0) out highp vec4 pc_fragColor;",
                n.glslVersion === zd ? "" : "#define gl_FragColor pc_fragColor",
                "#define gl_FragDepthEXT gl_FragDepth",
                "#define texture2D texture",
                "#define textureCube texture",
                "#define texture2DProj textureProj",
                "#define texture2DLodEXT textureLod",
                "#define texture2DProjLodEXT textureProjLod",
                "#define textureCubeLodEXT textureLod",
                "#define texture2DGradEXT textureGrad",
                "#define texture2DProjGradEXT textureProjGrad",
                "#define textureCubeGradEXT textureGrad",
              ].join("\n") +
              "\n" +
              v));
        const y = _ + g + o,
          x = _ + v + a,
          b = Fv(r, r.VERTEX_SHADER, y),
          S = Fv(r, r.FRAGMENT_SHADER, x);
        if (
          (r.attachShader(m, b),
          r.attachShader(m, S),
          void 0 !== n.index0AttributeName
            ? r.bindAttribLocation(m, 0, n.index0AttributeName)
            : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"),
          r.linkProgram(m),
          t.debug.checkShaderErrors)
        ) {
          const e = r.getProgramInfoLog(m).trim(),
            n = r.getShaderInfoLog(b).trim(),
            i = r.getShaderInfoLog(S).trim();
          let s = !0,
            o = !0;
          if (!1 === r.getProgramParameter(m, r.LINK_STATUS))
            if (((s = !1), "function" == typeof t.debug.onShaderError))
              t.debug.onShaderError(r, m, b, S);
            else {
              const t = Uv(r, b, "vertex"),
                n = Uv(r, S, "fragment");
              console.error(
                "THREE.WebGLProgram: Shader Error " +
                  r.getError() +
                  " - VALIDATE_STATUS " +
                  r.getProgramParameter(m, r.VALIDATE_STATUS) +
                  "\n\nProgram Info Log: " +
                  e +
                  "\n" +
                  t +
                  "\n" +
                  n
              );
            }
          else
            "" !== e
              ? console.warn("THREE.WebGLProgram: Program Info Log:", e)
              : ("" !== n && "" !== i) || (o = !1);
          o &&
            (this.diagnostics = {
              runnable: s,
              programLog: e,
              vertexShader: {
                log: n,
                prefix: g,
              },
              fragmentShader: {
                log: i,
                prefix: v,
              },
            });
        }
        let E, T;
        return (
          r.deleteShader(b),
          r.deleteShader(S),
          (this.getUniforms = function () {
            return void 0 === E && (E = new Iv(r, m)), E;
          }),
          (this.getAttributes = function () {
            return (
              void 0 === T &&
                (T = (function (t, e) {
                  const n = {},
                    i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
                  for (let r = 0; r < i; r++) {
                    const i = t.getActiveAttrib(e, r),
                      s = i.name;
                    let o = 1;
                    i.type === t.FLOAT_MAT2 && (o = 2),
                      i.type === t.FLOAT_MAT3 && (o = 3),
                      i.type === t.FLOAT_MAT4 && (o = 4),
                      (n[s] = {
                        type: i.type,
                        location: t.getAttribLocation(e, s),
                        locationSize: o,
                      });
                  }
                  return n;
                })(r, m)),
              T
            );
          }),
          (this.destroy = function () {
            i.releaseStatesOfProgram(this),
              r.deleteProgram(m),
              (this.program = void 0);
          }),
          (this.type = n.shaderType),
          (this.name = n.shaderName),
          (this.id = Nv++),
          (this.cacheKey = e),
          (this.usedTimes = 1),
          (this.program = m),
          (this.vertexShader = b),
          (this.fragmentShader = S),
          this
        );
      }
      let Jv = 0;
      class Qv {
        constructor() {
          (this.shaderCache = new Map()), (this.materialCache = new Map());
        }
        update(t) {
          const e = t.vertexShader,
            n = t.fragmentShader,
            i = this._getShaderStage(e),
            r = this._getShaderStage(n),
            s = this._getShaderCacheForMaterial(t);
          return (
            !1 === s.has(i) && (s.add(i), i.usedTimes++),
            !1 === s.has(r) && (s.add(r), r.usedTimes++),
            this
          );
        }
        remove(t) {
          const e = this.materialCache.get(t);
          for (const t of e)
            t.usedTimes--, 0 === t.usedTimes && this.shaderCache.delete(t.code);
          return this.materialCache.delete(t), this;
        }
        getVertexShaderID(t) {
          return this._getShaderStage(t.vertexShader).id;
        }
        getFragmentShaderID(t) {
          return this._getShaderStage(t.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(t) {
          const e = this.materialCache;
          let n = e.get(t);
          return void 0 === n && ((n = new Set()), e.set(t, n)), n;
        }
        _getShaderStage(t) {
          const e = this.shaderCache;
          let n = e.get(t);
          return void 0 === n && ((n = new t_(t)), e.set(t, n)), n;
        }
      }
      class t_ {
        constructor(t) {
          (this.id = Jv++), (this.code = t), (this.usedTimes = 0);
        }
      }
      function e_(t, e, n, i, r, s, o) {
        const a = new gf(),
          l = new Qv(),
          c = [],
          u = r.isWebGL2,
          h = r.logarithmicDepthBuffer,
          d = r.vertexTextures;
        let p = r.precision;
        const f = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite",
        };
        function m(t) {
          return 0 === t ? "uv" : `uv${t}`;
        }
        return {
          getParameters: function (s, a, c, g, v) {
            const _ = g.fog,
              y = v.geometry,
              x = s.isMeshStandardMaterial ? g.environment : null,
              b = (s.isMeshStandardMaterial ? n : e).get(s.envMap || x),
              S = b && b.mapping === id ? b.image.height : null,
              E = f[s.type];
            null !== s.precision &&
              ((p = r.getMaxPrecision(s.precision)),
              p !== s.precision &&
                console.warn(
                  "THREE.WebGLProgram.getParameters:",
                  s.precision,
                  "not supported, using",
                  p,
                  "instead."
                ));
            const T =
                y.morphAttributes.position ||
                y.morphAttributes.normal ||
                y.morphAttributes.color,
              M = void 0 !== T ? T.length : 0;
            let w,
              D,
              A,
              C,
              P = 0;
            if (
              (void 0 !== y.morphAttributes.position && (P = 1),
              void 0 !== y.morphAttributes.normal && (P = 2),
              void 0 !== y.morphAttributes.color && (P = 3),
              E)
            ) {
              const t = eg[E];
              (w = t.vertexShader), (D = t.fragmentShader);
            } else
              (w = s.vertexShader),
                (D = s.fragmentShader),
                l.update(s),
                (A = l.getVertexShaderID(s)),
                (C = l.getFragmentShaderID(s));
            const R = t.getRenderTarget(),
              L = !0 === v.isInstancedMesh,
              O = !!s.map,
              I = !!s.matcap,
              F = !!b,
              N = !!s.aoMap,
              U = !!s.lightMap,
              k = !!s.bumpMap,
              z = !!s.normalMap,
              B = !!s.displacementMap,
              H = !!s.emissiveMap,
              V = !!s.metalnessMap,
              G = !!s.roughnessMap,
              W = s.anisotropy > 0,
              j = s.clearcoat > 0,
              X = s.iridescence > 0,
              q = s.sheen > 0,
              Y = s.transmission > 0,
              K = W && !!s.anisotropyMap,
              Z = j && !!s.clearcoatMap,
              $ = j && !!s.clearcoatNormalMap,
              J = j && !!s.clearcoatRoughnessMap,
              Q = X && !!s.iridescenceMap,
              tt = X && !!s.iridescenceThicknessMap,
              et = q && !!s.sheenColorMap,
              nt = q && !!s.sheenRoughnessMap,
              it = !!s.specularMap,
              rt = !!s.specularColorMap,
              st = !!s.specularIntensityMap,
              ot = Y && !!s.transmissionMap,
              at = Y && !!s.thicknessMap,
              lt = !!s.gradientMap,
              ct = !!s.alphaMap,
              ut = s.alphaTest > 0,
              ht = !!s.alphaHash,
              dt = !!s.extensions,
              pt = !!y.attributes.uv1,
              ft = !!y.attributes.uv2,
              mt = !!y.attributes.uv3;
            let gt = Kh;
            return (
              s.toneMapped &&
                ((null !== R && !0 !== R.isXRRenderTarget) ||
                  (gt = t.toneMapping)),
              {
                isWebGL2: u,
                shaderID: E,
                shaderType: s.type,
                shaderName: s.name,
                vertexShader: w,
                fragmentShader: D,
                defines: s.defines,
                customVertexShaderID: A,
                customFragmentShaderID: C,
                isRawShaderMaterial: !0 === s.isRawShaderMaterial,
                glslVersion: s.glslVersion,
                precision: p,
                instancing: L,
                instancingColor: L && null !== v.instanceColor,
                supportsVertexTextures: d,
                outputColorSpace:
                  null === R
                    ? t.outputColorSpace
                    : !0 === R.isXRRenderTarget
                    ? R.texture.colorSpace
                    : Rd,
                map: O,
                matcap: I,
                envMap: F,
                envMapMode: F && b.mapping,
                envMapCubeUVHeight: S,
                aoMap: N,
                lightMap: U,
                bumpMap: k,
                normalMap: z,
                displacementMap: d && B,
                emissiveMap: H,
                normalMapObjectSpace: z && 1 === s.normalMapType,
                normalMapTangentSpace: z && 0 === s.normalMapType,
                metalnessMap: V,
                roughnessMap: G,
                anisotropy: W,
                anisotropyMap: K,
                clearcoat: j,
                clearcoatMap: Z,
                clearcoatNormalMap: $,
                clearcoatRoughnessMap: J,
                iridescence: X,
                iridescenceMap: Q,
                iridescenceThicknessMap: tt,
                sheen: q,
                sheenColorMap: et,
                sheenRoughnessMap: nt,
                specularMap: it,
                specularColorMap: rt,
                specularIntensityMap: st,
                transmission: Y,
                transmissionMap: ot,
                thicknessMap: at,
                gradientMap: lt,
                opaque: !1 === s.transparent && 1 === s.blending,
                alphaMap: ct,
                alphaTest: ut,
                alphaHash: ht,
                combine: s.combine,
                mapUv: O && m(s.map.channel),
                aoMapUv: N && m(s.aoMap.channel),
                lightMapUv: U && m(s.lightMap.channel),
                bumpMapUv: k && m(s.bumpMap.channel),
                normalMapUv: z && m(s.normalMap.channel),
                displacementMapUv: B && m(s.displacementMap.channel),
                emissiveMapUv: H && m(s.emissiveMap.channel),
                metalnessMapUv: V && m(s.metalnessMap.channel),
                roughnessMapUv: G && m(s.roughnessMap.channel),
                anisotropyMapUv: K && m(s.anisotropyMap.channel),
                clearcoatMapUv: Z && m(s.clearcoatMap.channel),
                clearcoatNormalMapUv: $ && m(s.clearcoatNormalMap.channel),
                clearcoatRoughnessMapUv:
                  J && m(s.clearcoatRoughnessMap.channel),
                iridescenceMapUv: Q && m(s.iridescenceMap.channel),
                iridescenceThicknessMapUv:
                  tt && m(s.iridescenceThicknessMap.channel),
                sheenColorMapUv: et && m(s.sheenColorMap.channel),
                sheenRoughnessMapUv: nt && m(s.sheenRoughnessMap.channel),
                specularMapUv: it && m(s.specularMap.channel),
                specularColorMapUv: rt && m(s.specularColorMap.channel),
                specularIntensityMapUv: st && m(s.specularIntensityMap.channel),
                transmissionMapUv: ot && m(s.transmissionMap.channel),
                thicknessMapUv: at && m(s.thicknessMap.channel),
                alphaMapUv: ct && m(s.alphaMap.channel),
                vertexTangents: !!y.attributes.tangent && (z || W),
                vertexColors: s.vertexColors,
                vertexAlphas:
                  !0 === s.vertexColors &&
                  !!y.attributes.color &&
                  4 === y.attributes.color.itemSize,
                vertexUv1s: pt,
                vertexUv2s: ft,
                vertexUv3s: mt,
                pointsUvs: !0 === v.isPoints && !!y.attributes.uv && (O || ct),
                fog: !!_,
                useFog: !0 === s.fog,
                fogExp2: _ && _.isFogExp2,
                flatShading: !0 === s.flatShading,
                sizeAttenuation: !0 === s.sizeAttenuation,
                logarithmicDepthBuffer: h,
                skinning: !0 === v.isSkinnedMesh,
                morphTargets: void 0 !== y.morphAttributes.position,
                morphNormals: void 0 !== y.morphAttributes.normal,
                morphColors: void 0 !== y.morphAttributes.color,
                morphTargetsCount: M,
                morphTextureStride: P,
                numDirLights: a.directional.length,
                numPointLights: a.point.length,
                numSpotLights: a.spot.length,
                numSpotLightMaps: a.spotLightMap.length,
                numRectAreaLights: a.rectArea.length,
                numHemiLights: a.hemi.length,
                numDirLightShadows: a.directionalShadowMap.length,
                numPointLightShadows: a.pointShadowMap.length,
                numSpotLightShadows: a.spotShadowMap.length,
                numSpotLightShadowsWithMaps: a.numSpotLightShadowsWithMaps,
                numLightProbes: a.numLightProbes,
                numClippingPlanes: o.numPlanes,
                numClipIntersection: o.numIntersection,
                dithering: s.dithering,
                shadowMapEnabled: t.shadowMap.enabled && c.length > 0,
                shadowMapType: t.shadowMap.type,
                toneMapping: gt,
                useLegacyLights: t._useLegacyLights,
                decodeVideoTexture:
                  O &&
                  !0 === s.map.isVideoTexture &&
                  dp.getTransfer(s.map.colorSpace) === Fd,
                premultipliedAlpha: s.premultipliedAlpha,
                doubleSided: 2 === s.side,
                flipSided: 1 === s.side,
                useDepthPacking: s.depthPacking >= 0,
                depthPacking: s.depthPacking || 0,
                index0AttributeName: s.index0AttributeName,
                extensionDerivatives: dt && !0 === s.extensions.derivatives,
                extensionFragDepth: dt && !0 === s.extensions.fragDepth,
                extensionDrawBuffers: dt && !0 === s.extensions.drawBuffers,
                extensionShaderTextureLOD:
                  dt && !0 === s.extensions.shaderTextureLOD,
                rendererExtensionFragDepth: u || i.has("EXT_frag_depth"),
                rendererExtensionDrawBuffers: u || i.has("WEBGL_draw_buffers"),
                rendererExtensionShaderTextureLod:
                  u || i.has("EXT_shader_texture_lod"),
                customProgramCacheKey: s.customProgramCacheKey(),
              }
            );
          },
          getProgramCacheKey: function (e) {
            const n = [];
            if (
              (e.shaderID
                ? n.push(e.shaderID)
                : (n.push(e.customVertexShaderID),
                  n.push(e.customFragmentShaderID)),
              void 0 !== e.defines)
            )
              for (const t in e.defines) n.push(t), n.push(e.defines[t]);
            return (
              !1 === e.isRawShaderMaterial &&
                ((function (t, e) {
                  t.push(e.precision),
                    t.push(e.outputColorSpace),
                    t.push(e.envMapMode),
                    t.push(e.envMapCubeUVHeight),
                    t.push(e.mapUv),
                    t.push(e.alphaMapUv),
                    t.push(e.lightMapUv),
                    t.push(e.aoMapUv),
                    t.push(e.bumpMapUv),
                    t.push(e.normalMapUv),
                    t.push(e.displacementMapUv),
                    t.push(e.emissiveMapUv),
                    t.push(e.metalnessMapUv),
                    t.push(e.roughnessMapUv),
                    t.push(e.anisotropyMapUv),
                    t.push(e.clearcoatMapUv),
                    t.push(e.clearcoatNormalMapUv),
                    t.push(e.clearcoatRoughnessMapUv),
                    t.push(e.iridescenceMapUv),
                    t.push(e.iridescenceThicknessMapUv),
                    t.push(e.sheenColorMapUv),
                    t.push(e.sheenRoughnessMapUv),
                    t.push(e.specularMapUv),
                    t.push(e.specularColorMapUv),
                    t.push(e.specularIntensityMapUv),
                    t.push(e.transmissionMapUv),
                    t.push(e.thicknessMapUv),
                    t.push(e.combine),
                    t.push(e.fogExp2),
                    t.push(e.sizeAttenuation),
                    t.push(e.morphTargetsCount),
                    t.push(e.morphAttributeCount),
                    t.push(e.numDirLights),
                    t.push(e.numPointLights),
                    t.push(e.numSpotLights),
                    t.push(e.numSpotLightMaps),
                    t.push(e.numHemiLights),
                    t.push(e.numRectAreaLights),
                    t.push(e.numDirLightShadows),
                    t.push(e.numPointLightShadows),
                    t.push(e.numSpotLightShadows),
                    t.push(e.numSpotLightShadowsWithMaps),
                    t.push(e.numLightProbes),
                    t.push(e.shadowMapType),
                    t.push(e.toneMapping),
                    t.push(e.numClippingPlanes),
                    t.push(e.numClipIntersection),
                    t.push(e.depthPacking);
                })(n, e),
                (function (t, e) {
                  a.disableAll(),
                    e.isWebGL2 && a.enable(0),
                    e.supportsVertexTextures && a.enable(1),
                    e.instancing && a.enable(2),
                    e.instancingColor && a.enable(3),
                    e.matcap && a.enable(4),
                    e.envMap && a.enable(5),
                    e.normalMapObjectSpace && a.enable(6),
                    e.normalMapTangentSpace && a.enable(7),
                    e.clearcoat && a.enable(8),
                    e.iridescence && a.enable(9),
                    e.alphaTest && a.enable(10),
                    e.vertexColors && a.enable(11),
                    e.vertexAlphas && a.enable(12),
                    e.vertexUv1s && a.enable(13),
                    e.vertexUv2s && a.enable(14),
                    e.vertexUv3s && a.enable(15),
                    e.vertexTangents && a.enable(16),
                    e.anisotropy && a.enable(17),
                    t.push(a.mask),
                    a.disableAll(),
                    e.fog && a.enable(0),
                    e.useFog && a.enable(1),
                    e.flatShading && a.enable(2),
                    e.logarithmicDepthBuffer && a.enable(3),
                    e.skinning && a.enable(4),
                    e.morphTargets && a.enable(5),
                    e.morphNormals && a.enable(6),
                    e.morphColors && a.enable(7),
                    e.premultipliedAlpha && a.enable(8),
                    e.shadowMapEnabled && a.enable(9),
                    e.useLegacyLights && a.enable(10),
                    e.doubleSided && a.enable(11),
                    e.flipSided && a.enable(12),
                    e.useDepthPacking && a.enable(13),
                    e.dithering && a.enable(14),
                    e.transmission && a.enable(15),
                    e.sheen && a.enable(16),
                    e.opaque && a.enable(17),
                    e.pointsUvs && a.enable(18),
                    e.decodeVideoTexture && a.enable(19),
                    t.push(a.mask);
                })(n, e),
                n.push(t.outputColorSpace)),
              n.push(e.customProgramCacheKey),
              n.join()
            );
          },
          getUniforms: function (t) {
            const e = f[t.type];
            let n;
            if (e) {
              const t = eg[e];
              n = Fm.clone(t.uniforms);
            } else n = t.uniforms;
            return n;
          },
          acquireProgram: function (e, n) {
            let i;
            for (let t = 0, e = c.length; t < e; t++) {
              const e = c[t];
              if (e.cacheKey === n) {
                (i = e), ++i.usedTimes;
                break;
              }
            }
            return void 0 === i && ((i = new $v(t, n, e, s)), c.push(i)), i;
          },
          releaseProgram: function (t) {
            if (0 == --t.usedTimes) {
              const e = c.indexOf(t);
              (c[e] = c[c.length - 1]), c.pop(), t.destroy();
            }
          },
          releaseShaderCache: function (t) {
            l.remove(t);
          },
          programs: c,
          dispose: function () {
            l.dispose();
          },
        };
      }
      function n_() {
        let t = new WeakMap();
        return {
          get: function (e) {
            let n = t.get(e);
            return void 0 === n && ((n = {}), t.set(e, n)), n;
          },
          remove: function (e) {
            t.delete(e);
          },
          update: function (e, n, i) {
            t.get(e)[n] = i;
          },
          dispose: function () {
            t = new WeakMap();
          },
        };
      }
      function i_(t, e) {
        return t.groupOrder !== e.groupOrder
          ? t.groupOrder - e.groupOrder
          : t.renderOrder !== e.renderOrder
          ? t.renderOrder - e.renderOrder
          : t.material.id !== e.material.id
          ? t.material.id - e.material.id
          : t.z !== e.z
          ? t.z - e.z
          : t.id - e.id;
      }
      function r_(t, e) {
        return t.groupOrder !== e.groupOrder
          ? t.groupOrder - e.groupOrder
          : t.renderOrder !== e.renderOrder
          ? t.renderOrder - e.renderOrder
          : t.z !== e.z
          ? e.z - t.z
          : t.id - e.id;
      }
      function s_() {
        const t = [];
        let e = 0;
        const n = [],
          i = [],
          r = [];
        function s(n, i, r, s, o, a) {
          let l = t[e];
          return (
            void 0 === l
              ? ((l = {
                  id: n.id,
                  object: n,
                  geometry: i,
                  material: r,
                  groupOrder: s,
                  renderOrder: n.renderOrder,
                  z: o,
                  group: a,
                }),
                (t[e] = l))
              : ((l.id = n.id),
                (l.object = n),
                (l.geometry = i),
                (l.material = r),
                (l.groupOrder = s),
                (l.renderOrder = n.renderOrder),
                (l.z = o),
                (l.group = a)),
            e++,
            l
          );
        }
        return {
          opaque: n,
          transmissive: i,
          transparent: r,
          init: function () {
            (e = 0), (n.length = 0), (i.length = 0), (r.length = 0);
          },
          push: function (t, e, o, a, l, c) {
            const u = s(t, e, o, a, l, c);
            o.transmission > 0
              ? i.push(u)
              : !0 === o.transparent
              ? r.push(u)
              : n.push(u);
          },
          unshift: function (t, e, o, a, l, c) {
            const u = s(t, e, o, a, l, c);
            o.transmission > 0
              ? i.unshift(u)
              : !0 === o.transparent
              ? r.unshift(u)
              : n.unshift(u);
          },
          finish: function () {
            for (let n = e, i = t.length; n < i; n++) {
              const e = t[n];
              if (null === e.id) break;
              (e.id = null),
                (e.object = null),
                (e.geometry = null),
                (e.material = null),
                (e.group = null);
            }
          },
          sort: function (t, e) {
            n.length > 1 && n.sort(t || i_),
              i.length > 1 && i.sort(e || r_),
              r.length > 1 && r.sort(e || r_);
          },
        };
      }
      function o_() {
        let t = new WeakMap();
        return {
          get: function (e, n) {
            const i = t.get(e);
            let r;
            return (
              void 0 === i
                ? ((r = new s_()), t.set(e, [r]))
                : n >= i.length
                ? ((r = new s_()), i.push(r))
                : (r = i[n]),
              r
            );
          },
          dispose: function () {
            t = new WeakMap();
          },
        };
      }
      function a_() {
        const t = {};
        return {
          get: function (e) {
            if (void 0 !== t[e.id]) return t[e.id];
            let n;
            switch (e.type) {
              case "DirectionalLight":
                n = {
                  direction: new Ap(),
                  color: new Kf(),
                };
                break;
              case "SpotLight":
                n = {
                  position: new Ap(),
                  direction: new Ap(),
                  color: new Kf(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                };
                break;
              case "PointLight":
                n = {
                  position: new Ap(),
                  color: new Kf(),
                  distance: 0,
                  decay: 0,
                };
                break;
              case "HemisphereLight":
                n = {
                  direction: new Ap(),
                  skyColor: new Kf(),
                  groundColor: new Kf(),
                };
                break;
              case "RectAreaLight":
                n = {
                  color: new Kf(),
                  position: new Ap(),
                  halfWidth: new Ap(),
                  halfHeight: new Ap(),
                };
            }
            return (t[e.id] = n), n;
          },
        };
      }
      let l_ = 0;
      function c_(t, e) {
        return (
          (e.castShadow ? 2 : 0) -
          (t.castShadow ? 2 : 0) +
          (e.map ? 1 : 0) -
          (t.map ? 1 : 0)
        );
      }
      function u_(t, e) {
        const n = new a_(),
          i = (function () {
            const t = {};
            return {
              get: function (e) {
                if (void 0 !== t[e.id]) return t[e.id];
                let n;
                switch (e.type) {
                  case "DirectionalLight":
                  case "SpotLight":
                    n = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new tp(),
                    };
                    break;
                  case "PointLight":
                    n = {
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new tp(),
                      shadowCameraNear: 1,
                      shadowCameraFar: 1e3,
                    };
                }
                return (t[e.id] = n), n;
              },
            };
          })(),
          r = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
              numSpotMaps: -1,
              numLightProbes: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0,
            numLightProbes: 0,
          };
        for (let t = 0; t < 9; t++) r.probe.push(new Ap());
        const s = new Ap(),
          o = new sf(),
          a = new sf();
        return {
          setup: function (s, o) {
            let a = 0,
              l = 0,
              c = 0;
            for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
            let u = 0,
              h = 0,
              d = 0,
              p = 0,
              f = 0,
              m = 0,
              g = 0,
              v = 0,
              _ = 0,
              y = 0,
              x = 0;
            s.sort(c_);
            const b = !0 === o ? Math.PI : 1;
            for (let t = 0, e = s.length; t < e; t++) {
              const e = s[t],
                o = e.color,
                S = e.intensity,
                E = e.distance,
                T = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
              if (e.isAmbientLight)
                (a += o.r * S * b), (l += o.g * S * b), (c += o.b * S * b);
              else if (e.isLightProbe) {
                for (let t = 0; t < 9; t++)
                  r.probe[t].addScaledVector(e.sh.coefficients[t], S);
                x++;
              } else if (e.isDirectionalLight) {
                const t = n.get(e);
                if (
                  (t.color.copy(e.color).multiplyScalar(e.intensity * b),
                  e.castShadow)
                ) {
                  const t = e.shadow,
                    n = i.get(e);
                  (n.shadowBias = t.bias),
                    (n.shadowNormalBias = t.normalBias),
                    (n.shadowRadius = t.radius),
                    (n.shadowMapSize = t.mapSize),
                    (r.directionalShadow[u] = n),
                    (r.directionalShadowMap[u] = T),
                    (r.directionalShadowMatrix[u] = e.shadow.matrix),
                    m++;
                }
                (r.directional[u] = t), u++;
              } else if (e.isSpotLight) {
                const t = n.get(e);
                t.position.setFromMatrixPosition(e.matrixWorld),
                  t.color.copy(o).multiplyScalar(S * b),
                  (t.distance = E),
                  (t.coneCos = Math.cos(e.angle)),
                  (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))),
                  (t.decay = e.decay),
                  (r.spot[d] = t);
                const s = e.shadow;
                if (
                  (e.map &&
                    ((r.spotLightMap[_] = e.map),
                    _++,
                    s.updateMatrices(e),
                    e.castShadow && y++),
                  (r.spotLightMatrix[d] = s.matrix),
                  e.castShadow)
                ) {
                  const t = i.get(e);
                  (t.shadowBias = s.bias),
                    (t.shadowNormalBias = s.normalBias),
                    (t.shadowRadius = s.radius),
                    (t.shadowMapSize = s.mapSize),
                    (r.spotShadow[d] = t),
                    (r.spotShadowMap[d] = T),
                    v++;
                }
                d++;
              } else if (e.isRectAreaLight) {
                const t = n.get(e);
                t.color.copy(o).multiplyScalar(S),
                  t.halfWidth.set(0.5 * e.width, 0, 0),
                  t.halfHeight.set(0, 0.5 * e.height, 0),
                  (r.rectArea[p] = t),
                  p++;
              } else if (e.isPointLight) {
                const t = n.get(e);
                if (
                  (t.color.copy(e.color).multiplyScalar(e.intensity * b),
                  (t.distance = e.distance),
                  (t.decay = e.decay),
                  e.castShadow)
                ) {
                  const t = e.shadow,
                    n = i.get(e);
                  (n.shadowBias = t.bias),
                    (n.shadowNormalBias = t.normalBias),
                    (n.shadowRadius = t.radius),
                    (n.shadowMapSize = t.mapSize),
                    (n.shadowCameraNear = t.camera.near),
                    (n.shadowCameraFar = t.camera.far),
                    (r.pointShadow[h] = n),
                    (r.pointShadowMap[h] = T),
                    (r.pointShadowMatrix[h] = e.shadow.matrix),
                    g++;
                }
                (r.point[h] = t), h++;
              } else if (e.isHemisphereLight) {
                const t = n.get(e);
                t.skyColor.copy(e.color).multiplyScalar(S * b),
                  t.groundColor.copy(e.groundColor).multiplyScalar(S * b),
                  (r.hemi[f] = t),
                  f++;
              }
            }
            p > 0 &&
              (e.isWebGL2 || !0 === t.has("OES_texture_float_linear")
                ? ((r.rectAreaLTC1 = tg.LTC_FLOAT_1),
                  (r.rectAreaLTC2 = tg.LTC_FLOAT_2))
                : !0 === t.has("OES_texture_half_float_linear")
                ? ((r.rectAreaLTC1 = tg.LTC_HALF_1),
                  (r.rectAreaLTC2 = tg.LTC_HALF_2))
                : console.error(
                    "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                  )),
              (r.ambient[0] = a),
              (r.ambient[1] = l),
              (r.ambient[2] = c);
            const S = r.hash;
            (S.directionalLength === u &&
              S.pointLength === h &&
              S.spotLength === d &&
              S.rectAreaLength === p &&
              S.hemiLength === f &&
              S.numDirectionalShadows === m &&
              S.numPointShadows === g &&
              S.numSpotShadows === v &&
              S.numSpotMaps === _ &&
              S.numLightProbes === x) ||
              ((r.directional.length = u),
              (r.spot.length = d),
              (r.rectArea.length = p),
              (r.point.length = h),
              (r.hemi.length = f),
              (r.directionalShadow.length = m),
              (r.directionalShadowMap.length = m),
              (r.pointShadow.length = g),
              (r.pointShadowMap.length = g),
              (r.spotShadow.length = v),
              (r.spotShadowMap.length = v),
              (r.directionalShadowMatrix.length = m),
              (r.pointShadowMatrix.length = g),
              (r.spotLightMatrix.length = v + _ - y),
              (r.spotLightMap.length = _),
              (r.numSpotLightShadowsWithMaps = y),
              (r.numLightProbes = x),
              (S.directionalLength = u),
              (S.pointLength = h),
              (S.spotLength = d),
              (S.rectAreaLength = p),
              (S.hemiLength = f),
              (S.numDirectionalShadows = m),
              (S.numPointShadows = g),
              (S.numSpotShadows = v),
              (S.numSpotMaps = _),
              (S.numLightProbes = x),
              (r.version = l_++));
          },
          setupView: function (t, e) {
            let n = 0,
              i = 0,
              l = 0,
              c = 0,
              u = 0;
            const h = e.matrixWorldInverse;
            for (let e = 0, d = t.length; e < d; e++) {
              const d = t[e];
              if (d.isDirectionalLight) {
                const t = r.directional[n];
                t.direction.setFromMatrixPosition(d.matrixWorld),
                  s.setFromMatrixPosition(d.target.matrixWorld),
                  t.direction.sub(s),
                  t.direction.transformDirection(h),
                  n++;
              } else if (d.isSpotLight) {
                const t = r.spot[l];
                t.position.setFromMatrixPosition(d.matrixWorld),
                  t.position.applyMatrix4(h),
                  t.direction.setFromMatrixPosition(d.matrixWorld),
                  s.setFromMatrixPosition(d.target.matrixWorld),
                  t.direction.sub(s),
                  t.direction.transformDirection(h),
                  l++;
              } else if (d.isRectAreaLight) {
                const t = r.rectArea[c];
                t.position.setFromMatrixPosition(d.matrixWorld),
                  t.position.applyMatrix4(h),
                  a.identity(),
                  o.copy(d.matrixWorld),
                  o.premultiply(h),
                  a.extractRotation(o),
                  t.halfWidth.set(0.5 * d.width, 0, 0),
                  t.halfHeight.set(0, 0.5 * d.height, 0),
                  t.halfWidth.applyMatrix4(a),
                  t.halfHeight.applyMatrix4(a),
                  c++;
              } else if (d.isPointLight) {
                const t = r.point[i];
                t.position.setFromMatrixPosition(d.matrixWorld),
                  t.position.applyMatrix4(h),
                  i++;
              } else if (d.isHemisphereLight) {
                const t = r.hemi[u];
                t.direction.setFromMatrixPosition(d.matrixWorld),
                  t.direction.transformDirection(h),
                  u++;
              }
            }
          },
          state: r,
        };
      }
      function h_(t, e) {
        const n = new u_(t, e),
          i = [],
          r = [];
        return {
          init: function () {
            (i.length = 0), (r.length = 0);
          },
          state: {
            lightsArray: i,
            shadowsArray: r,
            lights: n,
          },
          setupLights: function (t) {
            n.setup(i, t);
          },
          setupLightsView: function (t) {
            n.setupView(i, t);
          },
          pushLight: function (t) {
            i.push(t);
          },
          pushShadow: function (t) {
            r.push(t);
          },
        };
      }
      function d_(t, e) {
        let n = new WeakMap();
        return {
          get: function (i, r = 0) {
            const s = n.get(i);
            let o;
            return (
              void 0 === s
                ? ((o = new h_(t, e)), n.set(i, [o]))
                : r >= s.length
                ? ((o = new h_(t, e)), s.push(o))
                : (o = s[r]),
              o
            );
          },
          dispose: function () {
            n = new WeakMap();
          },
        };
      }
      class p_ extends Wf {
        constructor(t) {
          super(),
            (this.isMeshDepthMaterial = !0),
            (this.type = "MeshDepthMaterial"),
            (this.depthPacking = 3200),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.depthPacking = t.depthPacking),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            (this.wireframe = t.wireframe),
            (this.wireframeLinewidth = t.wireframeLinewidth),
            this
          );
        }
      }
      class f_ extends Wf {
        constructor(t) {
          super(),
            (this.isMeshDistanceMaterial = !0),
            (this.type = "MeshDistanceMaterial"),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            this.setValues(t);
        }
        copy(t) {
          return (
            super.copy(t),
            (this.map = t.map),
            (this.alphaMap = t.alphaMap),
            (this.displacementMap = t.displacementMap),
            (this.displacementScale = t.displacementScale),
            (this.displacementBias = t.displacementBias),
            this
          );
        }
      }
      function m_(t, e, n) {
        let i = new Km();
        const r = new tp(),
          s = new tp(),
          o = new Sp(),
          a = new p_({
            depthPacking: 3201,
          }),
          l = new f_(),
          c = {},
          u = n.maxTextureSize,
          h = {
            0: 1,
            1: 0,
            2: 2,
          },
          d = new Nm({
            defines: {
              VSM_SAMPLES: 8,
            },
            uniforms: {
              shadow_pass: {
                value: null,
              },
              resolution: {
                value: new tp(),
              },
              radius: {
                value: 4,
              },
            },
            vertexShader:
              "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
            fragmentShader:
              "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
          }),
          p = d.clone();
        p.defines.HORIZONTAL_PASS = 1;
        const f = new hm();
        f.setAttribute(
          "position",
          new tm(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
        );
        const m = new Cm(f, d),
          g = this;
        (this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = Vh);
        let v = this.type;
        function _(n, i) {
          const s = e.update(m);
          d.defines.VSM_SAMPLES !== n.blurSamples &&
            ((d.defines.VSM_SAMPLES = n.blurSamples),
            (p.defines.VSM_SAMPLES = n.blurSamples),
            (d.needsUpdate = !0),
            (p.needsUpdate = !0)),
            null === n.mapPass && (n.mapPass = new Tp(r.x, r.y)),
            (d.uniforms.shadow_pass.value = n.map.texture),
            (d.uniforms.resolution.value = n.mapSize),
            (d.uniforms.radius.value = n.radius),
            t.setRenderTarget(n.mapPass),
            t.clear(),
            t.renderBufferDirect(i, null, s, d, m, null),
            (p.uniforms.shadow_pass.value = n.mapPass.texture),
            (p.uniforms.resolution.value = n.mapSize),
            (p.uniforms.radius.value = n.radius),
            t.setRenderTarget(n.map),
            t.clear(),
            t.renderBufferDirect(i, null, s, p, m, null);
        }
        function y(e, n, i, r) {
          let s = null;
          const o =
            !0 === i.isPointLight
              ? e.customDistanceMaterial
              : e.customDepthMaterial;
          if (void 0 !== o) s = o;
          else if (
            ((s = !0 === i.isPointLight ? l : a),
            (t.localClippingEnabled &&
              !0 === n.clipShadows &&
              Array.isArray(n.clippingPlanes) &&
              0 !== n.clippingPlanes.length) ||
              (n.displacementMap && 0 !== n.displacementScale) ||
              (n.alphaMap && n.alphaTest > 0) ||
              (n.map && n.alphaTest > 0))
          ) {
            const t = s.uuid,
              e = n.uuid;
            let i = c[t];
            void 0 === i && ((i = {}), (c[t] = i));
            let r = i[e];
            void 0 === r && ((r = s.clone()), (i[e] = r)), (s = r);
          }
          return (
            (s.visible = n.visible),
            (s.wireframe = n.wireframe),
            (s.side =
              r === Wh
                ? null !== n.shadowSide
                  ? n.shadowSide
                  : n.side
                : null !== n.shadowSide
                ? n.shadowSide
                : h[n.side]),
            (s.alphaMap = n.alphaMap),
            (s.alphaTest = n.alphaTest),
            (s.map = n.map),
            (s.clipShadows = n.clipShadows),
            (s.clippingPlanes = n.clippingPlanes),
            (s.clipIntersection = n.clipIntersection),
            (s.displacementMap = n.displacementMap),
            (s.displacementScale = n.displacementScale),
            (s.displacementBias = n.displacementBias),
            (s.wireframeLinewidth = n.wireframeLinewidth),
            (s.linewidth = n.linewidth),
            !0 === i.isPointLight &&
              !0 === s.isMeshDistanceMaterial &&
              (t.properties.get(s).light = i),
            s
          );
        }
        function x(n, r, s, o, a) {
          if (!1 === n.visible) return;
          if (
            n.layers.test(r.layers) &&
            (n.isMesh || n.isLine || n.isPoints) &&
            (n.castShadow || (n.receiveShadow && a === Wh)) &&
            (!n.frustumCulled || i.intersectsObject(n))
          ) {
            n.modelViewMatrix.multiplyMatrices(
              s.matrixWorldInverse,
              n.matrixWorld
            );
            const i = e.update(n),
              r = n.material;
            if (Array.isArray(r)) {
              const e = i.groups;
              for (let l = 0, c = e.length; l < c; l++) {
                const c = e[l],
                  u = r[c.materialIndex];
                if (u && u.visible) {
                  const e = y(n, u, o, a);
                  t.renderBufferDirect(s, null, i, e, n, c);
                }
              }
            } else if (r.visible) {
              const e = y(n, r, o, a);
              t.renderBufferDirect(s, null, i, e, n, null);
            }
          }
          const l = n.children;
          for (let t = 0, e = l.length; t < e; t++) x(l[t], r, s, o, a);
        }
        this.render = function (e, n, a) {
          if (!1 === g.enabled) return;
          if (!1 === g.autoUpdate && !1 === g.needsUpdate) return;
          if (0 === e.length) return;
          const l = t.getRenderTarget(),
            c = t.getActiveCubeFace(),
            h = t.getActiveMipmapLevel(),
            d = t.state;
          d.setBlending(0),
            d.buffers.color.setClear(1, 1, 1, 1),
            d.buffers.depth.setTest(!0),
            d.setScissorTest(!1);
          const p = v !== Wh && this.type === Wh,
            f = v === Wh && this.type !== Wh;
          for (let l = 0, c = e.length; l < c; l++) {
            const c = e[l],
              h = c.shadow;
            if (void 0 === h) {
              console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
              continue;
            }
            if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
            r.copy(h.mapSize);
            const m = h.getFrameExtents();
            if (
              (r.multiply(m),
              s.copy(h.mapSize),
              (r.x > u || r.y > u) &&
                (r.x > u &&
                  ((s.x = Math.floor(u / m.x)),
                  (r.x = s.x * m.x),
                  (h.mapSize.x = s.x)),
                r.y > u &&
                  ((s.y = Math.floor(u / m.y)),
                  (r.y = s.y * m.y),
                  (h.mapSize.y = s.y))),
              null === h.map || !0 === p || !0 === f)
            ) {
              const t =
                this.type !== Wh
                  ? {
                      minFilter: ad,
                      magFilter: ad,
                    }
                  : {};
              null !== h.map && h.map.dispose(),
                (h.map = new Tp(r.x, r.y, t)),
                (h.map.texture.name = c.name + ".shadowMap"),
                h.camera.updateProjectionMatrix();
            }
            t.setRenderTarget(h.map), t.clear();
            const g = h.getViewportCount();
            for (let t = 0; t < g; t++) {
              const e = h.getViewport(t);
              o.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w),
                d.viewport(o),
                h.updateMatrices(c, t),
                (i = h.getFrustum()),
                x(n, a, h.camera, c, this.type);
            }
            !0 !== h.isPointLightShadow && this.type === Wh && _(h, a),
              (h.needsUpdate = !1);
          }
          (v = this.type), (g.needsUpdate = !1), t.setRenderTarget(l, c, h);
        };
      }
      function g_(t, e, n) {
        const i = n.isWebGL2,
          r = new (function () {
            let e = !1;
            const n = new Sp();
            let i = null;
            const r = new Sp(0, 0, 0, 0);
            return {
              setMask: function (n) {
                i === n || e || (t.colorMask(n, n, n, n), (i = n));
              },
              setLocked: function (t) {
                e = t;
              },
              setClear: function (e, i, s, o, a) {
                !0 === a && ((e *= o), (i *= o), (s *= o)),
                  n.set(e, i, s, o),
                  !1 === r.equals(n) && (t.clearColor(e, i, s, o), r.copy(n));
              },
              reset: function () {
                (e = !1), (i = null), r.set(-1, 0, 0, 0);
              },
            };
          })(),
          s = new (function () {
            let e = !1,
              n = null,
              i = null,
              r = null;
            return {
              setTest: function (e) {
                e ? B(t.DEPTH_TEST) : H(t.DEPTH_TEST);
              },
              setMask: function (i) {
                n === i || e || (t.depthMask(i), (n = i));
              },
              setFunc: function (e) {
                if (i !== e) {
                  switch (e) {
                    case 0:
                      t.depthFunc(t.NEVER);
                      break;
                    case 1:
                      t.depthFunc(t.ALWAYS);
                      break;
                    case 2:
                      t.depthFunc(t.LESS);
                      break;
                    case 3:
                    default:
                      t.depthFunc(t.LEQUAL);
                      break;
                    case 4:
                      t.depthFunc(t.EQUAL);
                      break;
                    case 5:
                      t.depthFunc(t.GEQUAL);
                      break;
                    case 6:
                      t.depthFunc(t.GREATER);
                      break;
                    case 7:
                      t.depthFunc(t.NOTEQUAL);
                  }
                  i = e;
                }
              },
              setLocked: function (t) {
                e = t;
              },
              setClear: function (e) {
                r !== e && (t.clearDepth(e), (r = e));
              },
              reset: function () {
                (e = !1), (n = null), (i = null), (r = null);
              },
            };
          })(),
          o = new (function () {
            let e = !1,
              n = null,
              i = null,
              r = null,
              s = null,
              o = null,
              a = null,
              l = null,
              c = null;
            return {
              setTest: function (n) {
                e || (n ? B(t.STENCIL_TEST) : H(t.STENCIL_TEST));
              },
              setMask: function (i) {
                n === i || e || (t.stencilMask(i), (n = i));
              },
              setFunc: function (e, n, o) {
                (i === e && r === n && s === o) ||
                  (t.stencilFunc(e, n, o), (i = e), (r = n), (s = o));
              },
              setOp: function (e, n, i) {
                (o === e && a === n && l === i) ||
                  (t.stencilOp(e, n, i), (o = e), (a = n), (l = i));
              },
              setLocked: function (t) {
                e = t;
              },
              setClear: function (e) {
                c !== e && (t.clearStencil(e), (c = e));
              },
              reset: function () {
                (e = !1),
                  (n = null),
                  (i = null),
                  (r = null),
                  (s = null),
                  (o = null),
                  (a = null),
                  (l = null),
                  (c = null);
              },
            };
          })(),
          a = new WeakMap(),
          l = new WeakMap();
        let c = {},
          u = {},
          h = new WeakMap(),
          d = [],
          p = null,
          f = !1,
          m = null,
          g = null,
          v = null,
          _ = null,
          y = null,
          x = null,
          b = null,
          S = !1,
          E = null,
          T = null,
          M = null,
          w = null,
          D = null;
        const A = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let C = !1,
          P = 0;
        const R = t.getParameter(t.VERSION);
        -1 !== R.indexOf("WebGL")
          ? ((P = parseFloat(/^WebGL (\d)/.exec(R)[1])), (C = P >= 1))
          : -1 !== R.indexOf("OpenGL ES") &&
            ((P = parseFloat(/^OpenGL ES (\d)/.exec(R)[1])), (C = P >= 2));
        let L = null,
          O = {};
        const I = t.getParameter(t.SCISSOR_BOX),
          F = t.getParameter(t.VIEWPORT),
          N = new Sp().fromArray(I),
          U = new Sp().fromArray(F);
        function k(e, n, r, s) {
          const o = new Uint8Array(4),
            a = t.createTexture();
          t.bindTexture(e, a),
            t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST),
            t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
          for (let a = 0; a < r; a++)
            !i || (e !== t.TEXTURE_3D && e !== t.TEXTURE_2D_ARRAY)
              ? t.texImage2D(
                  n + a,
                  0,
                  t.RGBA,
                  1,
                  1,
                  0,
                  t.RGBA,
                  t.UNSIGNED_BYTE,
                  o
                )
              : t.texImage3D(
                  n,
                  0,
                  t.RGBA,
                  1,
                  1,
                  s,
                  0,
                  t.RGBA,
                  t.UNSIGNED_BYTE,
                  o
                );
          return a;
        }
        const z = {};
        function B(e) {
          !0 !== c[e] && (t.enable(e), (c[e] = !0));
        }
        function H(e) {
          !1 !== c[e] && (t.disable(e), (c[e] = !1));
        }
        (z[t.TEXTURE_2D] = k(t.TEXTURE_2D, t.TEXTURE_2D, 1)),
          (z[t.TEXTURE_CUBE_MAP] = k(
            t.TEXTURE_CUBE_MAP,
            t.TEXTURE_CUBE_MAP_POSITIVE_X,
            6
          )),
          i &&
            ((z[t.TEXTURE_2D_ARRAY] = k(
              t.TEXTURE_2D_ARRAY,
              t.TEXTURE_2D_ARRAY,
              1,
              1
            )),
            (z[t.TEXTURE_3D] = k(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1))),
          r.setClear(0, 0, 0, 1),
          s.setClear(1),
          o.setClear(0),
          B(t.DEPTH_TEST),
          s.setFunc(3),
          j(!1),
          X(1),
          B(t.CULL_FACE),
          W(0);
        const V = {
          [jh]: t.FUNC_ADD,
          101: t.FUNC_SUBTRACT,
          102: t.FUNC_REVERSE_SUBTRACT,
        };
        if (i) (V[103] = t.MIN), (V[104] = t.MAX);
        else {
          const t = e.get("EXT_blend_minmax");
          null !== t && ((V[103] = t.MIN_EXT), (V[104] = t.MAX_EXT));
        }
        const G = {
          200: t.ZERO,
          201: t.ONE,
          202: t.SRC_COLOR,
          204: t.SRC_ALPHA,
          210: t.SRC_ALPHA_SATURATE,
          208: t.DST_COLOR,
          206: t.DST_ALPHA,
          203: t.ONE_MINUS_SRC_COLOR,
          205: t.ONE_MINUS_SRC_ALPHA,
          209: t.ONE_MINUS_DST_COLOR,
          207: t.ONE_MINUS_DST_ALPHA,
        };
        function W(e, n, i, r, s, o, a, l) {
          if (0 !== e) {
            if ((!1 === f && (B(t.BLEND), (f = !0)), 5 === e))
              (s = s || n),
                (o = o || i),
                (a = a || r),
                (n === g && s === y) ||
                  (t.blendEquationSeparate(V[n], V[s]), (g = n), (y = s)),
                (i === v && r === _ && o === x && a === b) ||
                  (t.blendFuncSeparate(G[i], G[r], G[o], G[a]),
                  (v = i),
                  (_ = r),
                  (x = o),
                  (b = a)),
                (m = e),
                (S = !1);
            else if (e !== m || l !== S) {
              if (
                ((g === jh && y === jh) ||
                  (t.blendEquation(t.FUNC_ADD), (g = jh), (y = jh)),
                l)
              )
                switch (e) {
                  case 1:
                    t.blendFuncSeparate(
                      t.ONE,
                      t.ONE_MINUS_SRC_ALPHA,
                      t.ONE,
                      t.ONE_MINUS_SRC_ALPHA
                    );
                    break;
                  case 2:
                    t.blendFunc(t.ONE, t.ONE);
                    break;
                  case 3:
                    t.blendFuncSeparate(
                      t.ZERO,
                      t.ONE_MINUS_SRC_COLOR,
                      t.ZERO,
                      t.ONE
                    );
                    break;
                  case 4:
                    t.blendFuncSeparate(
                      t.ZERO,
                      t.SRC_COLOR,
                      t.ZERO,
                      t.SRC_ALPHA
                    );
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", e);
                }
              else
                switch (e) {
                  case 1:
                    t.blendFuncSeparate(
                      t.SRC_ALPHA,
                      t.ONE_MINUS_SRC_ALPHA,
                      t.ONE,
                      t.ONE_MINUS_SRC_ALPHA
                    );
                    break;
                  case 2:
                    t.blendFunc(t.SRC_ALPHA, t.ONE);
                    break;
                  case 3:
                    t.blendFuncSeparate(
                      t.ZERO,
                      t.ONE_MINUS_SRC_COLOR,
                      t.ZERO,
                      t.ONE
                    );
                    break;
                  case 4:
                    t.blendFunc(t.ZERO, t.SRC_COLOR);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", e);
                }
              (v = null), (_ = null), (x = null), (b = null), (m = e), (S = l);
            }
          } else !0 === f && (H(t.BLEND), (f = !1));
        }
        function j(e) {
          E !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), (E = e));
        }
        function X(e) {
          0 !== e
            ? (B(t.CULL_FACE),
              e !== T &&
                (1 === e
                  ? t.cullFace(t.BACK)
                  : 2 === e
                  ? t.cullFace(t.FRONT)
                  : t.cullFace(t.FRONT_AND_BACK)))
            : H(t.CULL_FACE),
            (T = e);
        }
        function q(e, n, i) {
          e
            ? (B(t.POLYGON_OFFSET_FILL),
              (w === n && D === i) || (t.polygonOffset(n, i), (w = n), (D = i)))
            : H(t.POLYGON_OFFSET_FILL);
        }
        return {
          buffers: {
            color: r,
            depth: s,
            stencil: o,
          },
          enable: B,
          disable: H,
          bindFramebuffer: function (e, n) {
            return (
              u[e] !== n &&
              (t.bindFramebuffer(e, n),
              (u[e] = n),
              i &&
                (e === t.DRAW_FRAMEBUFFER && (u[t.FRAMEBUFFER] = n),
                e === t.FRAMEBUFFER && (u[t.DRAW_FRAMEBUFFER] = n)),
              !0)
            );
          },
          drawBuffers: function (i, r) {
            let s = d,
              o = !1;
            if (i)
              if (
                ((s = h.get(r)),
                void 0 === s && ((s = []), h.set(r, s)),
                i.isWebGLMultipleRenderTargets)
              ) {
                const e = i.texture;
                if (s.length !== e.length || s[0] !== t.COLOR_ATTACHMENT0) {
                  for (let n = 0, i = e.length; n < i; n++)
                    s[n] = t.COLOR_ATTACHMENT0 + n;
                  (s.length = e.length), (o = !0);
                }
              } else
                s[0] !== t.COLOR_ATTACHMENT0 &&
                  ((s[0] = t.COLOR_ATTACHMENT0), (o = !0));
            else s[0] !== t.BACK && ((s[0] = t.BACK), (o = !0));
            o &&
              (n.isWebGL2
                ? t.drawBuffers(s)
                : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(s));
          },
          useProgram: function (e) {
            return p !== e && (t.useProgram(e), (p = e), !0);
          },
          setBlending: W,
          setMaterial: function (e, n) {
            2 === e.side ? H(t.CULL_FACE) : B(t.CULL_FACE);
            let i = 1 === e.side;
            n && (i = !i),
              j(i),
              1 === e.blending && !1 === e.transparent
                ? W(0)
                : W(
                    e.blending,
                    e.blendEquation,
                    e.blendSrc,
                    e.blendDst,
                    e.blendEquationAlpha,
                    e.blendSrcAlpha,
                    e.blendDstAlpha,
                    e.premultipliedAlpha
                  ),
              s.setFunc(e.depthFunc),
              s.setTest(e.depthTest),
              s.setMask(e.depthWrite),
              r.setMask(e.colorWrite);
            const a = e.stencilWrite;
            o.setTest(a),
              a &&
                (o.setMask(e.stencilWriteMask),
                o.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
                o.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
              q(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits),
              !0 === e.alphaToCoverage
                ? B(t.SAMPLE_ALPHA_TO_COVERAGE)
                : H(t.SAMPLE_ALPHA_TO_COVERAGE);
          },
          setFlipSided: j,
          setCullFace: X,
          setLineWidth: function (e) {
            e !== M && (C && t.lineWidth(e), (M = e));
          },
          setPolygonOffset: q,
          setScissorTest: function (e) {
            e ? B(t.SCISSOR_TEST) : H(t.SCISSOR_TEST);
          },
          activeTexture: function (e) {
            void 0 === e && (e = t.TEXTURE0 + A - 1),
              L !== e && (t.activeTexture(e), (L = e));
          },
          bindTexture: function (e, n, i) {
            void 0 === i && (i = null === L ? t.TEXTURE0 + A - 1 : L);
            let r = O[i];
            void 0 === r &&
              ((r = {
                type: void 0,
                texture: void 0,
              }),
              (O[i] = r)),
              (r.type === e && r.texture === n) ||
                (L !== i && (t.activeTexture(i), (L = i)),
                t.bindTexture(e, n || z[e]),
                (r.type = e),
                (r.texture = n));
          },
          unbindTexture: function () {
            const e = O[L];
            void 0 !== e &&
              void 0 !== e.type &&
              (t.bindTexture(e.type, null),
              (e.type = void 0),
              (e.texture = void 0));
          },
          compressedTexImage2D: function () {
            try {
              t.compressedTexImage2D.apply(t, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          compressedTexImage3D: function () {
            try {
              t.compressedTexImage3D.apply(t, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          texImage2D: function () {
            try {
              t.texImage2D.apply(t, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          texImage3D: function () {
            try {
              t.texImage3D.apply(t, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          updateUBOMapping: function (e, n) {
            let i = l.get(n);
            void 0 === i && ((i = new WeakMap()), l.set(n, i));
            let r = i.get(e);
            void 0 === r &&
              ((r = t.getUniformBlockIndex(n, e.name)), i.set(e, r));
          },
          uniformBlockBinding: function (e, n) {
            const i = l.get(n).get(e);
            a.get(n) !== i &&
              (t.uniformBlockBinding(n, i, e.__bindingPointIndex), a.set(n, i));
          },
          texStorage2D: function () {
            try {
              t.texStorage2D.apply(t, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          texStorage3D: function () {
            try {
              t.texStorage3D.apply(t, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          texSubImage2D: function () {
            try {
              t.texSubImage2D.apply(t, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          texSubImage3D: function () {
            try {
              t.texSubImage3D.apply(t, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          compressedTexSubImage2D: function () {
            try {
              t.compressedTexSubImage2D.apply(t, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          compressedTexSubImage3D: function () {
            try {
              t.compressedTexSubImage3D.apply(t, arguments);
            } catch (t) {
              console.error("THREE.WebGLState:", t);
            }
          },
          scissor: function (e) {
            !1 === N.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), N.copy(e));
          },
          viewport: function (e) {
            !1 === U.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), U.copy(e));
          },
          reset: function () {
            t.disable(t.BLEND),
              t.disable(t.CULL_FACE),
              t.disable(t.DEPTH_TEST),
              t.disable(t.POLYGON_OFFSET_FILL),
              t.disable(t.SCISSOR_TEST),
              t.disable(t.STENCIL_TEST),
              t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),
              t.blendEquation(t.FUNC_ADD),
              t.blendFunc(t.ONE, t.ZERO),
              t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO),
              t.colorMask(!0, !0, !0, !0),
              t.clearColor(0, 0, 0, 0),
              t.depthMask(!0),
              t.depthFunc(t.LESS),
              t.clearDepth(1),
              t.stencilMask(4294967295),
              t.stencilFunc(t.ALWAYS, 0, 4294967295),
              t.stencilOp(t.KEEP, t.KEEP, t.KEEP),
              t.clearStencil(0),
              t.cullFace(t.BACK),
              t.frontFace(t.CCW),
              t.polygonOffset(0, 0),
              t.activeTexture(t.TEXTURE0),
              t.bindFramebuffer(t.FRAMEBUFFER, null),
              !0 === i &&
                (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
                t.bindFramebuffer(t.READ_FRAMEBUFFER, null)),
              t.useProgram(null),
              t.lineWidth(1),
              t.scissor(0, 0, t.canvas.width, t.canvas.height),
              t.viewport(0, 0, t.canvas.width, t.canvas.height),
              (c = {}),
              (L = null),
              (O = {}),
              (u = {}),
              (h = new WeakMap()),
              (d = []),
              (p = null),
              (f = !1),
              (m = null),
              (g = null),
              (v = null),
              (_ = null),
              (y = null),
              (x = null),
              (b = null),
              (S = !1),
              (E = null),
              (T = null),
              (M = null),
              (w = null),
              (D = null),
              N.set(0, 0, t.canvas.width, t.canvas.height),
              U.set(0, 0, t.canvas.width, t.canvas.height),
              r.reset(),
              s.reset(),
              o.reset();
          },
        };
      }
      function v_(t, e, n, i, r, s, o) {
        const a = r.isWebGL2,
          l = r.maxTextures,
          c = r.maxCubemapSize,
          u = r.maxTextureSize,
          h = r.maxSamples,
          d = e.has("WEBGL_multisampled_render_to_texture")
            ? e.get("WEBGL_multisampled_render_to_texture")
            : null,
          p =
            "undefined" != typeof navigator &&
            /OculusBrowser/g.test(navigator.userAgent),
          f = new WeakMap();
        let m;
        const g = new WeakMap();
        let v = !1;
        try {
          v =
            "undefined" != typeof OffscreenCanvas &&
            null !== new OffscreenCanvas(1, 1).getContext("2d");
        } catch (t) {}
        function _(t, e) {
          return v ? new OffscreenCanvas(t, e) : rp("canvas");
        }
        function y(t, e, n, i) {
          let r = 1;
          if (
            ((t.width > i || t.height > i) &&
              (r = i / Math.max(t.width, t.height)),
            r < 1 || !0 === e)
          ) {
            if (
              ("undefined" != typeof HTMLImageElement &&
                t instanceof HTMLImageElement) ||
              ("undefined" != typeof HTMLCanvasElement &&
                t instanceof HTMLCanvasElement) ||
              ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
            ) {
              const i = e ? $d : Math.floor,
                s = i(r * t.width),
                o = i(r * t.height);
              void 0 === m && (m = _(s, o));
              const a = n ? _(s, o) : m;
              return (
                (a.width = s),
                (a.height = o),
                a.getContext("2d").drawImage(t, 0, 0, s, o),
                console.warn(
                  "THREE.WebGLRenderer: Texture has been resized from (" +
                    t.width +
                    "x" +
                    t.height +
                    ") to (" +
                    s +
                    "x" +
                    o +
                    ")."
                ),
                a
              );
            }
            return (
              "data" in t &&
                console.warn(
                  "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                    t.width +
                    "x" +
                    t.height +
                    ")."
                ),
              t
            );
          }
          return t;
        }
        function x(t) {
          return Zd(t.width) && Zd(t.height);
        }
        function b(t, e) {
          return (
            t.generateMipmaps && e && t.minFilter !== ad && t.minFilter !== cd
          );
        }
        function S(e) {
          t.generateMipmap(e);
        }
        function E(n, i, r, s, o = !1) {
          if (!1 === a) return i;
          if (null !== n) {
            if (void 0 !== t[n]) return t[n];
            console.warn(
              "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                n +
                "'"
            );
          }
          let l = i;
          if (
            (i === t.RED &&
              (r === t.FLOAT && (l = t.R32F),
              r === t.HALF_FLOAT && (l = t.R16F),
              r === t.UNSIGNED_BYTE && (l = t.R8)),
            i === t.RED_INTEGER &&
              (r === t.UNSIGNED_BYTE && (l = t.R8UI),
              r === t.UNSIGNED_SHORT && (l = t.R16UI),
              r === t.UNSIGNED_INT && (l = t.R32UI),
              r === t.BYTE && (l = t.R8I),
              r === t.SHORT && (l = t.R16I),
              r === t.INT && (l = t.R32I)),
            i === t.RG &&
              (r === t.FLOAT && (l = t.RG32F),
              r === t.HALF_FLOAT && (l = t.RG16F),
              r === t.UNSIGNED_BYTE && (l = t.RG8)),
            i === t.RGBA)
          ) {
            const e = o ? Id : dp.getTransfer(s);
            r === t.FLOAT && (l = t.RGBA32F),
              r === t.HALF_FLOAT && (l = t.RGBA16F),
              r === t.UNSIGNED_BYTE &&
                (l = e === Fd ? t.SRGB8_ALPHA8 : t.RGBA8),
              r === t.UNSIGNED_SHORT_4_4_4_4 && (l = t.RGBA4),
              r === t.UNSIGNED_SHORT_5_5_5_1 && (l = t.RGB5_A1);
          }
          return (
            (l !== t.R16F &&
              l !== t.R32F &&
              l !== t.RG16F &&
              l !== t.RG32F &&
              l !== t.RGBA16F &&
              l !== t.RGBA32F) ||
              e.get("EXT_color_buffer_float"),
            l
          );
        }
        function T(t, e, n) {
          return !0 === b(t, n) ||
            (t.isFramebufferTexture && t.minFilter !== ad && t.minFilter !== cd)
            ? Math.log2(Math.max(e.width, e.height)) + 1
            : void 0 !== t.mipmaps && t.mipmaps.length > 0
            ? t.mipmaps.length
            : t.isCompressedTexture && Array.isArray(t.image)
            ? e.mipmaps.length
            : 1;
        }
        function M(e) {
          return e === ad || 1004 === e || e === ld ? t.NEAREST : t.LINEAR;
        }
        function w(t) {
          const e = t.target;
          e.removeEventListener("dispose", w),
            (function (t) {
              const e = i.get(t);
              if (void 0 === e.__webglInit) return;
              const n = t.source,
                r = g.get(n);
              if (r) {
                const i = r[e.__cacheKey];
                i.usedTimes--,
                  0 === i.usedTimes && A(t),
                  0 === Object.keys(r).length && g.delete(n);
              }
              i.remove(t);
            })(e),
            e.isVideoTexture && f.delete(e);
        }
        function D(e) {
          const n = e.target;
          n.removeEventListener("dispose", D),
            (function (e) {
              const n = e.texture,
                r = i.get(e),
                s = i.get(n);
              if (
                (void 0 !== s.__webglTexture &&
                  (t.deleteTexture(s.__webglTexture), o.memory.textures--),
                e.depthTexture && e.depthTexture.dispose(),
                e.isWebGLCubeRenderTarget)
              )
                for (let e = 0; e < 6; e++) {
                  if (Array.isArray(r.__webglFramebuffer[e]))
                    for (let n = 0; n < r.__webglFramebuffer[e].length; n++)
                      t.deleteFramebuffer(r.__webglFramebuffer[e][n]);
                  else t.deleteFramebuffer(r.__webglFramebuffer[e]);
                  r.__webglDepthbuffer &&
                    t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
                }
              else {
                if (Array.isArray(r.__webglFramebuffer))
                  for (let e = 0; e < r.__webglFramebuffer.length; e++)
                    t.deleteFramebuffer(r.__webglFramebuffer[e]);
                else t.deleteFramebuffer(r.__webglFramebuffer);
                if (
                  (r.__webglDepthbuffer &&
                    t.deleteRenderbuffer(r.__webglDepthbuffer),
                  r.__webglMultisampledFramebuffer &&
                    t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                  r.__webglColorRenderbuffer)
                )
                  for (let e = 0; e < r.__webglColorRenderbuffer.length; e++)
                    r.__webglColorRenderbuffer[e] &&
                      t.deleteRenderbuffer(r.__webglColorRenderbuffer[e]);
                r.__webglDepthRenderbuffer &&
                  t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
              }
              if (e.isWebGLMultipleRenderTargets)
                for (let e = 0, r = n.length; e < r; e++) {
                  const r = i.get(n[e]);
                  r.__webglTexture &&
                    (t.deleteTexture(r.__webglTexture), o.memory.textures--),
                    i.remove(n[e]);
                }
              i.remove(n), i.remove(e);
            })(n);
        }
        function A(e) {
          const n = i.get(e);
          t.deleteTexture(n.__webglTexture);
          const r = e.source;
          delete g.get(r)[n.__cacheKey], o.memory.textures--;
        }
        let C = 0;
        function P(e, r) {
          const s = i.get(e);
          if (
            (e.isVideoTexture &&
              (function (t) {
                const e = o.render.frame;
                f.get(t) !== e && (f.set(t, e), t.update());
              })(e),
            !1 === e.isRenderTargetTexture &&
              e.version > 0 &&
              s.__version !== e.version)
          ) {
            const t = e.image;
            if (null === t)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but no image data found."
              );
            else {
              if (!1 !== t.complete) return void N(s, e, r);
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
              );
            }
          }
          n.bindTexture(t.TEXTURE_2D, s.__webglTexture, t.TEXTURE0 + r);
        }
        const R = {
            [rd]: t.REPEAT,
            [sd]: t.CLAMP_TO_EDGE,
            [od]: t.MIRRORED_REPEAT,
          },
          L = {
            [ad]: t.NEAREST,
            1004: t.NEAREST_MIPMAP_NEAREST,
            [ld]: t.NEAREST_MIPMAP_LINEAR,
            [cd]: t.LINEAR,
            1007: t.LINEAR_MIPMAP_NEAREST,
            [ud]: t.LINEAR_MIPMAP_LINEAR,
          },
          O = {
            512: t.NEVER,
            519: t.ALWAYS,
            513: t.LESS,
            515: t.LEQUAL,
            514: t.EQUAL,
            518: t.GEQUAL,
            516: t.GREATER,
            517: t.NOTEQUAL,
          };
        function I(n, s, o) {
          if (
            (o
              ? (t.texParameteri(n, t.TEXTURE_WRAP_S, R[s.wrapS]),
                t.texParameteri(n, t.TEXTURE_WRAP_T, R[s.wrapT]),
                (n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY) ||
                  t.texParameteri(n, t.TEXTURE_WRAP_R, R[s.wrapR]),
                t.texParameteri(n, t.TEXTURE_MAG_FILTER, L[s.magFilter]),
                t.texParameteri(n, t.TEXTURE_MIN_FILTER, L[s.minFilter]))
              : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
                t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
                (n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY) ||
                  t.texParameteri(n, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE),
                (s.wrapS === sd && s.wrapT === sd) ||
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                  ),
                t.texParameteri(n, t.TEXTURE_MAG_FILTER, M(s.magFilter)),
                t.texParameteri(n, t.TEXTURE_MIN_FILTER, M(s.minFilter)),
                s.minFilter !== ad &&
                  s.minFilter !== cd &&
                  console.warn(
                    "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                  )),
            s.compareFunction &&
              (t.texParameteri(
                n,
                t.TEXTURE_COMPARE_MODE,
                t.COMPARE_REF_TO_TEXTURE
              ),
              t.texParameteri(n, t.TEXTURE_COMPARE_FUNC, O[s.compareFunction])),
            !0 === e.has("EXT_texture_filter_anisotropic"))
          ) {
            const o = e.get("EXT_texture_filter_anisotropic");
            if (s.magFilter === ad) return;
            if (s.minFilter !== ld && s.minFilter !== ud) return;
            if (s.type === fd && !1 === e.has("OES_texture_float_linear"))
              return;
            if (
              !1 === a &&
              s.type === md &&
              !1 === e.has("OES_texture_half_float_linear")
            )
              return;
            (s.anisotropy > 1 || i.get(s).__currentAnisotropy) &&
              (t.texParameterf(
                n,
                o.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(s.anisotropy, r.getMaxAnisotropy())
              ),
              (i.get(s).__currentAnisotropy = s.anisotropy));
          }
        }
        function F(e, n) {
          let i = !1;
          void 0 === e.__webglInit &&
            ((e.__webglInit = !0), n.addEventListener("dispose", w));
          const r = n.source;
          let s = g.get(r);
          void 0 === s && ((s = {}), g.set(r, s));
          const a = (function (t) {
            const e = [];
            return (
              e.push(t.wrapS),
              e.push(t.wrapT),
              e.push(t.wrapR || 0),
              e.push(t.magFilter),
              e.push(t.minFilter),
              e.push(t.anisotropy),
              e.push(t.internalFormat),
              e.push(t.format),
              e.push(t.type),
              e.push(t.generateMipmaps),
              e.push(t.premultiplyAlpha),
              e.push(t.flipY),
              e.push(t.unpackAlignment),
              e.push(t.colorSpace),
              e.join()
            );
          })(n);
          if (a !== e.__cacheKey) {
            void 0 === s[a] &&
              ((s[a] = {
                texture: t.createTexture(),
                usedTimes: 0,
              }),
              o.memory.textures++,
              (i = !0)),
              s[a].usedTimes++;
            const r = s[e.__cacheKey];
            void 0 !== r &&
              (s[e.__cacheKey].usedTimes--, 0 === r.usedTimes && A(n)),
              (e.__cacheKey = a),
              (e.__webglTexture = s[a].texture);
          }
          return i;
        }
        function N(e, r, o) {
          let l = t.TEXTURE_2D;
          (r.isDataArrayTexture || r.isCompressedArrayTexture) &&
            (l = t.TEXTURE_2D_ARRAY),
            r.isData3DTexture && (l = t.TEXTURE_3D);
          const c = F(e, r),
            h = r.source;
          n.bindTexture(l, e.__webglTexture, t.TEXTURE0 + o);
          const d = i.get(h);
          if (h.version !== d.__version || !0 === c) {
            n.activeTexture(t.TEXTURE0 + o);
            const e = dp.getPrimaries(dp.workingColorSpace),
              i = r.colorSpace === Cd ? null : dp.getPrimaries(r.colorSpace),
              p =
                r.colorSpace === Cd || e === i
                  ? t.NONE
                  : t.BROWSER_DEFAULT_WEBGL;
            t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, r.flipY),
              t.pixelStorei(
                t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                r.premultiplyAlpha
              ),
              t.pixelStorei(t.UNPACK_ALIGNMENT, r.unpackAlignment),
              t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, p);
            const f =
              (function (t) {
                return (
                  !a &&
                  (t.wrapS !== sd ||
                    t.wrapT !== sd ||
                    (t.minFilter !== ad && t.minFilter !== cd))
                );
              })(r) && !1 === x(r.image);
            let m = y(r.image, f, !1, u);
            m = V(r, m);
            const g = x(m) || a,
              v = s.convert(r.format, r.colorSpace);
            let _,
              M = s.convert(r.type),
              w = E(r.internalFormat, v, M, r.colorSpace, r.isVideoTexture);
            I(l, r, g);
            const D = r.mipmaps,
              A = a && !0 !== r.isVideoTexture,
              C = void 0 === d.__version || !0 === c,
              P = T(r, m, g);
            if (r.isDepthTexture)
              (w = t.DEPTH_COMPONENT),
                a
                  ? (w =
                      r.type === fd
                        ? t.DEPTH_COMPONENT32F
                        : r.type === pd
                        ? t.DEPTH_COMPONENT24
                        : r.type === gd
                        ? t.DEPTH24_STENCIL8
                        : t.DEPTH_COMPONENT16)
                  : r.type === fd &&
                    console.error(
                      "WebGLRenderer: Floating point depth texture requires WebGL2."
                    ),
                r.format === _d &&
                  w === t.DEPTH_COMPONENT &&
                  r.type !== dd &&
                  r.type !== pd &&
                  (console.warn(
                    "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                  ),
                  (r.type = pd),
                  (M = s.convert(r.type))),
                r.format === yd &&
                  w === t.DEPTH_COMPONENT &&
                  ((w = t.DEPTH_STENCIL),
                  r.type !== gd &&
                    (console.warn(
                      "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                    ),
                    (r.type = gd),
                    (M = s.convert(r.type)))),
                C &&
                  (A
                    ? n.texStorage2D(t.TEXTURE_2D, 1, w, m.width, m.height)
                    : n.texImage2D(
                        t.TEXTURE_2D,
                        0,
                        w,
                        m.width,
                        m.height,
                        0,
                        v,
                        M,
                        null
                      ));
            else if (r.isDataTexture)
              if (D.length > 0 && g) {
                A &&
                  C &&
                  n.texStorage2D(t.TEXTURE_2D, P, w, D[0].width, D[0].height);
                for (let e = 0, i = D.length; e < i; e++)
                  (_ = D[e]),
                    A
                      ? n.texSubImage2D(
                          t.TEXTURE_2D,
                          e,
                          0,
                          0,
                          _.width,
                          _.height,
                          v,
                          M,
                          _.data
                        )
                      : n.texImage2D(
                          t.TEXTURE_2D,
                          e,
                          w,
                          _.width,
                          _.height,
                          0,
                          v,
                          M,
                          _.data
                        );
                r.generateMipmaps = !1;
              } else
                A
                  ? (C && n.texStorage2D(t.TEXTURE_2D, P, w, m.width, m.height),
                    n.texSubImage2D(
                      t.TEXTURE_2D,
                      0,
                      0,
                      0,
                      m.width,
                      m.height,
                      v,
                      M,
                      m.data
                    ))
                  : n.texImage2D(
                      t.TEXTURE_2D,
                      0,
                      w,
                      m.width,
                      m.height,
                      0,
                      v,
                      M,
                      m.data
                    );
            else if (r.isCompressedTexture)
              if (r.isCompressedArrayTexture) {
                A &&
                  C &&
                  n.texStorage3D(
                    t.TEXTURE_2D_ARRAY,
                    P,
                    w,
                    D[0].width,
                    D[0].height,
                    m.depth
                  );
                for (let e = 0, i = D.length; e < i; e++)
                  (_ = D[e]),
                    r.format !== vd
                      ? null !== v
                        ? A
                          ? n.compressedTexSubImage3D(
                              t.TEXTURE_2D_ARRAY,
                              e,
                              0,
                              0,
                              0,
                              _.width,
                              _.height,
                              m.depth,
                              v,
                              _.data,
                              0,
                              0
                            )
                          : n.compressedTexImage3D(
                              t.TEXTURE_2D_ARRAY,
                              e,
                              w,
                              _.width,
                              _.height,
                              m.depth,
                              0,
                              _.data,
                              0,
                              0
                            )
                        : console.warn(
                            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                          )
                      : A
                      ? n.texSubImage3D(
                          t.TEXTURE_2D_ARRAY,
                          e,
                          0,
                          0,
                          0,
                          _.width,
                          _.height,
                          m.depth,
                          v,
                          M,
                          _.data
                        )
                      : n.texImage3D(
                          t.TEXTURE_2D_ARRAY,
                          e,
                          w,
                          _.width,
                          _.height,
                          m.depth,
                          0,
                          v,
                          M,
                          _.data
                        );
              } else {
                A &&
                  C &&
                  n.texStorage2D(t.TEXTURE_2D, P, w, D[0].width, D[0].height);
                for (let e = 0, i = D.length; e < i; e++)
                  (_ = D[e]),
                    r.format !== vd
                      ? null !== v
                        ? A
                          ? n.compressedTexSubImage2D(
                              t.TEXTURE_2D,
                              e,
                              0,
                              0,
                              _.width,
                              _.height,
                              v,
                              _.data
                            )
                          : n.compressedTexImage2D(
                              t.TEXTURE_2D,
                              e,
                              w,
                              _.width,
                              _.height,
                              0,
                              _.data
                            )
                        : console.warn(
                            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                          )
                      : A
                      ? n.texSubImage2D(
                          t.TEXTURE_2D,
                          e,
                          0,
                          0,
                          _.width,
                          _.height,
                          v,
                          M,
                          _.data
                        )
                      : n.texImage2D(
                          t.TEXTURE_2D,
                          e,
                          w,
                          _.width,
                          _.height,
                          0,
                          v,
                          M,
                          _.data
                        );
              }
            else if (r.isDataArrayTexture)
              A
                ? (C &&
                    n.texStorage3D(
                      t.TEXTURE_2D_ARRAY,
                      P,
                      w,
                      m.width,
                      m.height,
                      m.depth
                    ),
                  n.texSubImage3D(
                    t.TEXTURE_2D_ARRAY,
                    0,
                    0,
                    0,
                    0,
                    m.width,
                    m.height,
                    m.depth,
                    v,
                    M,
                    m.data
                  ))
                : n.texImage3D(
                    t.TEXTURE_2D_ARRAY,
                    0,
                    w,
                    m.width,
                    m.height,
                    m.depth,
                    0,
                    v,
                    M,
                    m.data
                  );
            else if (r.isData3DTexture)
              A
                ? (C &&
                    n.texStorage3D(
                      t.TEXTURE_3D,
                      P,
                      w,
                      m.width,
                      m.height,
                      m.depth
                    ),
                  n.texSubImage3D(
                    t.TEXTURE_3D,
                    0,
                    0,
                    0,
                    0,
                    m.width,
                    m.height,
                    m.depth,
                    v,
                    M,
                    m.data
                  ))
                : n.texImage3D(
                    t.TEXTURE_3D,
                    0,
                    w,
                    m.width,
                    m.height,
                    m.depth,
                    0,
                    v,
                    M,
                    m.data
                  );
            else if (r.isFramebufferTexture) {
              if (C)
                if (A) n.texStorage2D(t.TEXTURE_2D, P, w, m.width, m.height);
                else {
                  let e = m.width,
                    i = m.height;
                  for (let r = 0; r < P; r++)
                    n.texImage2D(t.TEXTURE_2D, r, w, e, i, 0, v, M, null),
                      (e >>= 1),
                      (i >>= 1);
                }
            } else if (D.length > 0 && g) {
              A &&
                C &&
                n.texStorage2D(t.TEXTURE_2D, P, w, D[0].width, D[0].height);
              for (let e = 0, i = D.length; e < i; e++)
                (_ = D[e]),
                  A
                    ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, v, M, _)
                    : n.texImage2D(t.TEXTURE_2D, e, w, v, M, _);
              r.generateMipmaps = !1;
            } else
              A
                ? (C && n.texStorage2D(t.TEXTURE_2D, P, w, m.width, m.height),
                  n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, v, M, m))
                : n.texImage2D(t.TEXTURE_2D, 0, w, v, M, m);
            b(r, g) && S(l),
              (d.__version = h.version),
              r.onUpdate && r.onUpdate(r);
          }
          e.__version = r.version;
        }
        function U(e, r, o, a, l, c) {
          const u = s.convert(o.format, o.colorSpace),
            h = s.convert(o.type),
            p = E(o.internalFormat, u, h, o.colorSpace);
          if (!i.get(r).__hasExternalTextures) {
            const e = Math.max(1, r.width >> c),
              i = Math.max(1, r.height >> c);
            l === t.TEXTURE_3D || l === t.TEXTURE_2D_ARRAY
              ? n.texImage3D(l, c, p, e, i, r.depth, 0, u, h, null)
              : n.texImage2D(l, c, p, e, i, 0, u, h, null);
          }
          n.bindFramebuffer(t.FRAMEBUFFER, e),
            H(r)
              ? d.framebufferTexture2DMultisampleEXT(
                  t.FRAMEBUFFER,
                  a,
                  l,
                  i.get(o).__webglTexture,
                  0,
                  B(r)
                )
              : (l === t.TEXTURE_2D ||
                  (l >= t.TEXTURE_CUBE_MAP_POSITIVE_X &&
                    l <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
                t.framebufferTexture2D(
                  t.FRAMEBUFFER,
                  a,
                  l,
                  i.get(o).__webglTexture,
                  c
                ),
            n.bindFramebuffer(t.FRAMEBUFFER, null);
        }
        function k(e, n, i) {
          if (
            (t.bindRenderbuffer(t.RENDERBUFFER, e),
            n.depthBuffer && !n.stencilBuffer)
          ) {
            let r = !0 === a ? t.DEPTH_COMPONENT24 : t.DEPTH_COMPONENT16;
            if (i || H(n)) {
              const e = n.depthTexture;
              e &&
                e.isDepthTexture &&
                (e.type === fd
                  ? (r = t.DEPTH_COMPONENT32F)
                  : e.type === pd && (r = t.DEPTH_COMPONENT24));
              const i = B(n);
              H(n)
                ? d.renderbufferStorageMultisampleEXT(
                    t.RENDERBUFFER,
                    i,
                    r,
                    n.width,
                    n.height
                  )
                : t.renderbufferStorageMultisample(
                    t.RENDERBUFFER,
                    i,
                    r,
                    n.width,
                    n.height
                  );
            } else t.renderbufferStorage(t.RENDERBUFFER, r, n.width, n.height);
            t.framebufferRenderbuffer(
              t.FRAMEBUFFER,
              t.DEPTH_ATTACHMENT,
              t.RENDERBUFFER,
              e
            );
          } else if (n.depthBuffer && n.stencilBuffer) {
            const r = B(n);
            i && !1 === H(n)
              ? t.renderbufferStorageMultisample(
                  t.RENDERBUFFER,
                  r,
                  t.DEPTH24_STENCIL8,
                  n.width,
                  n.height
                )
              : H(n)
              ? d.renderbufferStorageMultisampleEXT(
                  t.RENDERBUFFER,
                  r,
                  t.DEPTH24_STENCIL8,
                  n.width,
                  n.height
                )
              : t.renderbufferStorage(
                  t.RENDERBUFFER,
                  t.DEPTH_STENCIL,
                  n.width,
                  n.height
                ),
              t.framebufferRenderbuffer(
                t.FRAMEBUFFER,
                t.DEPTH_STENCIL_ATTACHMENT,
                t.RENDERBUFFER,
                e
              );
          } else {
            const e =
              !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture];
            for (let r = 0; r < e.length; r++) {
              const o = e[r],
                a = s.convert(o.format, o.colorSpace),
                l = s.convert(o.type),
                c = E(o.internalFormat, a, l, o.colorSpace),
                u = B(n);
              i && !1 === H(n)
                ? t.renderbufferStorageMultisample(
                    t.RENDERBUFFER,
                    u,
                    c,
                    n.width,
                    n.height
                  )
                : H(n)
                ? d.renderbufferStorageMultisampleEXT(
                    t.RENDERBUFFER,
                    u,
                    c,
                    n.width,
                    n.height
                  )
                : t.renderbufferStorage(t.RENDERBUFFER, c, n.width, n.height);
            }
          }
          t.bindRenderbuffer(t.RENDERBUFFER, null);
        }
        function z(e) {
          const r = i.get(e),
            s = !0 === e.isWebGLCubeRenderTarget;
          if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
            if (s)
              throw new Error(
                "target.depthTexture not supported in Cube render targets"
              );
            !(function (e, r) {
              if (r && r.isWebGLCubeRenderTarget)
                throw new Error(
                  "Depth Texture with cube render targets is not supported"
                );
              if (
                (n.bindFramebuffer(t.FRAMEBUFFER, e),
                !r.depthTexture || !r.depthTexture.isDepthTexture)
              )
                throw new Error(
                  "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
                );
              (i.get(r.depthTexture).__webglTexture &&
                r.depthTexture.image.width === r.width &&
                r.depthTexture.image.height === r.height) ||
                ((r.depthTexture.image.width = r.width),
                (r.depthTexture.image.height = r.height),
                (r.depthTexture.needsUpdate = !0)),
                P(r.depthTexture, 0);
              const s = i.get(r.depthTexture).__webglTexture,
                o = B(r);
              if (r.depthTexture.format === _d)
                H(r)
                  ? d.framebufferTexture2DMultisampleEXT(
                      t.FRAMEBUFFER,
                      t.DEPTH_ATTACHMENT,
                      t.TEXTURE_2D,
                      s,
                      0,
                      o
                    )
                  : t.framebufferTexture2D(
                      t.FRAMEBUFFER,
                      t.DEPTH_ATTACHMENT,
                      t.TEXTURE_2D,
                      s,
                      0
                    );
              else {
                if (r.depthTexture.format !== yd)
                  throw new Error("Unknown depthTexture format");
                H(r)
                  ? d.framebufferTexture2DMultisampleEXT(
                      t.FRAMEBUFFER,
                      t.DEPTH_STENCIL_ATTACHMENT,
                      t.TEXTURE_2D,
                      s,
                      0,
                      o
                    )
                  : t.framebufferTexture2D(
                      t.FRAMEBUFFER,
                      t.DEPTH_STENCIL_ATTACHMENT,
                      t.TEXTURE_2D,
                      s,
                      0
                    );
              }
            })(r.__webglFramebuffer, e);
          } else if (s) {
            r.__webglDepthbuffer = [];
            for (let i = 0; i < 6; i++)
              n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer[i]),
                (r.__webglDepthbuffer[i] = t.createRenderbuffer()),
                k(r.__webglDepthbuffer[i], e, !1);
          } else
            n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer),
              (r.__webglDepthbuffer = t.createRenderbuffer()),
              k(r.__webglDepthbuffer, e, !1);
          n.bindFramebuffer(t.FRAMEBUFFER, null);
        }
        function B(t) {
          return Math.min(h, t.samples);
        }
        function H(t) {
          const n = i.get(t);
          return (
            a &&
            t.samples > 0 &&
            !0 === e.has("WEBGL_multisampled_render_to_texture") &&
            !1 !== n.__useRenderToTexture
          );
        }
        function V(t, n) {
          const i = t.colorSpace,
            r = t.format,
            s = t.type;
          return (
            !0 === t.isCompressedTexture ||
              !0 === t.isVideoTexture ||
              t.format === Bd ||
              (i !== Rd &&
                i !== Cd &&
                (dp.getTransfer(i) === Fd
                  ? !1 === a
                    ? !0 === e.has("EXT_sRGB") && r === vd
                      ? ((t.format = Bd),
                        (t.minFilter = cd),
                        (t.generateMipmaps = !1))
                      : (n = gp.sRGBToLinear(n))
                    : (r === vd && s === hd) ||
                      console.warn(
                        "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                      )
                  : console.error(
                      "THREE.WebGLTextures: Unsupported texture color space:",
                      i
                    ))),
            n
          );
        }
        (this.allocateTextureUnit = function () {
          const t = C;
          return (
            t >= l &&
              console.warn(
                "THREE.WebGLTextures: Trying to use " +
                  t +
                  " texture units while this GPU supports only " +
                  l
              ),
            (C += 1),
            t
          );
        }),
          (this.resetTextureUnits = function () {
            C = 0;
          }),
          (this.setTexture2D = P),
          (this.setTexture2DArray = function (e, r) {
            const s = i.get(e);
            e.version > 0 && s.__version !== e.version
              ? N(s, e, r)
              : n.bindTexture(
                  t.TEXTURE_2D_ARRAY,
                  s.__webglTexture,
                  t.TEXTURE0 + r
                );
          }),
          (this.setTexture3D = function (e, r) {
            const s = i.get(e);
            e.version > 0 && s.__version !== e.version
              ? N(s, e, r)
              : n.bindTexture(t.TEXTURE_3D, s.__webglTexture, t.TEXTURE0 + r);
          }),
          (this.setTextureCube = function (e, r) {
            const o = i.get(e);
            e.version > 0 && o.__version !== e.version
              ? (function (e, r, o) {
                  if (6 !== r.image.length) return;
                  const l = F(e, r),
                    u = r.source;
                  n.bindTexture(
                    t.TEXTURE_CUBE_MAP,
                    e.__webglTexture,
                    t.TEXTURE0 + o
                  );
                  const h = i.get(u);
                  if (u.version !== h.__version || !0 === l) {
                    n.activeTexture(t.TEXTURE0 + o);
                    const e = dp.getPrimaries(dp.workingColorSpace),
                      i =
                        r.colorSpace === Cd
                          ? null
                          : dp.getPrimaries(r.colorSpace),
                      d =
                        r.colorSpace === Cd || e === i
                          ? t.NONE
                          : t.BROWSER_DEFAULT_WEBGL;
                    t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, r.flipY),
                      t.pixelStorei(
                        t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                        r.premultiplyAlpha
                      ),
                      t.pixelStorei(t.UNPACK_ALIGNMENT, r.unpackAlignment),
                      t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
                    const p =
                        r.isCompressedTexture || r.image[0].isCompressedTexture,
                      f = r.image[0] && r.image[0].isDataTexture,
                      m = [];
                    for (let t = 0; t < 6; t++)
                      (m[t] =
                        p || f
                          ? f
                            ? r.image[t].image
                            : r.image[t]
                          : y(r.image[t], !1, !0, c)),
                        (m[t] = V(r, m[t]));
                    const g = m[0],
                      v = x(g) || a,
                      _ = s.convert(r.format, r.colorSpace),
                      M = s.convert(r.type),
                      w = E(r.internalFormat, _, M, r.colorSpace),
                      D = a && !0 !== r.isVideoTexture,
                      A = void 0 === h.__version || !0 === l;
                    let C,
                      P = T(r, g, v);
                    if ((I(t.TEXTURE_CUBE_MAP, r, v), p)) {
                      D &&
                        A &&
                        n.texStorage2D(
                          t.TEXTURE_CUBE_MAP,
                          P,
                          w,
                          g.width,
                          g.height
                        );
                      for (let e = 0; e < 6; e++) {
                        C = m[e].mipmaps;
                        for (let i = 0; i < C.length; i++) {
                          const s = C[i];
                          r.format !== vd
                            ? null !== _
                              ? D
                                ? n.compressedTexSubImage2D(
                                    t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                    i,
                                    0,
                                    0,
                                    s.width,
                                    s.height,
                                    _,
                                    s.data
                                  )
                                : n.compressedTexImage2D(
                                    t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                    i,
                                    w,
                                    s.width,
                                    s.height,
                                    0,
                                    s.data
                                  )
                              : console.warn(
                                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                                )
                            : D
                            ? n.texSubImage2D(
                                t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                i,
                                0,
                                0,
                                s.width,
                                s.height,
                                _,
                                M,
                                s.data
                              )
                            : n.texImage2D(
                                t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                i,
                                w,
                                s.width,
                                s.height,
                                0,
                                _,
                                M,
                                s.data
                              );
                        }
                      }
                    } else {
                      (C = r.mipmaps),
                        D &&
                          A &&
                          (C.length > 0 && P++,
                          n.texStorage2D(
                            t.TEXTURE_CUBE_MAP,
                            P,
                            w,
                            m[0].width,
                            m[0].height
                          ));
                      for (let e = 0; e < 6; e++)
                        if (f) {
                          D
                            ? n.texSubImage2D(
                                t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                0,
                                0,
                                0,
                                m[e].width,
                                m[e].height,
                                _,
                                M,
                                m[e].data
                              )
                            : n.texImage2D(
                                t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                0,
                                w,
                                m[e].width,
                                m[e].height,
                                0,
                                _,
                                M,
                                m[e].data
                              );
                          for (let i = 0; i < C.length; i++) {
                            const r = C[i].image[e].image;
                            D
                              ? n.texSubImage2D(
                                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                  i + 1,
                                  0,
                                  0,
                                  r.width,
                                  r.height,
                                  _,
                                  M,
                                  r.data
                                )
                              : n.texImage2D(
                                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                  i + 1,
                                  w,
                                  r.width,
                                  r.height,
                                  0,
                                  _,
                                  M,
                                  r.data
                                );
                          }
                        } else {
                          D
                            ? n.texSubImage2D(
                                t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                0,
                                0,
                                0,
                                _,
                                M,
                                m[e]
                              )
                            : n.texImage2D(
                                t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                0,
                                w,
                                _,
                                M,
                                m[e]
                              );
                          for (let i = 0; i < C.length; i++) {
                            const r = C[i];
                            D
                              ? n.texSubImage2D(
                                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                  i + 1,
                                  0,
                                  0,
                                  _,
                                  M,
                                  r.image[e]
                                )
                              : n.texImage2D(
                                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                  i + 1,
                                  w,
                                  _,
                                  M,
                                  r.image[e]
                                );
                          }
                        }
                    }
                    b(r, v) && S(t.TEXTURE_CUBE_MAP),
                      (h.__version = u.version),
                      r.onUpdate && r.onUpdate(r);
                  }
                  e.__version = r.version;
                })(o, e, r)
              : n.bindTexture(
                  t.TEXTURE_CUBE_MAP,
                  o.__webglTexture,
                  t.TEXTURE0 + r
                );
          }),
          (this.rebindTextures = function (e, n, r) {
            const s = i.get(e);
            void 0 !== n &&
              U(
                s.__webglFramebuffer,
                e,
                e.texture,
                t.COLOR_ATTACHMENT0,
                t.TEXTURE_2D,
                0
              ),
              void 0 !== r && z(e);
          }),
          (this.setupRenderTarget = function (e) {
            const l = e.texture,
              c = i.get(e),
              u = i.get(l);
            e.addEventListener("dispose", D),
              !0 !== e.isWebGLMultipleRenderTargets &&
                (void 0 === u.__webglTexture &&
                  (u.__webglTexture = t.createTexture()),
                (u.__version = l.version),
                o.memory.textures++);
            const h = !0 === e.isWebGLCubeRenderTarget,
              d = !0 === e.isWebGLMultipleRenderTargets,
              p = x(e) || a;
            if (h) {
              c.__webglFramebuffer = [];
              for (let e = 0; e < 6; e++)
                if (a && l.mipmaps && l.mipmaps.length > 0) {
                  c.__webglFramebuffer[e] = [];
                  for (let n = 0; n < l.mipmaps.length; n++)
                    c.__webglFramebuffer[e][n] = t.createFramebuffer();
                } else c.__webglFramebuffer[e] = t.createFramebuffer();
            } else {
              if (a && l.mipmaps && l.mipmaps.length > 0) {
                c.__webglFramebuffer = [];
                for (let e = 0; e < l.mipmaps.length; e++)
                  c.__webglFramebuffer[e] = t.createFramebuffer();
              } else c.__webglFramebuffer = t.createFramebuffer();
              if (d)
                if (r.drawBuffers) {
                  const n = e.texture;
                  for (let e = 0, r = n.length; e < r; e++) {
                    const r = i.get(n[e]);
                    void 0 === r.__webglTexture &&
                      ((r.__webglTexture = t.createTexture()),
                      o.memory.textures++);
                  }
                } else
                  console.warn(
                    "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
                  );
              if (a && e.samples > 0 && !1 === H(e)) {
                const i = d ? l : [l];
                (c.__webglMultisampledFramebuffer = t.createFramebuffer()),
                  (c.__webglColorRenderbuffer = []),
                  n.bindFramebuffer(
                    t.FRAMEBUFFER,
                    c.__webglMultisampledFramebuffer
                  );
                for (let n = 0; n < i.length; n++) {
                  const r = i[n];
                  (c.__webglColorRenderbuffer[n] = t.createRenderbuffer()),
                    t.bindRenderbuffer(
                      t.RENDERBUFFER,
                      c.__webglColorRenderbuffer[n]
                    );
                  const o = s.convert(r.format, r.colorSpace),
                    a = s.convert(r.type),
                    l = E(
                      r.internalFormat,
                      o,
                      a,
                      r.colorSpace,
                      !0 === e.isXRRenderTarget
                    ),
                    u = B(e);
                  t.renderbufferStorageMultisample(
                    t.RENDERBUFFER,
                    u,
                    l,
                    e.width,
                    e.height
                  ),
                    t.framebufferRenderbuffer(
                      t.FRAMEBUFFER,
                      t.COLOR_ATTACHMENT0 + n,
                      t.RENDERBUFFER,
                      c.__webglColorRenderbuffer[n]
                    );
                }
                t.bindRenderbuffer(t.RENDERBUFFER, null),
                  e.depthBuffer &&
                    ((c.__webglDepthRenderbuffer = t.createRenderbuffer()),
                    k(c.__webglDepthRenderbuffer, e, !0)),
                  n.bindFramebuffer(t.FRAMEBUFFER, null);
              }
            }
            if (h) {
              n.bindTexture(t.TEXTURE_CUBE_MAP, u.__webglTexture),
                I(t.TEXTURE_CUBE_MAP, l, p);
              for (let n = 0; n < 6; n++)
                if (a && l.mipmaps && l.mipmaps.length > 0)
                  for (let i = 0; i < l.mipmaps.length; i++)
                    U(
                      c.__webglFramebuffer[n][i],
                      e,
                      l,
                      t.COLOR_ATTACHMENT0,
                      t.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                      i
                    );
                else
                  U(
                    c.__webglFramebuffer[n],
                    e,
                    l,
                    t.COLOR_ATTACHMENT0,
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                    0
                  );
              b(l, p) && S(t.TEXTURE_CUBE_MAP), n.unbindTexture();
            } else if (d) {
              const r = e.texture;
              for (let s = 0, o = r.length; s < o; s++) {
                const o = r[s],
                  a = i.get(o);
                n.bindTexture(t.TEXTURE_2D, a.__webglTexture),
                  I(t.TEXTURE_2D, o, p),
                  U(
                    c.__webglFramebuffer,
                    e,
                    o,
                    t.COLOR_ATTACHMENT0 + s,
                    t.TEXTURE_2D,
                    0
                  ),
                  b(o, p) && S(t.TEXTURE_2D);
              }
              n.unbindTexture();
            } else {
              let i = t.TEXTURE_2D;
              if (
                ((e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) &&
                  (a
                    ? (i = e.isWebGL3DRenderTarget
                        ? t.TEXTURE_3D
                        : t.TEXTURE_2D_ARRAY)
                    : console.error(
                        "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
                      )),
                n.bindTexture(i, u.__webglTexture),
                I(i, l, p),
                a && l.mipmaps && l.mipmaps.length > 0)
              )
                for (let n = 0; n < l.mipmaps.length; n++)
                  U(c.__webglFramebuffer[n], e, l, t.COLOR_ATTACHMENT0, i, n);
              else U(c.__webglFramebuffer, e, l, t.COLOR_ATTACHMENT0, i, 0);
              b(l, p) && S(i), n.unbindTexture();
            }
            e.depthBuffer && z(e);
          }),
          (this.updateRenderTargetMipmap = function (e) {
            const r = x(e) || a,
              s =
                !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
            for (let o = 0, a = s.length; o < a; o++) {
              const a = s[o];
              if (b(a, r)) {
                const r = e.isWebGLCubeRenderTarget
                    ? t.TEXTURE_CUBE_MAP
                    : t.TEXTURE_2D,
                  s = i.get(a).__webglTexture;
                n.bindTexture(r, s), S(r), n.unbindTexture();
              }
            }
          }),
          (this.updateMultisampleRenderTarget = function (e) {
            if (a && e.samples > 0 && !1 === H(e)) {
              const r = e.isWebGLMultipleRenderTargets
                  ? e.texture
                  : [e.texture],
                s = e.width,
                o = e.height;
              let a = t.COLOR_BUFFER_BIT;
              const l = [],
                c = e.stencilBuffer
                  ? t.DEPTH_STENCIL_ATTACHMENT
                  : t.DEPTH_ATTACHMENT,
                u = i.get(e),
                h = !0 === e.isWebGLMultipleRenderTargets;
              if (h)
                for (let e = 0; e < r.length; e++)
                  n.bindFramebuffer(
                    t.FRAMEBUFFER,
                    u.__webglMultisampledFramebuffer
                  ),
                    t.framebufferRenderbuffer(
                      t.FRAMEBUFFER,
                      t.COLOR_ATTACHMENT0 + e,
                      t.RENDERBUFFER,
                      null
                    ),
                    n.bindFramebuffer(t.FRAMEBUFFER, u.__webglFramebuffer),
                    t.framebufferTexture2D(
                      t.DRAW_FRAMEBUFFER,
                      t.COLOR_ATTACHMENT0 + e,
                      t.TEXTURE_2D,
                      null,
                      0
                    );
              n.bindFramebuffer(
                t.READ_FRAMEBUFFER,
                u.__webglMultisampledFramebuffer
              ),
                n.bindFramebuffer(t.DRAW_FRAMEBUFFER, u.__webglFramebuffer);
              for (let n = 0; n < r.length; n++) {
                l.push(t.COLOR_ATTACHMENT0 + n), e.depthBuffer && l.push(c);
                const d =
                  void 0 !== u.__ignoreDepthValues && u.__ignoreDepthValues;
                if (
                  (!1 === d &&
                    (e.depthBuffer && (a |= t.DEPTH_BUFFER_BIT),
                    e.stencilBuffer && (a |= t.STENCIL_BUFFER_BIT)),
                  h &&
                    t.framebufferRenderbuffer(
                      t.READ_FRAMEBUFFER,
                      t.COLOR_ATTACHMENT0,
                      t.RENDERBUFFER,
                      u.__webglColorRenderbuffer[n]
                    ),
                  !0 === d &&
                    (t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [c]),
                    t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [c])),
                  h)
                ) {
                  const e = i.get(r[n]).__webglTexture;
                  t.framebufferTexture2D(
                    t.DRAW_FRAMEBUFFER,
                    t.COLOR_ATTACHMENT0,
                    t.TEXTURE_2D,
                    e,
                    0
                  );
                }
                t.blitFramebuffer(0, 0, s, o, 0, 0, s, o, a, t.NEAREST),
                  p && t.invalidateFramebuffer(t.READ_FRAMEBUFFER, l);
              }
              if (
                (n.bindFramebuffer(t.READ_FRAMEBUFFER, null),
                n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
                h)
              )
                for (let e = 0; e < r.length; e++) {
                  n.bindFramebuffer(
                    t.FRAMEBUFFER,
                    u.__webglMultisampledFramebuffer
                  ),
                    t.framebufferRenderbuffer(
                      t.FRAMEBUFFER,
                      t.COLOR_ATTACHMENT0 + e,
                      t.RENDERBUFFER,
                      u.__webglColorRenderbuffer[e]
                    );
                  const s = i.get(r[e]).__webglTexture;
                  n.bindFramebuffer(t.FRAMEBUFFER, u.__webglFramebuffer),
                    t.framebufferTexture2D(
                      t.DRAW_FRAMEBUFFER,
                      t.COLOR_ATTACHMENT0 + e,
                      t.TEXTURE_2D,
                      s,
                      0
                    );
                }
              n.bindFramebuffer(
                t.DRAW_FRAMEBUFFER,
                u.__webglMultisampledFramebuffer
              );
            }
          }),
          (this.setupDepthRenderbuffer = z),
          (this.setupFrameBufferTexture = U),
          (this.useMultisampledRTT = H);
      }
      function __(t, e, n) {
        const i = n.isWebGL2;
        return {
          convert: function (n, r = "") {
            let s;
            const o = dp.getTransfer(r);
            if (n === hd) return t.UNSIGNED_BYTE;
            if (1017 === n) return t.UNSIGNED_SHORT_4_4_4_4;
            if (1018 === n) return t.UNSIGNED_SHORT_5_5_5_1;
            if (1010 === n) return t.BYTE;
            if (1011 === n) return t.SHORT;
            if (n === dd) return t.UNSIGNED_SHORT;
            if (1013 === n) return t.INT;
            if (n === pd) return t.UNSIGNED_INT;
            if (n === fd) return t.FLOAT;
            if (n === md)
              return i
                ? t.HALF_FLOAT
                : ((s = e.get("OES_texture_half_float")),
                  null !== s ? s.HALF_FLOAT_OES : null);
            if (1021 === n) return t.ALPHA;
            if (n === vd) return t.RGBA;
            if (1024 === n) return t.LUMINANCE;
            if (1025 === n) return t.LUMINANCE_ALPHA;
            if (n === _d) return t.DEPTH_COMPONENT;
            if (n === yd) return t.DEPTH_STENCIL;
            if (n === Bd)
              return (
                (s = e.get("EXT_sRGB")), null !== s ? s.SRGB_ALPHA_EXT : null
              );
            if (1028 === n) return t.RED;
            if (1029 === n) return t.RED_INTEGER;
            if (1030 === n) return t.RG;
            if (1031 === n) return t.RG_INTEGER;
            if (1033 === n) return t.RGBA_INTEGER;
            if (n === xd || n === bd || n === Sd || n === Ed)
              if (o === Fd) {
                if (
                  ((s = e.get("WEBGL_compressed_texture_s3tc_srgb")),
                  null === s)
                )
                  return null;
                if (n === xd) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                if (n === bd) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                if (n === Sd) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                if (n === Ed) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
              } else {
                if (((s = e.get("WEBGL_compressed_texture_s3tc")), null === s))
                  return null;
                if (n === xd) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (n === bd) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (n === Sd) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (n === Ed) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
              }
            if (35840 === n || 35841 === n || 35842 === n || 35843 === n) {
              if (((s = e.get("WEBGL_compressed_texture_pvrtc")), null === s))
                return null;
              if (35840 === n) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (35841 === n) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (35842 === n) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (35843 === n) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            }
            if (36196 === n)
              return (
                (s = e.get("WEBGL_compressed_texture_etc1")),
                null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null
              );
            if (37492 === n || 37496 === n) {
              if (((s = e.get("WEBGL_compressed_texture_etc")), null === s))
                return null;
              if (37492 === n)
                return o === Fd
                  ? s.COMPRESSED_SRGB8_ETC2
                  : s.COMPRESSED_RGB8_ETC2;
              if (37496 === n)
                return o === Fd
                  ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                  : s.COMPRESSED_RGBA8_ETC2_EAC;
            }
            if (
              37808 === n ||
              37809 === n ||
              37810 === n ||
              37811 === n ||
              37812 === n ||
              37813 === n ||
              37814 === n ||
              37815 === n ||
              37816 === n ||
              37817 === n ||
              37818 === n ||
              37819 === n ||
              37820 === n ||
              37821 === n
            ) {
              if (((s = e.get("WEBGL_compressed_texture_astc")), null === s))
                return null;
              if (37808 === n)
                return o === Fd
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                  : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
              if (37809 === n)
                return o === Fd
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                  : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
              if (37810 === n)
                return o === Fd
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                  : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
              if (37811 === n)
                return o === Fd
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                  : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
              if (37812 === n)
                return o === Fd
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                  : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
              if (37813 === n)
                return o === Fd
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                  : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
              if (37814 === n)
                return o === Fd
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                  : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
              if (37815 === n)
                return o === Fd
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                  : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
              if (37816 === n)
                return o === Fd
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                  : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
              if (37817 === n)
                return o === Fd
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                  : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
              if (37818 === n)
                return o === Fd
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                  : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
              if (37819 === n)
                return o === Fd
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                  : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
              if (37820 === n)
                return o === Fd
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                  : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
              if (37821 === n)
                return o === Fd
                  ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                  : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
            }
            if (n === Td || 36494 === n || 36495 === n) {
              if (((s = e.get("EXT_texture_compression_bptc")), null === s))
                return null;
              if (n === Td)
                return o === Fd
                  ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                  : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
              if (36494 === n) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
              if (36495 === n) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
            }
            if (36283 === n || 36284 === n || 36285 === n || 36286 === n) {
              if (((s = e.get("EXT_texture_compression_rgtc")), null === s))
                return null;
              if (n === Td) return s.COMPRESSED_RED_RGTC1_EXT;
              if (36284 === n) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
              if (36285 === n) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
              if (36286 === n) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
            }
            return n === gd
              ? i
                ? t.UNSIGNED_INT_24_8
                : ((s = e.get("WEBGL_depth_texture")),
                  null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null)
              : void 0 !== t[n]
              ? t[n]
              : null;
          },
        };
      }
      class y_ extends km {
        constructor(t = []) {
          super(), (this.isArrayCamera = !0), (this.cameras = t);
        }
      }
      class x_ extends Pf {
        constructor() {
          super(), (this.isGroup = !0), (this.type = "Group");
        }
      }
      const b_ = {
        type: "move",
      };
      class S_ {
        constructor() {
          (this._targetRay = null), (this._grip = null), (this._hand = null);
        }
        getHandSpace() {
          return (
            null === this._hand &&
              ((this._hand = new x_()),
              (this._hand.matrixAutoUpdate = !1),
              (this._hand.visible = !1),
              (this._hand.joints = {}),
              (this._hand.inputState = {
                pinching: !1,
              })),
            this._hand
          );
        }
        getTargetRaySpace() {
          return (
            null === this._targetRay &&
              ((this._targetRay = new x_()),
              (this._targetRay.matrixAutoUpdate = !1),
              (this._targetRay.visible = !1),
              (this._targetRay.hasLinearVelocity = !1),
              (this._targetRay.linearVelocity = new Ap()),
              (this._targetRay.hasAngularVelocity = !1),
              (this._targetRay.angularVelocity = new Ap())),
            this._targetRay
          );
        }
        getGripSpace() {
          return (
            null === this._grip &&
              ((this._grip = new x_()),
              (this._grip.matrixAutoUpdate = !1),
              (this._grip.visible = !1),
              (this._grip.hasLinearVelocity = !1),
              (this._grip.linearVelocity = new Ap()),
              (this._grip.hasAngularVelocity = !1),
              (this._grip.angularVelocity = new Ap())),
            this._grip
          );
        }
        dispatchEvent(t) {
          return (
            null !== this._targetRay && this._targetRay.dispatchEvent(t),
            null !== this._grip && this._grip.dispatchEvent(t),
            null !== this._hand && this._hand.dispatchEvent(t),
            this
          );
        }
        connect(t) {
          if (t && t.hand) {
            const e = this._hand;
            if (e) for (const n of t.hand.values()) this._getHandJoint(e, n);
          }
          return (
            this.dispatchEvent({
              type: "connected",
              data: t,
            }),
            this
          );
        }
        disconnect(t) {
          return (
            this.dispatchEvent({
              type: "disconnected",
              data: t,
            }),
            null !== this._targetRay && (this._targetRay.visible = !1),
            null !== this._grip && (this._grip.visible = !1),
            null !== this._hand && (this._hand.visible = !1),
            this
          );
        }
        update(t, e, n) {
          let i = null,
            r = null,
            s = null;
          const o = this._targetRay,
            a = this._grip,
            l = this._hand;
          if (t && "visible-blurred" !== e.session.visibilityState) {
            if (l && t.hand) {
              s = !0;
              for (const i of t.hand.values()) {
                const t = e.getJointPose(i, n),
                  r = this._getHandJoint(l, i);
                null !== t &&
                  (r.matrix.fromArray(t.transform.matrix),
                  r.matrix.decompose(r.position, r.rotation, r.scale),
                  (r.matrixWorldNeedsUpdate = !0),
                  (r.jointRadius = t.radius)),
                  (r.visible = null !== t);
              }
              const i = l.joints["index-finger-tip"],
                r = l.joints["thumb-tip"],
                o = i.position.distanceTo(r.position),
                a = 0.02,
                c = 0.005;
              l.inputState.pinching && o > a + c
                ? ((l.inputState.pinching = !1),
                  this.dispatchEvent({
                    type: "pinchend",
                    handedness: t.handedness,
                    target: this,
                  }))
                : !l.inputState.pinching &&
                  o <= a - c &&
                  ((l.inputState.pinching = !0),
                  this.dispatchEvent({
                    type: "pinchstart",
                    handedness: t.handedness,
                    target: this,
                  }));
            } else
              null !== a &&
                t.gripSpace &&
                ((r = e.getPose(t.gripSpace, n)),
                null !== r &&
                  (a.matrix.fromArray(r.transform.matrix),
                  a.matrix.decompose(a.position, a.rotation, a.scale),
                  (a.matrixWorldNeedsUpdate = !0),
                  r.linearVelocity
                    ? ((a.hasLinearVelocity = !0),
                      a.linearVelocity.copy(r.linearVelocity))
                    : (a.hasLinearVelocity = !1),
                  r.angularVelocity
                    ? ((a.hasAngularVelocity = !0),
                      a.angularVelocity.copy(r.angularVelocity))
                    : (a.hasAngularVelocity = !1)));
            null !== o &&
              ((i = e.getPose(t.targetRaySpace, n)),
              null === i && null !== r && (i = r),
              null !== i &&
                (o.matrix.fromArray(i.transform.matrix),
                o.matrix.decompose(o.position, o.rotation, o.scale),
                (o.matrixWorldNeedsUpdate = !0),
                i.linearVelocity
                  ? ((o.hasLinearVelocity = !0),
                    o.linearVelocity.copy(i.linearVelocity))
                  : (o.hasLinearVelocity = !1),
                i.angularVelocity
                  ? ((o.hasAngularVelocity = !0),
                    o.angularVelocity.copy(i.angularVelocity))
                  : (o.hasAngularVelocity = !1),
                this.dispatchEvent(b_)));
          }
          return (
            null !== o && (o.visible = null !== i),
            null !== a && (a.visible = null !== r),
            null !== l && (l.visible = null !== s),
            this
          );
        }
        _getHandJoint(t, e) {
          if (void 0 === t.joints[e.jointName]) {
            const n = new x_();
            (n.matrixAutoUpdate = !1),
              (n.visible = !1),
              (t.joints[e.jointName] = n),
              t.add(n);
          }
          return t.joints[e.jointName];
        }
      }
      class E_ extends bp {
        constructor(t, e, n, i, r, s, o, a, l, c) {
          if ((c = void 0 !== c ? c : _d) !== _d && c !== yd)
            throw new Error(
              "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
            );
          void 0 === n && c === _d && (n = pd),
            void 0 === n && c === yd && (n = gd),
            super(null, i, r, s, o, a, c, n, l),
            (this.isDepthTexture = !0),
            (this.image = {
              width: t,
              height: e,
            }),
            (this.magFilter = void 0 !== o ? o : ad),
            (this.minFilter = void 0 !== a ? a : ad),
            (this.flipY = !1),
            (this.generateMipmaps = !1),
            (this.compareFunction = null);
        }
        copy(t) {
          return (
            super.copy(t), (this.compareFunction = t.compareFunction), this
          );
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (
            null !== this.compareFunction &&
              (e.compareFunction = this.compareFunction),
            e
          );
        }
      }
      class T_ extends Gd {
        constructor(t, e) {
          super();
          const n = this;
          let i = null,
            r = 1,
            s = null,
            o = "local-floor",
            a = 1,
            l = null,
            c = null,
            u = null,
            h = null,
            d = null,
            p = null;
          const f = e.getContextAttributes();
          let m = null,
            g = null;
          const v = [],
            _ = [],
            y = new km();
          y.layers.enable(1), (y.viewport = new Sp());
          const x = new km();
          x.layers.enable(2), (x.viewport = new Sp());
          const b = [y, x],
            S = new y_();
          S.layers.enable(1), S.layers.enable(2);
          let E = null,
            T = null;
          function M(t) {
            const e = _.indexOf(t.inputSource);
            if (-1 === e) return;
            const n = v[e];
            void 0 !== n &&
              (n.update(t.inputSource, t.frame, l || s),
              n.dispatchEvent({
                type: t.type,
                data: t.inputSource,
              }));
          }
          function w() {
            i.removeEventListener("select", M),
              i.removeEventListener("selectstart", M),
              i.removeEventListener("selectend", M),
              i.removeEventListener("squeeze", M),
              i.removeEventListener("squeezestart", M),
              i.removeEventListener("squeezeend", M),
              i.removeEventListener("end", w),
              i.removeEventListener("inputsourceschange", D);
            for (let t = 0; t < v.length; t++) {
              const e = _[t];
              null !== e && ((_[t] = null), v[t].disconnect(e));
            }
            (E = null),
              (T = null),
              t.setRenderTarget(m),
              (d = null),
              (h = null),
              (u = null),
              (i = null),
              (g = null),
              L.stop(),
              (n.isPresenting = !1),
              n.dispatchEvent({
                type: "sessionend",
              });
          }
          function D(t) {
            for (let e = 0; e < t.removed.length; e++) {
              const n = t.removed[e],
                i = _.indexOf(n);
              i >= 0 && ((_[i] = null), v[i].disconnect(n));
            }
            for (let e = 0; e < t.added.length; e++) {
              const n = t.added[e];
              let i = _.indexOf(n);
              if (-1 === i) {
                for (let t = 0; t < v.length; t++) {
                  if (t >= _.length) {
                    _.push(n), (i = t);
                    break;
                  }
                  if (null === _[t]) {
                    (_[t] = n), (i = t);
                    break;
                  }
                }
                if (-1 === i) break;
              }
              const r = v[i];
              r && r.connect(n);
            }
          }
          (this.cameraAutoUpdate = !0),
            (this.enabled = !1),
            (this.isPresenting = !1),
            (this.getController = function (t) {
              let e = v[t];
              return (
                void 0 === e && ((e = new S_()), (v[t] = e)),
                e.getTargetRaySpace()
              );
            }),
            (this.getControllerGrip = function (t) {
              let e = v[t];
              return (
                void 0 === e && ((e = new S_()), (v[t] = e)), e.getGripSpace()
              );
            }),
            (this.getHand = function (t) {
              let e = v[t];
              return (
                void 0 === e && ((e = new S_()), (v[t] = e)), e.getHandSpace()
              );
            }),
            (this.setFramebufferScaleFactor = function (t) {
              (r = t),
                !0 === n.isPresenting &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                  );
            }),
            (this.setReferenceSpaceType = function (t) {
              (o = t),
                !0 === n.isPresenting &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change reference space type while presenting."
                  );
            }),
            (this.getReferenceSpace = function () {
              return l || s;
            }),
            (this.setReferenceSpace = function (t) {
              l = t;
            }),
            (this.getBaseLayer = function () {
              return null !== h ? h : d;
            }),
            (this.getBinding = function () {
              return u;
            }),
            (this.getFrame = function () {
              return p;
            }),
            (this.getSession = function () {
              return i;
            }),
            (this.setSession = async function (c) {
              if (((i = c), null !== i)) {
                if (
                  ((m = t.getRenderTarget()),
                  i.addEventListener("select", M),
                  i.addEventListener("selectstart", M),
                  i.addEventListener("selectend", M),
                  i.addEventListener("squeeze", M),
                  i.addEventListener("squeezestart", M),
                  i.addEventListener("squeezeend", M),
                  i.addEventListener("end", w),
                  i.addEventListener("inputsourceschange", D),
                  !0 !== f.xrCompatible && (await e.makeXRCompatible()),
                  void 0 === i.renderState.layers ||
                    !1 === t.capabilities.isWebGL2)
                ) {
                  const n = {
                    antialias: void 0 !== i.renderState.layers || f.antialias,
                    alpha: !0,
                    depth: f.depth,
                    stencil: f.stencil,
                    framebufferScaleFactor: r,
                  };
                  (d = new XRWebGLLayer(i, e, n)),
                    i.updateRenderState({
                      baseLayer: d,
                    }),
                    (g = new Tp(d.framebufferWidth, d.framebufferHeight, {
                      format: vd,
                      type: hd,
                      colorSpace: t.outputColorSpace,
                      stencilBuffer: f.stencil,
                    }));
                } else {
                  let n = null,
                    s = null,
                    o = null;
                  f.depth &&
                    ((o = f.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24),
                    (n = f.stencil ? yd : _d),
                    (s = f.stencil ? gd : pd));
                  const a = {
                    colorFormat: e.RGBA8,
                    depthFormat: o,
                    scaleFactor: r,
                  };
                  (u = new XRWebGLBinding(i, e)),
                    (h = u.createProjectionLayer(a)),
                    i.updateRenderState({
                      layers: [h],
                    }),
                    (g = new Tp(h.textureWidth, h.textureHeight, {
                      format: vd,
                      type: hd,
                      depthTexture: new E_(
                        h.textureWidth,
                        h.textureHeight,
                        s,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        n
                      ),
                      stencilBuffer: f.stencil,
                      colorSpace: t.outputColorSpace,
                      samples: f.antialias ? 4 : 0,
                    })),
                    (t.properties.get(g).__ignoreDepthValues =
                      h.ignoreDepthValues);
                }
                (g.isXRRenderTarget = !0),
                  this.setFoveation(a),
                  (l = null),
                  (s = await i.requestReferenceSpace(o)),
                  L.setContext(i),
                  L.start(),
                  (n.isPresenting = !0),
                  n.dispatchEvent({
                    type: "sessionstart",
                  });
              }
            }),
            (this.getEnvironmentBlendMode = function () {
              if (null !== i) return i.environmentBlendMode;
            });
          const A = new Ap(),
            C = new Ap();
          function P(t, e) {
            null === e
              ? t.matrixWorld.copy(t.matrix)
              : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
              t.matrixWorldInverse.copy(t.matrixWorld).invert();
          }
          (this.updateCamera = function (t) {
            if (null === i) return;
            (S.near = x.near = y.near = t.near),
              (S.far = x.far = y.far = t.far),
              (E === S.near && T === S.far) ||
                (i.updateRenderState({
                  depthNear: S.near,
                  depthFar: S.far,
                }),
                (E = S.near),
                (T = S.far));
            const e = t.parent,
              n = S.cameras;
            P(S, e);
            for (let t = 0; t < n.length; t++) P(n[t], e);
            2 === n.length
              ? (function (t, e, n) {
                  A.setFromMatrixPosition(e.matrixWorld),
                    C.setFromMatrixPosition(n.matrixWorld);
                  const i = A.distanceTo(C),
                    r = e.projectionMatrix.elements,
                    s = n.projectionMatrix.elements,
                    o = r[14] / (r[10] - 1),
                    a = r[14] / (r[10] + 1),
                    l = (r[9] + 1) / r[5],
                    c = (r[9] - 1) / r[5],
                    u = (r[8] - 1) / r[0],
                    h = (s[8] + 1) / s[0],
                    d = o * u,
                    p = o * h,
                    f = i / (-u + h),
                    m = f * -u;
                  e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                    t.translateX(m),
                    t.translateZ(f),
                    t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                    t.matrixWorldInverse.copy(t.matrixWorld).invert();
                  const g = o + f,
                    v = a + f,
                    _ = d - m,
                    y = p + (i - m),
                    x = ((l * a) / v) * g,
                    b = ((c * a) / v) * g;
                  t.projectionMatrix.makePerspective(_, y, x, b, g, v),
                    t.projectionMatrixInverse.copy(t.projectionMatrix).invert();
                })(S, y, x)
              : S.projectionMatrix.copy(y.projectionMatrix),
              (function (t, e, n) {
                null === n
                  ? t.matrix.copy(e.matrixWorld)
                  : (t.matrix.copy(n.matrixWorld),
                    t.matrix.invert(),
                    t.matrix.multiply(e.matrixWorld)),
                  t.matrix.decompose(t.position, t.quaternion, t.scale),
                  t.updateMatrixWorld(!0),
                  t.projectionMatrix.copy(e.projectionMatrix),
                  t.projectionMatrixInverse.copy(e.projectionMatrixInverse),
                  t.isPerspectiveCamera &&
                    ((t.fov =
                      2 * Xd * Math.atan(1 / t.projectionMatrix.elements[5])),
                    (t.zoom = 1));
              })(t, S, e);
          }),
            (this.getCamera = function () {
              return S;
            }),
            (this.getFoveation = function () {
              if (null !== h || null !== d) return a;
            }),
            (this.setFoveation = function (t) {
              (a = t),
                null !== h && (h.fixedFoveation = t),
                null !== d &&
                  void 0 !== d.fixedFoveation &&
                  (d.fixedFoveation = t);
            });
          let R = null;
          const L = new Zm();
          L.setAnimationLoop(function (e, i) {
            if (((c = i.getViewerPose(l || s)), (p = i), null !== c)) {
              const e = c.views;
              null !== d &&
                (t.setRenderTargetFramebuffer(g, d.framebuffer),
                t.setRenderTarget(g));
              let n = !1;
              e.length !== S.cameras.length &&
                ((S.cameras.length = 0), (n = !0));
              for (let i = 0; i < e.length; i++) {
                const r = e[i];
                let s = null;
                if (null !== d) s = d.getViewport(r);
                else {
                  const e = u.getViewSubImage(h, r);
                  (s = e.viewport),
                    0 === i &&
                      (t.setRenderTargetTextures(
                        g,
                        e.colorTexture,
                        h.ignoreDepthValues ? void 0 : e.depthStencilTexture
                      ),
                      t.setRenderTarget(g));
                }
                let o = b[i];
                void 0 === o &&
                  ((o = new km()),
                  o.layers.enable(i),
                  (o.viewport = new Sp()),
                  (b[i] = o)),
                  o.matrix.fromArray(r.transform.matrix),
                  o.matrix.decompose(o.position, o.quaternion, o.scale),
                  o.projectionMatrix.fromArray(r.projectionMatrix),
                  o.projectionMatrixInverse.copy(o.projectionMatrix).invert(),
                  o.viewport.set(s.x, s.y, s.width, s.height),
                  0 === i &&
                    (S.matrix.copy(o.matrix),
                    S.matrix.decompose(S.position, S.quaternion, S.scale)),
                  !0 === n && S.cameras.push(o);
              }
            }
            for (let t = 0; t < v.length; t++) {
              const e = _[t],
                n = v[t];
              null !== e && void 0 !== n && n.update(e, i, l || s);
            }
            R && R(e, i),
              i.detectedPlanes &&
                n.dispatchEvent({
                  type: "planesdetected",
                  data: i,
                }),
              (p = null);
          }),
            (this.setAnimationLoop = function (t) {
              R = t;
            }),
            (this.dispose = function () {});
        }
      }
      function M_(t, e) {
        function n(t, e) {
          !0 === t.matrixAutoUpdate && t.updateMatrix(), e.value.copy(t.matrix);
        }
        function i(i, r) {
          (i.opacity.value = r.opacity),
            r.color && i.diffuse.value.copy(r.color),
            r.emissive &&
              i.emissive.value
                .copy(r.emissive)
                .multiplyScalar(r.emissiveIntensity),
            r.map && ((i.map.value = r.map), n(r.map, i.mapTransform)),
            r.alphaMap &&
              ((i.alphaMap.value = r.alphaMap),
              n(r.alphaMap, i.alphaMapTransform)),
            r.bumpMap &&
              ((i.bumpMap.value = r.bumpMap),
              n(r.bumpMap, i.bumpMapTransform),
              (i.bumpScale.value = r.bumpScale),
              1 === r.side && (i.bumpScale.value *= -1)),
            r.normalMap &&
              ((i.normalMap.value = r.normalMap),
              n(r.normalMap, i.normalMapTransform),
              i.normalScale.value.copy(r.normalScale),
              1 === r.side && i.normalScale.value.negate()),
            r.displacementMap &&
              ((i.displacementMap.value = r.displacementMap),
              n(r.displacementMap, i.displacementMapTransform),
              (i.displacementScale.value = r.displacementScale),
              (i.displacementBias.value = r.displacementBias)),
            r.emissiveMap &&
              ((i.emissiveMap.value = r.emissiveMap),
              n(r.emissiveMap, i.emissiveMapTransform)),
            r.specularMap &&
              ((i.specularMap.value = r.specularMap),
              n(r.specularMap, i.specularMapTransform)),
            r.alphaTest > 0 && (i.alphaTest.value = r.alphaTest);
          const s = e.get(r).envMap;
          if (
            (s &&
              ((i.envMap.value = s),
              (i.flipEnvMap.value =
                s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1),
              (i.reflectivity.value = r.reflectivity),
              (i.ior.value = r.ior),
              (i.refractionRatio.value = r.refractionRatio)),
            r.lightMap)
          ) {
            i.lightMap.value = r.lightMap;
            const e = !0 === t._useLegacyLights ? Math.PI : 1;
            (i.lightMapIntensity.value = r.lightMapIntensity * e),
              n(r.lightMap, i.lightMapTransform);
          }
          r.aoMap &&
            ((i.aoMap.value = r.aoMap),
            (i.aoMapIntensity.value = r.aoMapIntensity),
            n(r.aoMap, i.aoMapTransform));
        }
        return {
          refreshFogUniforms: function (e, n) {
            n.color.getRGB(e.fogColor.value, Im(t)),
              n.isFog
                ? ((e.fogNear.value = n.near), (e.fogFar.value = n.far))
                : n.isFogExp2 && (e.fogDensity.value = n.density);
          },
          refreshMaterialUniforms: function (t, r, s, o, a) {
            r.isMeshBasicMaterial || r.isMeshLambertMaterial
              ? i(t, r)
              : r.isMeshToonMaterial
              ? (i(t, r),
                (function (t, e) {
                  e.gradientMap && (t.gradientMap.value = e.gradientMap);
                })(t, r))
              : r.isMeshPhongMaterial
              ? (i(t, r),
                (function (t, e) {
                  t.specular.value.copy(e.specular),
                    (t.shininess.value = Math.max(e.shininess, 1e-4));
                })(t, r))
              : r.isMeshStandardMaterial
              ? (i(t, r),
                (function (t, i) {
                  (t.metalness.value = i.metalness),
                    i.metalnessMap &&
                      ((t.metalnessMap.value = i.metalnessMap),
                      n(i.metalnessMap, t.metalnessMapTransform)),
                    (t.roughness.value = i.roughness),
                    i.roughnessMap &&
                      ((t.roughnessMap.value = i.roughnessMap),
                      n(i.roughnessMap, t.roughnessMapTransform));
                  e.get(i).envMap &&
                    (t.envMapIntensity.value = i.envMapIntensity);
                })(t, r),
                r.isMeshPhysicalMaterial &&
                  (function (t, e, i) {
                    (t.ior.value = e.ior),
                      e.sheen > 0 &&
                        (t.sheenColor.value
                          .copy(e.sheenColor)
                          .multiplyScalar(e.sheen),
                        (t.sheenRoughness.value = e.sheenRoughness),
                        e.sheenColorMap &&
                          ((t.sheenColorMap.value = e.sheenColorMap),
                          n(e.sheenColorMap, t.sheenColorMapTransform)),
                        e.sheenRoughnessMap &&
                          ((t.sheenRoughnessMap.value = e.sheenRoughnessMap),
                          n(
                            e.sheenRoughnessMap,
                            t.sheenRoughnessMapTransform
                          ))),
                      e.clearcoat > 0 &&
                        ((t.clearcoat.value = e.clearcoat),
                        (t.clearcoatRoughness.value = e.clearcoatRoughness),
                        e.clearcoatMap &&
                          ((t.clearcoatMap.value = e.clearcoatMap),
                          n(e.clearcoatMap, t.clearcoatMapTransform)),
                        e.clearcoatRoughnessMap &&
                          ((t.clearcoatRoughnessMap.value =
                            e.clearcoatRoughnessMap),
                          n(
                            e.clearcoatRoughnessMap,
                            t.clearcoatRoughnessMapTransform
                          )),
                        e.clearcoatNormalMap &&
                          ((t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                          n(
                            e.clearcoatNormalMap,
                            t.clearcoatNormalMapTransform
                          ),
                          t.clearcoatNormalScale.value.copy(
                            e.clearcoatNormalScale
                          ),
                          1 === e.side &&
                            t.clearcoatNormalScale.value.negate())),
                      e.iridescence > 0 &&
                        ((t.iridescence.value = e.iridescence),
                        (t.iridescenceIOR.value = e.iridescenceIOR),
                        (t.iridescenceThicknessMinimum.value =
                          e.iridescenceThicknessRange[0]),
                        (t.iridescenceThicknessMaximum.value =
                          e.iridescenceThicknessRange[1]),
                        e.iridescenceMap &&
                          ((t.iridescenceMap.value = e.iridescenceMap),
                          n(e.iridescenceMap, t.iridescenceMapTransform)),
                        e.iridescenceThicknessMap &&
                          ((t.iridescenceThicknessMap.value =
                            e.iridescenceThicknessMap),
                          n(
                            e.iridescenceThicknessMap,
                            t.iridescenceThicknessMapTransform
                          ))),
                      e.transmission > 0 &&
                        ((t.transmission.value = e.transmission),
                        (t.transmissionSamplerMap.value = i.texture),
                        t.transmissionSamplerSize.value.set(i.width, i.height),
                        e.transmissionMap &&
                          ((t.transmissionMap.value = e.transmissionMap),
                          n(e.transmissionMap, t.transmissionMapTransform)),
                        (t.thickness.value = e.thickness),
                        e.thicknessMap &&
                          ((t.thicknessMap.value = e.thicknessMap),
                          n(e.thicknessMap, t.thicknessMapTransform)),
                        (t.attenuationDistance.value = e.attenuationDistance),
                        t.attenuationColor.value.copy(e.attenuationColor)),
                      e.anisotropy > 0 &&
                        (t.anisotropyVector.value.set(
                          e.anisotropy * Math.cos(e.anisotropyRotation),
                          e.anisotropy * Math.sin(e.anisotropyRotation)
                        ),
                        e.anisotropyMap &&
                          ((t.anisotropyMap.value = e.anisotropyMap),
                          n(e.anisotropyMap, t.anisotropyMapTransform))),
                      (t.specularIntensity.value = e.specularIntensity),
                      t.specularColor.value.copy(e.specularColor),
                      e.specularColorMap &&
                        ((t.specularColorMap.value = e.specularColorMap),
                        n(e.specularColorMap, t.specularColorMapTransform)),
                      e.specularIntensityMap &&
                        ((t.specularIntensityMap.value =
                          e.specularIntensityMap),
                        n(
                          e.specularIntensityMap,
                          t.specularIntensityMapTransform
                        ));
                  })(t, r, a))
              : r.isMeshMatcapMaterial
              ? (i(t, r),
                (function (t, e) {
                  e.matcap && (t.matcap.value = e.matcap);
                })(t, r))
              : r.isMeshDepthMaterial
              ? i(t, r)
              : r.isMeshDistanceMaterial
              ? (i(t, r),
                (function (t, n) {
                  const i = e.get(n).light;
                  t.referencePosition.value.setFromMatrixPosition(
                    i.matrixWorld
                  ),
                    (t.nearDistance.value = i.shadow.camera.near),
                    (t.farDistance.value = i.shadow.camera.far);
                })(t, r))
              : r.isMeshNormalMaterial
              ? i(t, r)
              : r.isLineBasicMaterial
              ? ((function (t, e) {
                  t.diffuse.value.copy(e.color),
                    (t.opacity.value = e.opacity),
                    e.map && ((t.map.value = e.map), n(e.map, t.mapTransform));
                })(t, r),
                r.isLineDashedMaterial &&
                  (function (t, e) {
                    (t.dashSize.value = e.dashSize),
                      (t.totalSize.value = e.dashSize + e.gapSize),
                      (t.scale.value = e.scale);
                  })(t, r))
              : r.isPointsMaterial
              ? (function (t, e, i, r) {
                  t.diffuse.value.copy(e.color),
                    (t.opacity.value = e.opacity),
                    (t.size.value = e.size * i),
                    (t.scale.value = 0.5 * r),
                    e.map && ((t.map.value = e.map), n(e.map, t.uvTransform)),
                    e.alphaMap &&
                      ((t.alphaMap.value = e.alphaMap),
                      n(e.alphaMap, t.alphaMapTransform)),
                    e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
                })(t, r, s, o)
              : r.isSpriteMaterial
              ? (function (t, e) {
                  t.diffuse.value.copy(e.color),
                    (t.opacity.value = e.opacity),
                    (t.rotation.value = e.rotation),
                    e.map && ((t.map.value = e.map), n(e.map, t.mapTransform)),
                    e.alphaMap &&
                      ((t.alphaMap.value = e.alphaMap),
                      n(e.alphaMap, t.alphaMapTransform)),
                    e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
                })(t, r)
              : r.isShadowMaterial
              ? (t.color.value.copy(r.color), (t.opacity.value = r.opacity))
              : r.isShaderMaterial && (r.uniformsNeedUpdate = !1);
          },
        };
      }
      function w_(t, e, n, i) {
        let r = {},
          s = {},
          o = [];
        const a = n.isWebGL2
          ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS)
          : 0;
        function l(t, e, n) {
          const i = t.value;
          if (void 0 === n[e]) {
            if ("number" == typeof i) n[e] = i;
            else {
              const t = Array.isArray(i) ? i : [i],
                r = [];
              for (let e = 0; e < t.length; e++) r.push(t[e].clone());
              n[e] = r;
            }
            return !0;
          }
          if ("number" == typeof i) {
            if (n[e] !== i) return (n[e] = i), !0;
          } else {
            const t = Array.isArray(n[e]) ? n[e] : [n[e]],
              r = Array.isArray(i) ? i : [i];
            for (let e = 0; e < t.length; e++) {
              const n = t[e];
              if (!1 === n.equals(r[e])) return n.copy(r[e]), !0;
            }
          }
          return !1;
        }
        function c(t) {
          const e = {
            boundary: 0,
            storage: 0,
          };
          return (
            "number" == typeof t
              ? ((e.boundary = 4), (e.storage = 4))
              : t.isVector2
              ? ((e.boundary = 8), (e.storage = 8))
              : t.isVector3 || t.isColor
              ? ((e.boundary = 16), (e.storage = 12))
              : t.isVector4
              ? ((e.boundary = 16), (e.storage = 16))
              : t.isMatrix3
              ? ((e.boundary = 48), (e.storage = 48))
              : t.isMatrix4
              ? ((e.boundary = 64), (e.storage = 64))
              : t.isTexture
              ? console.warn(
                  "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
                )
              : console.warn(
                  "THREE.WebGLRenderer: Unsupported uniform value type.",
                  t
                ),
            e
          );
        }
        function u(e) {
          const n = e.target;
          n.removeEventListener("dispose", u);
          const i = o.indexOf(n.__bindingPointIndex);
          o.splice(i, 1),
            t.deleteBuffer(r[n.id]),
            delete r[n.id],
            delete s[n.id];
        }
        return {
          bind: function (t, e) {
            const n = e.program;
            i.uniformBlockBinding(t, n);
          },
          update: function (n, h) {
            let d = r[n.id];
            void 0 === d &&
              ((function (t) {
                const e = t.uniforms;
                let n = 0;
                let i = 0;
                for (let t = 0, r = e.length; t < r; t++) {
                  const r = e[t],
                    s = {
                      boundary: 0,
                      storage: 0,
                    },
                    o = Array.isArray(r.value) ? r.value : [r.value];
                  for (let t = 0, e = o.length; t < e; t++) {
                    const e = c(o[t]);
                    (s.boundary += e.boundary), (s.storage += e.storage);
                  }
                  (r.__data = new Float32Array(
                    s.storage / Float32Array.BYTES_PER_ELEMENT
                  )),
                    (r.__offset = n),
                    t > 0 &&
                      ((i = n % 16),
                      0 !== i &&
                        16 - i - s.boundary < 0 &&
                        ((n += 16 - i), (r.__offset = n))),
                    (n += s.storage);
                }
                (i = n % 16),
                  i > 0 && (n += 16 - i),
                  (t.__size = n),
                  (t.__cache = {});
              })(n),
              (d = (function (e) {
                const n = (function () {
                  for (let t = 0; t < a; t++)
                    if (-1 === o.indexOf(t)) return o.push(t), t;
                  return (
                    console.error(
                      "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
                    ),
                    0
                  );
                })();
                e.__bindingPointIndex = n;
                const i = t.createBuffer(),
                  r = e.__size,
                  s = e.usage;
                return (
                  t.bindBuffer(t.UNIFORM_BUFFER, i),
                  t.bufferData(t.UNIFORM_BUFFER, r, s),
                  t.bindBuffer(t.UNIFORM_BUFFER, null),
                  t.bindBufferBase(t.UNIFORM_BUFFER, n, i),
                  i
                );
              })(n)),
              (r[n.id] = d),
              n.addEventListener("dispose", u));
            const p = h.program;
            i.updateUBOMapping(n, p);
            const f = e.render.frame;
            s[n.id] !== f &&
              ((function (e) {
                const n = r[e.id],
                  i = e.uniforms,
                  s = e.__cache;
                t.bindBuffer(t.UNIFORM_BUFFER, n);
                for (let e = 0, n = i.length; e < n; e++) {
                  const n = i[e];
                  if (!0 === l(n, e, s)) {
                    const e = n.__offset,
                      i = Array.isArray(n.value) ? n.value : [n.value];
                    let r = 0;
                    for (let s = 0; s < i.length; s++) {
                      const o = i[s],
                        a = c(o);
                      "number" == typeof o
                        ? ((n.__data[0] = o),
                          t.bufferSubData(t.UNIFORM_BUFFER, e + r, n.__data))
                        : o.isMatrix3
                        ? ((n.__data[0] = o.elements[0]),
                          (n.__data[1] = o.elements[1]),
                          (n.__data[2] = o.elements[2]),
                          (n.__data[3] = o.elements[0]),
                          (n.__data[4] = o.elements[3]),
                          (n.__data[5] = o.elements[4]),
                          (n.__data[6] = o.elements[5]),
                          (n.__data[7] = o.elements[0]),
                          (n.__data[8] = o.elements[6]),
                          (n.__data[9] = o.elements[7]),
                          (n.__data[10] = o.elements[8]),
                          (n.__data[11] = o.elements[0]))
                        : (o.toArray(n.__data, r),
                          (r += a.storage / Float32Array.BYTES_PER_ELEMENT));
                    }
                    t.bufferSubData(t.UNIFORM_BUFFER, e, n.__data);
                  }
                }
                t.bindBuffer(t.UNIFORM_BUFFER, null);
              })(n),
              (s[n.id] = f));
          },
          dispose: function () {
            for (const e in r) t.deleteBuffer(r[e]);
            (o = []), (r = {}), (s = {});
          },
        };
      }
      class D_ {
        constructor(t = {}) {
          const {
            canvas: e = sp(),
            context: n = null,
            depth: i = !0,
            stencil: r = !0,
            alpha: s = !1,
            antialias: o = !1,
            premultipliedAlpha: a = !0,
            preserveDrawingBuffer: l = !1,
            powerPreference: c = "default",
            failIfMajorPerformanceCaveat: u = !1,
          } = t;
          let h;
          (this.isWebGLRenderer = !0),
            (h = null !== n ? n.getContextAttributes().alpha : s);
          const d = new Uint32Array(4),
            p = new Int32Array(4);
          let f = null,
            m = null;
          const g = [],
            v = [];
          (this.domElement = e),
            (this.debug = {
              checkShaderErrors: !0,
              onShaderError: null,
            }),
            (this.autoClear = !0),
            (this.autoClearColor = !0),
            (this.autoClearDepth = !0),
            (this.autoClearStencil = !0),
            (this.sortObjects = !0),
            (this.clippingPlanes = []),
            (this.localClippingEnabled = !1),
            (this._outputColorSpace = Pd),
            (this._useLegacyLights = !1),
            (this.toneMapping = Kh),
            (this.toneMappingExposure = 1);
          const _ = this;
          let y = !1,
            x = 0,
            b = 0,
            S = null,
            E = -1,
            T = null;
          const M = new Sp(),
            w = new Sp();
          let D = null;
          const A = new Kf(0);
          let C = 0,
            P = e.width,
            R = e.height,
            L = 1,
            O = null,
            I = null;
          const F = new Sp(0, 0, P, R),
            N = new Sp(0, 0, P, R);
          let U = !1;
          const k = new Km();
          let z = !1,
            B = !1,
            H = null;
          const V = new sf(),
            G = new tp(),
            W = new Ap(),
            j = {
              background: null,
              fog: null,
              environment: null,
              overrideMaterial: null,
              isScene: !0,
            };
          function X() {
            return null === S ? L : 1;
          }
          let q,
            Y,
            K,
            Z,
            $,
            J,
            Q,
            tt,
            et,
            nt,
            it,
            rt,
            st,
            ot,
            at,
            lt,
            ct,
            ut,
            ht,
            dt,
            pt,
            ft,
            mt,
            gt,
            vt = n;
          function _t(t, n) {
            for (let i = 0; i < t.length; i++) {
              const r = t[i],
                s = e.getContext(r, n);
              if (null !== s) return s;
            }
            return null;
          }
          try {
            const t = {
              alpha: !0,
              depth: i,
              stencil: r,
              antialias: o,
              premultipliedAlpha: a,
              preserveDrawingBuffer: l,
              powerPreference: c,
              failIfMajorPerformanceCaveat: u,
            };
            if (
              ("setAttribute" in e &&
                e.setAttribute("data-engine", `three.js r${Hh}`),
              e.addEventListener("webglcontextlost", bt, !1),
              e.addEventListener("webglcontextrestored", St, !1),
              e.addEventListener("webglcontextcreationerror", Et, !1),
              null === vt)
            ) {
              const e = ["webgl2", "webgl", "experimental-webgl"];
              if (
                (!0 === _.isWebGL1Renderer && e.shift(),
                (vt = _t(e, t)),
                null === vt)
              )
                throw _t(e)
                  ? new Error(
                      "Error creating WebGL context with your selected attributes."
                    )
                  : new Error("Error creating WebGL context.");
            }
            "undefined" != typeof WebGLRenderingContext &&
              vt instanceof WebGLRenderingContext &&
              console.warn(
                "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."
              ),
              void 0 === vt.getShaderPrecisionFormat &&
                (vt.getShaderPrecisionFormat = function () {
                  return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1,
                  };
                });
          } catch (t) {
            throw (console.error("THREE.WebGLRenderer: " + t.message), t);
          }
          function yt() {
            (q = new Eg(vt)),
              (Y = new og(vt, q, t)),
              q.init(Y),
              (ft = new __(vt, q, Y)),
              (K = new g_(vt, q, Y)),
              (Z = new wg(vt)),
              ($ = new n_()),
              (J = new v_(vt, q, K, $, Y, ft, Z)),
              (Q = new lg(_)),
              (tt = new Sg(_)),
              (et = new $m(vt, Y)),
              (mt = new rg(vt, q, et, Y)),
              (nt = new Tg(vt, et, Z, mt)),
              (it = new Pg(vt, nt, et, Z)),
              (ht = new Cg(vt, Y, J)),
              (lt = new ag($)),
              (rt = new e_(_, Q, tt, q, Y, mt, lt)),
              (st = new M_(_, $)),
              (ot = new o_()),
              (at = new d_(q, Y)),
              (ut = new ig(_, Q, tt, K, it, h, a)),
              (ct = new m_(_, it, Y)),
              (gt = new w_(vt, Z, Y, K)),
              (dt = new sg(vt, q, Z, Y)),
              (pt = new Mg(vt, q, Z, Y)),
              (Z.programs = rt.programs),
              (_.capabilities = Y),
              (_.extensions = q),
              (_.properties = $),
              (_.renderLists = ot),
              (_.shadowMap = ct),
              (_.state = K),
              (_.info = Z);
          }
          yt();
          const xt = new T_(_, vt);
          function bt(t) {
            t.preventDefault(),
              console.log("THREE.WebGLRenderer: Context Lost."),
              (y = !0);
          }
          function St() {
            console.log("THREE.WebGLRenderer: Context Restored."), (y = !1);
            const t = Z.autoReset,
              e = ct.enabled,
              n = ct.autoUpdate,
              i = ct.needsUpdate,
              r = ct.type;
            yt(),
              (Z.autoReset = t),
              (ct.enabled = e),
              (ct.autoUpdate = n),
              (ct.needsUpdate = i),
              (ct.type = r);
          }
          function Et(t) {
            console.error(
              "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
              t.statusMessage
            );
          }
          function Tt(t) {
            const e = t.target;
            e.removeEventListener("dispose", Tt),
              (function (t) {
                (function (t) {
                  const e = $.get(t).programs;
                  void 0 !== e &&
                    (e.forEach(function (t) {
                      rt.releaseProgram(t);
                    }),
                    t.isShaderMaterial && rt.releaseShaderCache(t));
                })(t),
                  $.remove(t);
              })(e);
          }
          (this.xr = xt),
            (this.getContext = function () {
              return vt;
            }),
            (this.getContextAttributes = function () {
              return vt.getContextAttributes();
            }),
            (this.forceContextLoss = function () {
              const t = q.get("WEBGL_lose_context");
              t && t.loseContext();
            }),
            (this.forceContextRestore = function () {
              const t = q.get("WEBGL_lose_context");
              t && t.restoreContext();
            }),
            (this.getPixelRatio = function () {
              return L;
            }),
            (this.setPixelRatio = function (t) {
              void 0 !== t && ((L = t), this.setSize(P, R, !1));
            }),
            (this.getSize = function (t) {
              return t.set(P, R);
            }),
            (this.setSize = function (t, n, i = !0) {
              xt.isPresenting
                ? console.warn(
                    "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                  )
                : ((P = t),
                  (R = n),
                  (e.width = Math.floor(t * L)),
                  (e.height = Math.floor(n * L)),
                  !0 === i &&
                    ((e.style.width = t + "px"), (e.style.height = n + "px")),
                  this.setViewport(0, 0, t, n));
            }),
            (this.getDrawingBufferSize = function (t) {
              return t.set(P * L, R * L).floor();
            }),
            (this.setDrawingBufferSize = function (t, n, i) {
              (P = t),
                (R = n),
                (L = i),
                (e.width = Math.floor(t * i)),
                (e.height = Math.floor(n * i)),
                this.setViewport(0, 0, t, n);
            }),
            (this.getCurrentViewport = function (t) {
              return t.copy(M);
            }),
            (this.getViewport = function (t) {
              return t.copy(F);
            }),
            (this.setViewport = function (t, e, n, i) {
              t.isVector4 ? F.set(t.x, t.y, t.z, t.w) : F.set(t, e, n, i),
                K.viewport(M.copy(F).multiplyScalar(L).floor());
            }),
            (this.getScissor = function (t) {
              return t.copy(N);
            }),
            (this.setScissor = function (t, e, n, i) {
              t.isVector4 ? N.set(t.x, t.y, t.z, t.w) : N.set(t, e, n, i),
                K.scissor(w.copy(N).multiplyScalar(L).floor());
            }),
            (this.getScissorTest = function () {
              return U;
            }),
            (this.setScissorTest = function (t) {
              K.setScissorTest((U = t));
            }),
            (this.setOpaqueSort = function (t) {
              O = t;
            }),
            (this.setTransparentSort = function (t) {
              I = t;
            }),
            (this.getClearColor = function (t) {
              return t.copy(ut.getClearColor());
            }),
            (this.setClearColor = function () {
              ut.setClearColor.apply(ut, arguments);
            }),
            (this.getClearAlpha = function () {
              return ut.getClearAlpha();
            }),
            (this.setClearAlpha = function () {
              ut.setClearAlpha.apply(ut, arguments);
            }),
            (this.clear = function (t = !0, e = !0, n = !0) {
              let i = 0;
              if (t) {
                let t = !1;
                if (null !== S) {
                  const e = S.texture.format;
                  t = 1033 === e || 1031 === e || 1029 === e;
                }
                if (t) {
                  const t = S.texture.type,
                    e =
                      t === hd ||
                      t === pd ||
                      t === dd ||
                      t === gd ||
                      1017 === t ||
                      1018 === t,
                    n = ut.getClearColor(),
                    i = ut.getClearAlpha(),
                    r = n.r,
                    s = n.g,
                    o = n.b;
                  e
                    ? ((d[0] = r),
                      (d[1] = s),
                      (d[2] = o),
                      (d[3] = i),
                      vt.clearBufferuiv(vt.COLOR, 0, d))
                    : ((p[0] = r),
                      (p[1] = s),
                      (p[2] = o),
                      (p[3] = i),
                      vt.clearBufferiv(vt.COLOR, 0, p));
                } else i |= vt.COLOR_BUFFER_BIT;
              }
              e && (i |= vt.DEPTH_BUFFER_BIT),
                n && (i |= vt.STENCIL_BUFFER_BIT),
                vt.clear(i);
            }),
            (this.clearColor = function () {
              this.clear(!0, !1, !1);
            }),
            (this.clearDepth = function () {
              this.clear(!1, !0, !1);
            }),
            (this.clearStencil = function () {
              this.clear(!1, !1, !0);
            }),
            (this.dispose = function () {
              e.removeEventListener("webglcontextlost", bt, !1),
                e.removeEventListener("webglcontextrestored", St, !1),
                e.removeEventListener("webglcontextcreationerror", Et, !1),
                ot.dispose(),
                at.dispose(),
                $.dispose(),
                Q.dispose(),
                tt.dispose(),
                it.dispose(),
                mt.dispose(),
                gt.dispose(),
                rt.dispose(),
                xt.dispose(),
                xt.removeEventListener("sessionstart", wt),
                xt.removeEventListener("sessionend", Dt),
                H && (H.dispose(), (H = null)),
                At.stop();
            }),
            (this.renderBufferDirect = function (t, e, n, i, r, s) {
              null === e && (e = j);
              const o = r.isMesh && r.matrixWorld.determinant() < 0,
                a = (function (t, e, n, i, r) {
                  !0 !== e.isScene && (e = j), J.resetTextureUnits();
                  const s = e.fog,
                    o = i.isMeshStandardMaterial ? e.environment : null,
                    a =
                      null === S
                        ? _.outputColorSpace
                        : !0 === S.isXRRenderTarget
                        ? S.texture.colorSpace
                        : Rd,
                    l = (i.isMeshStandardMaterial ? tt : Q).get(i.envMap || o),
                    c =
                      !0 === i.vertexColors &&
                      !!n.attributes.color &&
                      4 === n.attributes.color.itemSize,
                    u =
                      !!n.attributes.tangent &&
                      (!!i.normalMap || i.anisotropy > 0),
                    h = !!n.morphAttributes.position,
                    d = !!n.morphAttributes.normal,
                    p = !!n.morphAttributes.color;
                  let f = Kh;
                  i.toneMapped &&
                    ((null !== S && !0 !== S.isXRRenderTarget) ||
                      (f = _.toneMapping));
                  const g =
                      n.morphAttributes.position ||
                      n.morphAttributes.normal ||
                      n.morphAttributes.color,
                    v = void 0 !== g ? g.length : 0,
                    y = $.get(i),
                    x = m.state.lights;
                  if (!0 === z && (!0 === B || t !== T)) {
                    const e = t === T && i.id === E;
                    lt.setState(i, t, e);
                  }
                  let b = !1;
                  i.version === y.__version
                    ? (y.needsLights &&
                        y.lightsStateVersion !== x.state.version) ||
                      y.outputColorSpace !== a ||
                      (r.isInstancedMesh && !1 === y.instancing)
                      ? (b = !0)
                      : r.isInstancedMesh || !0 !== y.instancing
                      ? r.isSkinnedMesh && !1 === y.skinning
                        ? (b = !0)
                        : r.isSkinnedMesh || !0 !== y.skinning
                        ? (r.isInstancedMesh &&
                            !0 === y.instancingColor &&
                            null === r.instanceColor) ||
                          (r.isInstancedMesh &&
                            !1 === y.instancingColor &&
                            null !== r.instanceColor) ||
                          y.envMap !== l ||
                          (!0 === i.fog && y.fog !== s)
                          ? (b = !0)
                          : void 0 === y.numClippingPlanes ||
                            (y.numClippingPlanes === lt.numPlanes &&
                              y.numIntersection === lt.numIntersection)
                          ? (y.vertexAlphas !== c ||
                              y.vertexTangents !== u ||
                              y.morphTargets !== h ||
                              y.morphNormals !== d ||
                              y.morphColors !== p ||
                              y.toneMapping !== f ||
                              (!0 === Y.isWebGL2 &&
                                y.morphTargetsCount !== v)) &&
                            (b = !0)
                          : (b = !0)
                        : (b = !0)
                      : (b = !0)
                    : ((b = !0), (y.__version = i.version));
                  let M = y.currentProgram;
                  !0 === b && (M = Ot(i, e, r));
                  let w = !1,
                    D = !1,
                    A = !1;
                  const C = M.getUniforms(),
                    P = y.uniforms;
                  if (
                    (K.useProgram(M.program) && ((w = !0), (D = !0), (A = !0)),
                    i.id !== E && ((E = i.id), (D = !0)),
                    w || T !== t)
                  ) {
                    C.setValue(vt, "projectionMatrix", t.projectionMatrix),
                      C.setValue(vt, "viewMatrix", t.matrixWorldInverse);
                    const e = C.map.cameraPosition;
                    void 0 !== e &&
                      e.setValue(vt, W.setFromMatrixPosition(t.matrixWorld)),
                      Y.logarithmicDepthBuffer &&
                        C.setValue(
                          vt,
                          "logDepthBufFC",
                          2 / (Math.log(t.far + 1) / Math.LN2)
                        ),
                      (i.isMeshPhongMaterial ||
                        i.isMeshToonMaterial ||
                        i.isMeshLambertMaterial ||
                        i.isMeshBasicMaterial ||
                        i.isMeshStandardMaterial ||
                        i.isShaderMaterial) &&
                        C.setValue(
                          vt,
                          "isOrthographic",
                          !0 === t.isOrthographicCamera
                        ),
                      T !== t && ((T = t), (D = !0), (A = !0));
                  }
                  if (r.isSkinnedMesh) {
                    C.setOptional(vt, r, "bindMatrix"),
                      C.setOptional(vt, r, "bindMatrixInverse");
                    const t = r.skeleton;
                    t &&
                      (Y.floatVertexTextures
                        ? (null === t.boneTexture && t.computeBoneTexture(),
                          C.setValue(vt, "boneTexture", t.boneTexture, J),
                          C.setValue(vt, "boneTextureSize", t.boneTextureSize))
                        : console.warn(
                            "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
                          ));
                  }
                  const O = n.morphAttributes;
                  var I, F;
                  if (
                    ((void 0 !== O.position ||
                      void 0 !== O.normal ||
                      (void 0 !== O.color && !0 === Y.isWebGL2)) &&
                      ht.update(r, n, M),
                    (D || y.receiveShadow !== r.receiveShadow) &&
                      ((y.receiveShadow = r.receiveShadow),
                      C.setValue(vt, "receiveShadow", r.receiveShadow)),
                    i.isMeshGouraudMaterial &&
                      null !== i.envMap &&
                      ((P.envMap.value = l),
                      (P.flipEnvMap.value =
                        l.isCubeTexture && !1 === l.isRenderTargetTexture
                          ? -1
                          : 1)),
                    D &&
                      (C.setValue(
                        vt,
                        "toneMappingExposure",
                        _.toneMappingExposure
                      ),
                      y.needsLights &&
                        ((F = A),
                        ((I = P).ambientLightColor.needsUpdate = F),
                        (I.lightProbe.needsUpdate = F),
                        (I.directionalLights.needsUpdate = F),
                        (I.directionalLightShadows.needsUpdate = F),
                        (I.pointLights.needsUpdate = F),
                        (I.pointLightShadows.needsUpdate = F),
                        (I.spotLights.needsUpdate = F),
                        (I.spotLightShadows.needsUpdate = F),
                        (I.rectAreaLights.needsUpdate = F),
                        (I.hemisphereLights.needsUpdate = F)),
                      s && !0 === i.fog && st.refreshFogUniforms(P, s),
                      st.refreshMaterialUniforms(P, i, L, R, H),
                      Iv.upload(vt, y.uniformsList, P, J)),
                    i.isShaderMaterial &&
                      !0 === i.uniformsNeedUpdate &&
                      (Iv.upload(vt, y.uniformsList, P, J),
                      (i.uniformsNeedUpdate = !1)),
                    i.isSpriteMaterial && C.setValue(vt, "center", r.center),
                    C.setValue(vt, "modelViewMatrix", r.modelViewMatrix),
                    C.setValue(vt, "normalMatrix", r.normalMatrix),
                    C.setValue(vt, "modelMatrix", r.matrixWorld),
                    i.isShaderMaterial || i.isRawShaderMaterial)
                  ) {
                    const t = i.uniformsGroups;
                    for (let e = 0, n = t.length; e < n; e++)
                      if (Y.isWebGL2) {
                        const n = t[e];
                        gt.update(n, M), gt.bind(n, M);
                      } else
                        console.warn(
                          "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
                        );
                  }
                  return M;
                })(t, e, n, i, r);
              K.setMaterial(i, o);
              let l = n.index,
                c = 1;
              if (!0 === i.wireframe) {
                if (((l = nt.getWireframeAttribute(n)), void 0 === l)) return;
                c = 2;
              }
              const u = n.drawRange,
                h = n.attributes.position;
              let d = u.start * c,
                p = (u.start + u.count) * c;
              null !== s &&
                ((d = Math.max(d, s.start * c)),
                (p = Math.min(p, (s.start + s.count) * c))),
                null !== l
                  ? ((d = Math.max(d, 0)), (p = Math.min(p, l.count)))
                  : null != h &&
                    ((d = Math.max(d, 0)), (p = Math.min(p, h.count)));
              const f = p - d;
              if (f < 0 || f === 1 / 0) return;
              let g;
              mt.setup(r, i, a, n, l);
              let v = dt;
              if (
                (null !== l && ((g = et.get(l)), (v = pt), v.setIndex(g)),
                r.isMesh)
              )
                !0 === i.wireframe
                  ? (K.setLineWidth(i.wireframeLinewidth * X()),
                    v.setMode(vt.LINES))
                  : v.setMode(vt.TRIANGLES);
              else if (r.isLine) {
                let t = i.linewidth;
                void 0 === t && (t = 1),
                  K.setLineWidth(t * X()),
                  r.isLineSegments
                    ? v.setMode(vt.LINES)
                    : r.isLineLoop
                    ? v.setMode(vt.LINE_LOOP)
                    : v.setMode(vt.LINE_STRIP);
              } else
                r.isPoints
                  ? v.setMode(vt.POINTS)
                  : r.isSprite && v.setMode(vt.TRIANGLES);
              if (r.isInstancedMesh) v.renderInstances(d, f, r.count);
              else if (n.isInstancedBufferGeometry) {
                const t =
                    void 0 !== n._maxInstanceCount
                      ? n._maxInstanceCount
                      : 1 / 0,
                  e = Math.min(n.instanceCount, t);
                v.renderInstances(d, f, e);
              } else v.render(d, f);
            }),
            (this.compile = function (t, e) {
              function n(t, e, n) {
                !0 === t.transparent && 2 === t.side && !1 === t.forceSinglePass
                  ? ((t.side = 1),
                    (t.needsUpdate = !0),
                    Ot(t, e, n),
                    (t.side = 0),
                    (t.needsUpdate = !0),
                    Ot(t, e, n),
                    (t.side = 2))
                  : Ot(t, e, n);
              }
              (m = at.get(t)),
                m.init(),
                v.push(m),
                t.traverseVisible(function (t) {
                  t.isLight &&
                    t.layers.test(e.layers) &&
                    (m.pushLight(t), t.castShadow && m.pushShadow(t));
                }),
                m.setupLights(_._useLegacyLights),
                t.traverse(function (e) {
                  const i = e.material;
                  if (i)
                    if (Array.isArray(i))
                      for (let r = 0; r < i.length; r++) n(i[r], t, e);
                    else n(i, t, e);
                }),
                v.pop(),
                (m = null);
            });
          let Mt = null;
          function wt() {
            At.stop();
          }
          function Dt() {
            At.start();
          }
          const At = new Zm();
          function Ct(t, e, n, i) {
            if (!1 === t.visible) return;
            if (t.layers.test(e.layers))
              if (t.isGroup) n = t.renderOrder;
              else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
              else if (t.isLight)
                m.pushLight(t), t.castShadow && m.pushShadow(t);
              else if (t.isSprite) {
                if (!t.frustumCulled || k.intersectsSprite(t)) {
                  i && W.setFromMatrixPosition(t.matrixWorld).applyMatrix4(V);
                  const e = it.update(t),
                    r = t.material;
                  r.visible && f.push(t, e, r, n, W.z, null);
                }
              } else if (
                (t.isMesh || t.isLine || t.isPoints) &&
                (!t.frustumCulled || k.intersectsObject(t))
              ) {
                const e = it.update(t),
                  r = t.material;
                if (
                  (i &&
                    (void 0 !== t.boundingSphere
                      ? (null === t.boundingSphere && t.computeBoundingSphere(),
                        W.copy(t.boundingSphere.center))
                      : (null === e.boundingSphere && e.computeBoundingSphere(),
                        W.copy(e.boundingSphere.center)),
                    W.applyMatrix4(t.matrixWorld).applyMatrix4(V)),
                  Array.isArray(r))
                ) {
                  const i = e.groups;
                  for (let s = 0, o = i.length; s < o; s++) {
                    const o = i[s],
                      a = r[o.materialIndex];
                    a && a.visible && f.push(t, e, a, n, W.z, o);
                  }
                } else r.visible && f.push(t, e, r, n, W.z, null);
              }
            const r = t.children;
            for (let t = 0, s = r.length; t < s; t++) Ct(r[t], e, n, i);
          }
          function Pt(t, e, n, i) {
            const r = t.opaque,
              s = t.transmissive,
              o = t.transparent;
            m.setupLightsView(n),
              !0 === z && lt.setGlobalState(_.clippingPlanes, n),
              s.length > 0 &&
                (function (t, e, n, i) {
                  const r = Y.isWebGL2;
                  null === H &&
                    (H = new Tp(1, 1, {
                      generateMipmaps: !0,
                      type: q.has("EXT_color_buffer_half_float") ? md : hd,
                      minFilter: ud,
                      samples: r ? 4 : 0,
                    })),
                    _.getDrawingBufferSize(G),
                    r ? H.setSize(G.x, G.y) : H.setSize($d(G.x), $d(G.y));
                  const s = _.getRenderTarget();
                  _.setRenderTarget(H),
                    _.getClearColor(A),
                    (C = _.getClearAlpha()),
                    C < 1 && _.setClearColor(16777215, 0.5),
                    _.clear();
                  const o = _.toneMapping;
                  (_.toneMapping = Kh),
                    Rt(t, n, i),
                    J.updateMultisampleRenderTarget(H),
                    J.updateRenderTargetMipmap(H);
                  let a = !1;
                  for (let t = 0, r = e.length; t < r; t++) {
                    const r = e[t],
                      s = r.object,
                      o = r.geometry,
                      l = r.material,
                      c = r.group;
                    if (2 === l.side && s.layers.test(i.layers)) {
                      const t = l.side;
                      (l.side = 1),
                        (l.needsUpdate = !0),
                        Lt(s, n, i, o, l, c),
                        (l.side = t),
                        (l.needsUpdate = !0),
                        (a = !0);
                    }
                  }
                  !0 === a &&
                    (J.updateMultisampleRenderTarget(H),
                    J.updateRenderTargetMipmap(H)),
                    _.setRenderTarget(s),
                    _.setClearColor(A, C),
                    (_.toneMapping = o);
                })(r, s, e, n),
              i && K.viewport(M.copy(i)),
              r.length > 0 && Rt(r, e, n),
              s.length > 0 && Rt(s, e, n),
              o.length > 0 && Rt(o, e, n),
              K.buffers.depth.setTest(!0),
              K.buffers.depth.setMask(!0),
              K.buffers.color.setMask(!0),
              K.setPolygonOffset(!1);
          }
          function Rt(t, e, n) {
            const i = !0 === e.isScene ? e.overrideMaterial : null;
            for (let r = 0, s = t.length; r < s; r++) {
              const s = t[r],
                o = s.object,
                a = s.geometry,
                l = null === i ? s.material : i,
                c = s.group;
              o.layers.test(n.layers) && Lt(o, e, n, a, l, c);
            }
          }
          function Lt(t, e, n, i, r, s) {
            t.onBeforeRender(_, e, n, i, r, s),
              t.modelViewMatrix.multiplyMatrices(
                n.matrixWorldInverse,
                t.matrixWorld
              ),
              t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
              r.onBeforeRender(_, e, n, i, t, s),
              !0 === r.transparent && 2 === r.side && !1 === r.forceSinglePass
                ? ((r.side = 1),
                  (r.needsUpdate = !0),
                  _.renderBufferDirect(n, e, i, r, t, s),
                  (r.side = 0),
                  (r.needsUpdate = !0),
                  _.renderBufferDirect(n, e, i, r, t, s),
                  (r.side = 2))
                : _.renderBufferDirect(n, e, i, r, t, s),
              t.onAfterRender(_, e, n, i, r, s);
          }
          function Ot(t, e, n) {
            !0 !== e.isScene && (e = j);
            const i = $.get(t),
              r = m.state.lights,
              s = m.state.shadowsArray,
              o = r.state.version,
              a = rt.getParameters(t, r.state, s, e, n),
              l = rt.getProgramCacheKey(a);
            let c = i.programs;
            (i.environment = t.isMeshStandardMaterial ? e.environment : null),
              (i.fog = e.fog),
              (i.envMap = (t.isMeshStandardMaterial ? tt : Q).get(
                t.envMap || i.environment
              )),
              void 0 === c &&
                (t.addEventListener("dispose", Tt),
                (c = new Map()),
                (i.programs = c));
            let u = c.get(l);
            if (void 0 !== u) {
              if (i.currentProgram === u && i.lightsStateVersion === o)
                return It(t, a), u;
            } else
              (a.uniforms = rt.getUniforms(t)),
                t.onBuild(n, a, _),
                t.onBeforeCompile(a, _),
                (u = rt.acquireProgram(a, l)),
                c.set(l, u),
                (i.uniforms = a.uniforms);
            const h = i.uniforms;
            ((t.isShaderMaterial || t.isRawShaderMaterial) &&
              !0 !== t.clipping) ||
              (h.clippingPlanes = lt.uniform),
              It(t, a),
              (i.needsLights = (function (t) {
                return (
                  t.isMeshLambertMaterial ||
                  t.isMeshToonMaterial ||
                  t.isMeshPhongMaterial ||
                  t.isMeshStandardMaterial ||
                  t.isShadowMaterial ||
                  (t.isShaderMaterial && !0 === t.lights)
                );
              })(t)),
              (i.lightsStateVersion = o),
              i.needsLights &&
                ((h.ambientLightColor.value = r.state.ambient),
                (h.lightProbe.value = r.state.probe),
                (h.directionalLights.value = r.state.directional),
                (h.directionalLightShadows.value = r.state.directionalShadow),
                (h.spotLights.value = r.state.spot),
                (h.spotLightShadows.value = r.state.spotShadow),
                (h.rectAreaLights.value = r.state.rectArea),
                (h.ltc_1.value = r.state.rectAreaLTC1),
                (h.ltc_2.value = r.state.rectAreaLTC2),
                (h.pointLights.value = r.state.point),
                (h.pointLightShadows.value = r.state.pointShadow),
                (h.hemisphereLights.value = r.state.hemi),
                (h.directionalShadowMap.value = r.state.directionalShadowMap),
                (h.directionalShadowMatrix.value =
                  r.state.directionalShadowMatrix),
                (h.spotShadowMap.value = r.state.spotShadowMap),
                (h.spotLightMatrix.value = r.state.spotLightMatrix),
                (h.spotLightMap.value = r.state.spotLightMap),
                (h.pointShadowMap.value = r.state.pointShadowMap),
                (h.pointShadowMatrix.value = r.state.pointShadowMatrix));
            const d = u.getUniforms(),
              p = Iv.seqWithValue(d.seq, h);
            return (i.currentProgram = u), (i.uniformsList = p), u;
          }
          function It(t, e) {
            const n = $.get(t);
            (n.outputColorSpace = e.outputColorSpace),
              (n.instancing = e.instancing),
              (n.instancingColor = e.instancingColor),
              (n.skinning = e.skinning),
              (n.morphTargets = e.morphTargets),
              (n.morphNormals = e.morphNormals),
              (n.morphColors = e.morphColors),
              (n.morphTargetsCount = e.morphTargetsCount),
              (n.numClippingPlanes = e.numClippingPlanes),
              (n.numIntersection = e.numClipIntersection),
              (n.vertexAlphas = e.vertexAlphas),
              (n.vertexTangents = e.vertexTangents),
              (n.toneMapping = e.toneMapping);
          }
          At.setAnimationLoop(function (t) {
            Mt && Mt(t);
          }),
            "undefined" != typeof self && At.setContext(self),
            (this.setAnimationLoop = function (t) {
              (Mt = t),
                xt.setAnimationLoop(t),
                null === t ? At.stop() : At.start();
            }),
            xt.addEventListener("sessionstart", wt),
            xt.addEventListener("sessionend", Dt),
            (this.render = function (t, e) {
              if (void 0 !== e && !0 !== e.isCamera)
                return void console.error(
                  "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
                );
              if (!0 === y) return;
              !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(),
                null === e.parent &&
                  !0 === e.matrixWorldAutoUpdate &&
                  e.updateMatrixWorld(),
                !0 === xt.enabled &&
                  !0 === xt.isPresenting &&
                  (!0 === xt.cameraAutoUpdate && xt.updateCamera(e),
                  (e = xt.getCamera())),
                !0 === t.isScene && t.onBeforeRender(_, t, e, S),
                (m = at.get(t, v.length)),
                m.init(),
                v.push(m),
                V.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                k.setFromProjectionMatrix(V),
                (B = this.localClippingEnabled),
                (z = lt.init(this.clippingPlanes, B)),
                (f = ot.get(t, g.length)),
                f.init(),
                g.push(f),
                Ct(t, e, 0, _.sortObjects),
                f.finish(),
                !0 === _.sortObjects && f.sort(O, I),
                this.info.render.frame++,
                !0 === z && lt.beginShadows();
              const n = m.state.shadowsArray;
              if (
                (ct.render(n, t, e),
                !0 === z && lt.endShadows(),
                !0 === this.info.autoReset && this.info.reset(),
                ut.render(f, t),
                m.setupLights(_._useLegacyLights),
                e.isArrayCamera)
              ) {
                const n = e.cameras;
                for (let e = 0, i = n.length; e < i; e++) {
                  const i = n[e];
                  Pt(f, t, i, i.viewport);
                }
              } else Pt(f, t, e);
              null !== S &&
                (J.updateMultisampleRenderTarget(S),
                J.updateRenderTargetMipmap(S)),
                !0 === t.isScene && t.onAfterRender(_, t, e),
                mt.resetDefaultState(),
                (E = -1),
                (T = null),
                v.pop(),
                (m = v.length > 0 ? v[v.length - 1] : null),
                g.pop(),
                (f = g.length > 0 ? g[g.length - 1] : null);
            }),
            (this.getActiveCubeFace = function () {
              return x;
            }),
            (this.getActiveMipmapLevel = function () {
              return b;
            }),
            (this.getRenderTarget = function () {
              return S;
            }),
            (this.setRenderTargetTextures = function (t, e, n) {
              ($.get(t.texture).__webglTexture = e),
                ($.get(t.depthTexture).__webglTexture = n);
              const i = $.get(t);
              (i.__hasExternalTextures = !0),
                i.__hasExternalTextures &&
                  ((i.__autoAllocateDepthBuffer = void 0 === n),
                  i.__autoAllocateDepthBuffer ||
                    (!0 === q.has("WEBGL_multisampled_render_to_texture") &&
                      (console.warn(
                        "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                      ),
                      (i.__useRenderToTexture = !1))));
            }),
            (this.setRenderTargetFramebuffer = function (t, e) {
              const n = $.get(t);
              (n.__webglFramebuffer = e),
                (n.__useDefaultFramebuffer = void 0 === e);
            }),
            (this.setRenderTarget = function (t, e = 0, n = 0) {
              (S = t), (x = e), (b = n);
              let i = !0,
                r = null,
                s = !1,
                o = !1;
              if (t) {
                const a = $.get(t);
                void 0 !== a.__useDefaultFramebuffer
                  ? (K.bindFramebuffer(vt.FRAMEBUFFER, null), (i = !1))
                  : void 0 === a.__webglFramebuffer
                  ? J.setupRenderTarget(t)
                  : a.__hasExternalTextures &&
                    J.rebindTextures(
                      t,
                      $.get(t.texture).__webglTexture,
                      $.get(t.depthTexture).__webglTexture
                    );
                const l = t.texture;
                (l.isData3DTexture ||
                  l.isDataArrayTexture ||
                  l.isCompressedArrayTexture) &&
                  (o = !0);
                const c = $.get(t).__webglFramebuffer;
                t.isWebGLCubeRenderTarget
                  ? ((r = Array.isArray(c[e]) ? c[e][n] : c[e]), (s = !0))
                  : (r =
                      Y.isWebGL2 &&
                      t.samples > 0 &&
                      !1 === J.useMultisampledRTT(t)
                        ? $.get(t).__webglMultisampledFramebuffer
                        : Array.isArray(c)
                        ? c[n]
                        : c),
                  M.copy(t.viewport),
                  w.copy(t.scissor),
                  (D = t.scissorTest);
              } else
                M.copy(F).multiplyScalar(L).floor(),
                  w.copy(N).multiplyScalar(L).floor(),
                  (D = U);
              if (
                (K.bindFramebuffer(vt.FRAMEBUFFER, r) &&
                  Y.drawBuffers &&
                  i &&
                  K.drawBuffers(t, r),
                K.viewport(M),
                K.scissor(w),
                K.setScissorTest(D),
                s)
              ) {
                const i = $.get(t.texture);
                vt.framebufferTexture2D(
                  vt.FRAMEBUFFER,
                  vt.COLOR_ATTACHMENT0,
                  vt.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                  i.__webglTexture,
                  n
                );
              } else if (o) {
                const i = $.get(t.texture),
                  r = e || 0;
                vt.framebufferTextureLayer(
                  vt.FRAMEBUFFER,
                  vt.COLOR_ATTACHMENT0,
                  i.__webglTexture,
                  n || 0,
                  r
                );
              }
              E = -1;
            }),
            (this.readRenderTargetPixels = function (t, e, n, i, r, s, o) {
              if (!t || !t.isWebGLRenderTarget)
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
                );
              let a = $.get(t).__webglFramebuffer;
              if (
                (t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a)
              ) {
                K.bindFramebuffer(vt.FRAMEBUFFER, a);
                try {
                  const o = t.texture,
                    a = o.format,
                    l = o.type;
                  if (
                    a !== vd &&
                    ft.convert(a) !==
                      vt.getParameter(vt.IMPLEMENTATION_COLOR_READ_FORMAT)
                  )
                    return void console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                    );
                  const c =
                    l === md &&
                    (q.has("EXT_color_buffer_half_float") ||
                      (Y.isWebGL2 && q.has("EXT_color_buffer_float")));
                  if (
                    !(
                      l === hd ||
                      ft.convert(l) ===
                        vt.getParameter(vt.IMPLEMENTATION_COLOR_READ_TYPE) ||
                      (l === fd &&
                        (Y.isWebGL2 ||
                          q.has("OES_texture_float") ||
                          q.has("WEBGL_color_buffer_float"))) ||
                      c
                    )
                  )
                    return void console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                    );
                  e >= 0 &&
                    e <= t.width - i &&
                    n >= 0 &&
                    n <= t.height - r &&
                    vt.readPixels(e, n, i, r, ft.convert(a), ft.convert(l), s);
                } finally {
                  const t = null !== S ? $.get(S).__webglFramebuffer : null;
                  K.bindFramebuffer(vt.FRAMEBUFFER, t);
                }
              }
            }),
            (this.copyFramebufferToTexture = function (t, e, n = 0) {
              const i = Math.pow(2, -n),
                r = Math.floor(e.image.width * i),
                s = Math.floor(e.image.height * i);
              J.setTexture2D(e, 0),
                vt.copyTexSubImage2D(vt.TEXTURE_2D, n, 0, 0, t.x, t.y, r, s),
                K.unbindTexture();
            }),
            (this.copyTextureToTexture = function (t, e, n, i = 0) {
              const r = e.image.width,
                s = e.image.height,
                o = ft.convert(n.format),
                a = ft.convert(n.type);
              J.setTexture2D(n, 0),
                vt.pixelStorei(vt.UNPACK_FLIP_Y_WEBGL, n.flipY),
                vt.pixelStorei(
                  vt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                  n.premultiplyAlpha
                ),
                vt.pixelStorei(vt.UNPACK_ALIGNMENT, n.unpackAlignment),
                e.isDataTexture
                  ? vt.texSubImage2D(
                      vt.TEXTURE_2D,
                      i,
                      t.x,
                      t.y,
                      r,
                      s,
                      o,
                      a,
                      e.image.data
                    )
                  : e.isCompressedTexture
                  ? vt.compressedTexSubImage2D(
                      vt.TEXTURE_2D,
                      i,
                      t.x,
                      t.y,
                      e.mipmaps[0].width,
                      e.mipmaps[0].height,
                      o,
                      e.mipmaps[0].data
                    )
                  : vt.texSubImage2D(vt.TEXTURE_2D, i, t.x, t.y, o, a, e.image),
                0 === i &&
                  n.generateMipmaps &&
                  vt.generateMipmap(vt.TEXTURE_2D),
                K.unbindTexture();
            }),
            (this.copyTextureToTexture3D = function (t, e, n, i, r = 0) {
              if (_.isWebGL1Renderer)
                return void console.warn(
                  "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
                );
              const s = t.max.x - t.min.x + 1,
                o = t.max.y - t.min.y + 1,
                a = t.max.z - t.min.z + 1,
                l = ft.convert(i.format),
                c = ft.convert(i.type);
              let u;
              if (i.isData3DTexture) J.setTexture3D(i, 0), (u = vt.TEXTURE_3D);
              else {
                if (!i.isDataArrayTexture)
                  return void console.warn(
                    "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
                  );
                J.setTexture2DArray(i, 0), (u = vt.TEXTURE_2D_ARRAY);
              }
              vt.pixelStorei(vt.UNPACK_FLIP_Y_WEBGL, i.flipY),
                vt.pixelStorei(
                  vt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                  i.premultiplyAlpha
                ),
                vt.pixelStorei(vt.UNPACK_ALIGNMENT, i.unpackAlignment);
              const h = vt.getParameter(vt.UNPACK_ROW_LENGTH),
                d = vt.getParameter(vt.UNPACK_IMAGE_HEIGHT),
                p = vt.getParameter(vt.UNPACK_SKIP_PIXELS),
                f = vt.getParameter(vt.UNPACK_SKIP_ROWS),
                m = vt.getParameter(vt.UNPACK_SKIP_IMAGES),
                g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
              vt.pixelStorei(vt.UNPACK_ROW_LENGTH, g.width),
                vt.pixelStorei(vt.UNPACK_IMAGE_HEIGHT, g.height),
                vt.pixelStorei(vt.UNPACK_SKIP_PIXELS, t.min.x),
                vt.pixelStorei(vt.UNPACK_SKIP_ROWS, t.min.y),
                vt.pixelStorei(vt.UNPACK_SKIP_IMAGES, t.min.z),
                n.isDataTexture || n.isData3DTexture
                  ? vt.texSubImage3D(u, r, e.x, e.y, e.z, s, o, a, l, c, g.data)
                  : n.isCompressedArrayTexture
                  ? (console.warn(
                      "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                    ),
                    vt.compressedTexSubImage3D(
                      u,
                      r,
                      e.x,
                      e.y,
                      e.z,
                      s,
                      o,
                      a,
                      l,
                      g.data
                    ))
                  : vt.texSubImage3D(u, r, e.x, e.y, e.z, s, o, a, l, c, g),
                vt.pixelStorei(vt.UNPACK_ROW_LENGTH, h),
                vt.pixelStorei(vt.UNPACK_IMAGE_HEIGHT, d),
                vt.pixelStorei(vt.UNPACK_SKIP_PIXELS, p),
                vt.pixelStorei(vt.UNPACK_SKIP_ROWS, f),
                vt.pixelStorei(vt.UNPACK_SKIP_IMAGES, m),
                0 === r && i.generateMipmaps && vt.generateMipmap(u),
                K.unbindTexture();
            }),
            (this.initTexture = function (t) {
              t.isCubeTexture
                ? J.setTextureCube(t, 0)
                : t.isData3DTexture
                ? J.setTexture3D(t, 0)
                : t.isDataArrayTexture || t.isCompressedArrayTexture
                ? J.setTexture2DArray(t, 0)
                : J.setTexture2D(t, 0),
                K.unbindTexture();
            }),
            (this.resetState = function () {
              (x = 0), (b = 0), (S = null), K.reset(), mt.reset();
            }),
            "undefined" != typeof __THREE_DEVTOOLS__ &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", {
                  detail: this,
                })
              );
        }
        get coordinateSystem() {
          return Hd;
        }
        get outputColorSpace() {
          return this._outputColorSpace;
        }
        set outputColorSpace(t) {
          this._outputColorSpace = t;
          const e = this.getContext();
          (e.drawingBufferColorSpace = t === Ld ? "display-p3" : "srgb"),
            (e.unpackColorSpace =
              dp.workingColorSpace === Od ? "display-p3" : "srgb");
        }
        get physicallyCorrectLights() {
          return (
            console.warn(
              "THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
            ),
            !this.useLegacyLights
          );
        }
        set physicallyCorrectLights(t) {
          console.warn(
            "THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
          ),
            (this.useLegacyLights = !t);
        }
        get outputEncoding() {
          return (
            console.warn(
              "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
            ),
            this.outputColorSpace === Pd ? Ad : 3e3
          );
        }
        set outputEncoding(t) {
          console.warn(
            "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
          ),
            (this.outputColorSpace = t === Ad ? Pd : Rd);
        }
        get useLegacyLights() {
          return (
            console.warn(
              "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
            ),
            this._useLegacyLights
          );
        }
        set useLegacyLights(t) {
          console.warn(
            "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
          ),
            (this._useLegacyLights = t);
        }
      }
      (class extends D_ {}).prototype.isWebGL1Renderer = !0;
      class A_ extends Pf {
        constructor() {
          super(),
            (this.isScene = !0),
            (this.type = "Scene"),
            (this.background = null),
            (this.environment = null),
            (this.fog = null),
            (this.backgroundBlurriness = 0),
            (this.backgroundIntensity = 1),
            (this.overrideMaterial = null),
            "undefined" != typeof __THREE_DEVTOOLS__ &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", {
                  detail: this,
                })
              );
        }
        copy(t, e) {
          return (
            super.copy(t, e),
            null !== t.background && (this.background = t.background.clone()),
            null !== t.environment &&
              (this.environment = t.environment.clone()),
            null !== t.fog && (this.fog = t.fog.clone()),
            (this.backgroundBlurriness = t.backgroundBlurriness),
            (this.backgroundIntensity = t.backgroundIntensity),
            null !== t.overrideMaterial &&
              (this.overrideMaterial = t.overrideMaterial.clone()),
            (this.matrixAutoUpdate = t.matrixAutoUpdate),
            this
          );
        }
        toJSON(t) {
          const e = super.toJSON(t);
          return (
            null !== this.fog && (e.object.fog = this.fog.toJSON()),
            this.backgroundBlurriness > 0 &&
              (e.object.backgroundBlurriness = this.backgroundBlurriness),
            1 !== this.backgroundIntensity &&
              (e.object.backgroundIntensity = this.backgroundIntensity),
            e
          );
        }
      }
      class C_ extends bp {
        constructor(t, e, n, i, r, s, o, a, l) {
          super(t, e, n, i, r, s, o, a, l),
            (this.isVideoTexture = !0),
            (this.minFilter = void 0 !== s ? s : cd),
            (this.magFilter = void 0 !== r ? r : cd),
            (this.generateMipmaps = !1);
          const c = this;
          "requestVideoFrameCallback" in t &&
            t.requestVideoFrameCallback(function e() {
              (c.needsUpdate = !0), t.requestVideoFrameCallback(e);
            });
        }
        clone() {
          return new this.constructor(this.image).copy(this);
        }
        update() {
          const t = this.image;
          !1 == "requestVideoFrameCallback" in t &&
            t.readyState >= t.HAVE_CURRENT_DATA &&
            (this.needsUpdate = !0);
        }
      }
      function P_(t, e, n) {
        return !t || (!n && t.constructor === e)
          ? t
          : "number" == typeof e.BYTES_PER_ELEMENT
          ? new e(t)
          : Array.prototype.slice.call(t);
      }
      class R_ {
        constructor(t, e, n, i) {
          (this.parameterPositions = t),
            (this._cachedIndex = 0),
            (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
            (this.sampleValues = e),
            (this.valueSize = n),
            (this.settings = null),
            (this.DefaultSettings_ = {});
        }
        evaluate(t) {
          const e = this.parameterPositions;
          let n = this._cachedIndex,
            i = e[n],
            r = e[n - 1];
          t: {
            e: {
              let s;
              n: {
                i: if (!(t < i)) {
                  for (let s = n + 2; ; ) {
                    if (void 0 === i) {
                      if (t < r) break i;
                      return (
                        (n = e.length),
                        (this._cachedIndex = n),
                        this.copySampleValue_(n - 1)
                      );
                    }
                    if (n === s) break;
                    if (((r = i), (i = e[++n]), t < i)) break e;
                  }
                  s = e.length;
                  break n;
                }
                if (t >= r) break t;
                {
                  const o = e[1];
                  t < o && ((n = 2), (r = o));
                  for (let s = n - 2; ; ) {
                    if (void 0 === r)
                      return (this._cachedIndex = 0), this.copySampleValue_(0);
                    if (n === s) break;
                    if (((i = r), (r = e[--n - 1]), t >= r)) break e;
                  }
                  (s = n), (n = 0);
                }
              }
              for (; n < s; ) {
                const i = (n + s) >>> 1;
                t < e[i] ? (s = i) : (n = i + 1);
              }
              if (((i = e[n]), (r = e[n - 1]), void 0 === r))
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (void 0 === i)
                return (
                  (n = e.length),
                  (this._cachedIndex = n),
                  this.copySampleValue_(n - 1)
                );
            }
            (this._cachedIndex = n), this.intervalChanged_(n, r, i);
          }
          return this.interpolate_(n, r, t, i);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(t) {
          const e = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = t * i;
          for (let t = 0; t !== i; ++t) e[t] = n[r + t];
          return e;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {}
      }
      class L_ extends R_ {
        constructor(t, e, n, i) {
          super(t, e, n, i),
            (this._weightPrev = -0),
            (this._offsetPrev = -0),
            (this._weightNext = -0),
            (this._offsetNext = -0),
            (this.DefaultSettings_ = {
              endingStart: 2400,
              endingEnd: 2400,
            });
        }
        intervalChanged_(t, e, n) {
          const i = this.parameterPositions;
          let r = t - 2,
            s = t + 1,
            o = i[r],
            a = i[s];
          if (void 0 === o)
            switch (this.getSettings_().endingStart) {
              case 2401:
                (r = t), (o = 2 * e - n);
                break;
              case 2402:
                (r = i.length - 2), (o = e + i[r] - i[r + 1]);
                break;
              default:
                (r = t), (o = n);
            }
          if (void 0 === a)
            switch (this.getSettings_().endingEnd) {
              case 2401:
                (s = t), (a = 2 * n - e);
                break;
              case 2402:
                (s = 1), (a = n + i[1] - i[0]);
                break;
              default:
                (s = t - 1), (a = e);
            }
          const l = 0.5 * (n - e),
            c = this.valueSize;
          (this._weightPrev = l / (e - o)),
            (this._weightNext = l / (a - n)),
            (this._offsetPrev = r * c),
            (this._offsetNext = s * c);
        }
        interpolate_(t, e, n, i) {
          const r = this.resultBuffer,
            s = this.sampleValues,
            o = this.valueSize,
            a = t * o,
            l = a - o,
            c = this._offsetPrev,
            u = this._offsetNext,
            h = this._weightPrev,
            d = this._weightNext,
            p = (n - e) / (i - e),
            f = p * p,
            m = f * p,
            g = -h * m + 2 * h * f - h * p,
            v = (1 + h) * m + (-1.5 - 2 * h) * f + (-0.5 + h) * p + 1,
            _ = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
            y = d * m - d * f;
          for (let t = 0; t !== o; ++t)
            r[t] = g * s[c + t] + v * s[l + t] + _ * s[a + t] + y * s[u + t];
          return r;
        }
      }
      class O_ extends R_ {
        constructor(t, e, n, i) {
          super(t, e, n, i);
        }
        interpolate_(t, e, n, i) {
          const r = this.resultBuffer,
            s = this.sampleValues,
            o = this.valueSize,
            a = t * o,
            l = a - o,
            c = (n - e) / (i - e),
            u = 1 - c;
          for (let t = 0; t !== o; ++t) r[t] = s[l + t] * u + s[a + t] * c;
          return r;
        }
      }
      class I_ extends R_ {
        constructor(t, e, n, i) {
          super(t, e, n, i);
        }
        interpolate_(t) {
          return this.copySampleValue_(t - 1);
        }
      }
      class F_ {
        constructor(t, e, n, i) {
          if (void 0 === t)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (void 0 === e || 0 === e.length)
            throw new Error(
              "THREE.KeyframeTrack: no keyframes in track named " + t
            );
          (this.name = t),
            (this.times = P_(e, this.TimeBufferType)),
            (this.values = P_(n, this.ValueBufferType)),
            this.setInterpolation(i || this.DefaultInterpolation);
        }
        static toJSON(t) {
          const e = t.constructor;
          let n;
          if (e.toJSON !== this.toJSON) n = e.toJSON(t);
          else {
            n = {
              name: t.name,
              times: P_(t.times, Array),
              values: P_(t.values, Array),
            };
            const e = t.getInterpolation();
            e !== t.DefaultInterpolation && (n.interpolation = e);
          }
          return (n.type = t.ValueTypeName), n;
        }
        InterpolantFactoryMethodDiscrete(t) {
          return new I_(this.times, this.values, this.getValueSize(), t);
        }
        InterpolantFactoryMethodLinear(t) {
          return new O_(this.times, this.values, this.getValueSize(), t);
        }
        InterpolantFactoryMethodSmooth(t) {
          return new L_(this.times, this.values, this.getValueSize(), t);
        }
        setInterpolation(t) {
          let e;
          switch (t) {
            case Md:
              e = this.InterpolantFactoryMethodDiscrete;
              break;
            case wd:
              e = this.InterpolantFactoryMethodLinear;
              break;
            case Dd:
              e = this.InterpolantFactoryMethodSmooth;
          }
          if (void 0 === e) {
            const e =
              "unsupported interpolation for " +
              this.ValueTypeName +
              " keyframe track named " +
              this.name;
            if (void 0 === this.createInterpolant) {
              if (t === this.DefaultInterpolation) throw new Error(e);
              this.setInterpolation(this.DefaultInterpolation);
            }
            return console.warn("THREE.KeyframeTrack:", e), this;
          }
          return (this.createInterpolant = e), this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return Md;
            case this.InterpolantFactoryMethodLinear:
              return wd;
            case this.InterpolantFactoryMethodSmooth:
              return Dd;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(t) {
          if (0 !== t) {
            const e = this.times;
            for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;
          }
          return this;
        }
        scale(t) {
          if (1 !== t) {
            const e = this.times;
            for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;
          }
          return this;
        }
        trim(t, e) {
          const n = this.times,
            i = n.length;
          let r = 0,
            s = i - 1;
          for (; r !== i && n[r] < t; ) ++r;
          for (; -1 !== s && n[s] > e; ) --s;
          if ((++s, 0 !== r || s !== i)) {
            r >= s && ((s = Math.max(s, 1)), (r = s - 1));
            const t = this.getValueSize();
            (this.times = n.slice(r, s)),
              (this.values = this.values.slice(r * t, s * t));
          }
          return this;
        }
        validate() {
          let t = !0;
          const e = this.getValueSize();
          e - Math.floor(e) != 0 &&
            (console.error(
              "THREE.KeyframeTrack: Invalid value size in track.",
              this
            ),
            (t = !1));
          const n = this.times,
            i = this.values,
            r = n.length;
          0 === r &&
            (console.error("THREE.KeyframeTrack: Track is empty.", this),
            (t = !1));
          let s = null;
          for (let e = 0; e !== r; e++) {
            const i = n[e];
            if ("number" == typeof i && isNaN(i)) {
              console.error(
                "THREE.KeyframeTrack: Time is not a valid number.",
                this,
                e,
                i
              ),
                (t = !1);
              break;
            }
            if (null !== s && s > i) {
              console.error(
                "THREE.KeyframeTrack: Out of order keys.",
                this,
                e,
                i,
                s
              ),
                (t = !1);
              break;
            }
            s = i;
          }
          if (
            void 0 !== i &&
            ((o = i), ArrayBuffer.isView(o) && !(o instanceof DataView))
          )
            for (let e = 0, n = i.length; e !== n; ++e) {
              const n = i[e];
              if (isNaN(n)) {
                console.error(
                  "THREE.KeyframeTrack: Value is not a valid number.",
                  this,
                  e,
                  n
                ),
                  (t = !1);
                break;
              }
            }
          var o;
          return t;
        }
        optimize() {
          const t = this.times.slice(),
            e = this.values.slice(),
            n = this.getValueSize(),
            i = this.getInterpolation() === Dd,
            r = t.length - 1;
          let s = 1;
          for (let o = 1; o < r; ++o) {
            let r = !1;
            const a = t[o];
            if (a !== t[o + 1] && (1 !== o || a !== t[0]))
              if (i) r = !0;
              else {
                const t = o * n,
                  i = t - n,
                  s = t + n;
                for (let o = 0; o !== n; ++o) {
                  const n = e[t + o];
                  if (n !== e[i + o] || n !== e[s + o]) {
                    r = !0;
                    break;
                  }
                }
              }
            if (r) {
              if (o !== s) {
                t[s] = t[o];
                const i = o * n,
                  r = s * n;
                for (let t = 0; t !== n; ++t) e[r + t] = e[i + t];
              }
              ++s;
            }
          }
          if (r > 0) {
            t[s] = t[r];
            for (let t = r * n, i = s * n, o = 0; o !== n; ++o)
              e[i + o] = e[t + o];
            ++s;
          }
          return (
            s !== t.length
              ? ((this.times = t.slice(0, s)),
                (this.values = e.slice(0, s * n)))
              : ((this.times = t), (this.values = e)),
            this
          );
        }
        clone() {
          const t = this.times.slice(),
            e = this.values.slice(),
            n = new (0, this.constructor)(this.name, t, e);
          return (n.createInterpolant = this.createInterpolant), n;
        }
      }
      (F_.prototype.TimeBufferType = Float32Array),
        (F_.prototype.ValueBufferType = Float32Array),
        (F_.prototype.DefaultInterpolation = wd);
      class N_ extends F_ {}
      (N_.prototype.ValueTypeName = "bool"),
        (N_.prototype.ValueBufferType = Array),
        (N_.prototype.DefaultInterpolation = Md),
        (N_.prototype.InterpolantFactoryMethodLinear = void 0),
        (N_.prototype.InterpolantFactoryMethodSmooth = void 0);
      (class extends F_ {}).prototype.ValueTypeName = "color";
      (class extends F_ {}).prototype.ValueTypeName = "number";
      class U_ extends R_ {
        constructor(t, e, n, i) {
          super(t, e, n, i);
        }
        interpolate_(t, e, n, i) {
          const r = this.resultBuffer,
            s = this.sampleValues,
            o = this.valueSize,
            a = (n - e) / (i - e);
          let l = t * o;
          for (let t = l + o; l !== t; l += 4)
            Dp.slerpFlat(r, 0, s, l - o, s, l, a);
          return r;
        }
      }
      class k_ extends F_ {
        InterpolantFactoryMethodLinear(t) {
          return new U_(this.times, this.values, this.getValueSize(), t);
        }
      }
      (k_.prototype.ValueTypeName = "quaternion"),
        (k_.prototype.DefaultInterpolation = wd),
        (k_.prototype.InterpolantFactoryMethodSmooth = void 0);
      class z_ extends F_ {}
      (z_.prototype.ValueTypeName = "string"),
        (z_.prototype.ValueBufferType = Array),
        (z_.prototype.DefaultInterpolation = Md),
        (z_.prototype.InterpolantFactoryMethodLinear = void 0),
        (z_.prototype.InterpolantFactoryMethodSmooth = void 0);
      (class extends F_ {}).prototype.ValueTypeName = "vector";
      class B_ {
        constructor(t = !0) {
          (this.autoStart = t),
            (this.startTime = 0),
            (this.oldTime = 0),
            (this.elapsedTime = 0),
            (this.running = !1);
        }
        start() {
          (this.startTime = H_()),
            (this.oldTime = this.startTime),
            (this.elapsedTime = 0),
            (this.running = !0);
        }
        stop() {
          this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
        }
        getElapsedTime() {
          return this.getDelta(), this.elapsedTime;
        }
        getDelta() {
          let t = 0;
          if (this.autoStart && !this.running) return this.start(), 0;
          if (this.running) {
            const e = H_();
            (t = (e - this.oldTime) / 1e3),
              (this.oldTime = e),
              (this.elapsedTime += t);
          }
          return t;
        }
      }
      function H_() {
        return ("undefined" == typeof performance ? Date : performance).now();
      }
      const V_ = "\\[\\]\\.:\\/",
        G_ = new RegExp("[" + V_ + "]", "g"),
        W_ = "[^" + V_ + "]",
        j_ = "[^" + V_.replace("\\.", "") + "]",
        X_ = new RegExp(
          "^" +
            /((?:WC+[\/:])*)/.source.replace("WC", W_) +
            /(WCOD+)?/.source.replace("WCOD", j_) +
            /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", W_) +
            /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", W_) +
            "$"
        ),
        q_ = ["material", "materials", "bones", "map"];
      class Y_ {
        constructor(t, e, n) {
          (this.path = e),
            (this.parsedPath = n || Y_.parseTrackName(e)),
            (this.node = Y_.findNode(t, this.parsedPath.nodeName)),
            (this.rootNode = t),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
        static create(t, e, n) {
          return t && t.isAnimationObjectGroup
            ? new Y_.Composite(t, e, n)
            : new Y_(t, e, n);
        }
        static sanitizeNodeName(t) {
          return t.replace(/\s/g, "_").replace(G_, "");
        }
        static parseTrackName(t) {
          const e = X_.exec(t);
          if (null === e)
            throw new Error("PropertyBinding: Cannot parse trackName: " + t);
          const n = {
              nodeName: e[2],
              objectName: e[3],
              objectIndex: e[4],
              propertyName: e[5],
              propertyIndex: e[6],
            },
            i = n.nodeName && n.nodeName.lastIndexOf(".");
          if (void 0 !== i && -1 !== i) {
            const t = n.nodeName.substring(i + 1);
            -1 !== q_.indexOf(t) &&
              ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = t));
          }
          if (null === n.propertyName || 0 === n.propertyName.length)
            throw new Error(
              "PropertyBinding: can not parse propertyName from trackName: " + t
            );
          return n;
        }
        static findNode(t, e) {
          if (
            void 0 === e ||
            "" === e ||
            "." === e ||
            -1 === e ||
            e === t.name ||
            e === t.uuid
          )
            return t;
          if (t.skeleton) {
            const n = t.skeleton.getBoneByName(e);
            if (void 0 !== n) return n;
          }
          if (t.children) {
            const n = function (t) {
                for (let i = 0; i < t.length; i++) {
                  const r = t[i];
                  if (r.name === e || r.uuid === e) return r;
                  const s = n(r.children);
                  if (s) return s;
                }
                return null;
              },
              i = n(t.children);
            if (i) return i;
          }
          return null;
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(t, e) {
          t[e] = this.targetObject[this.propertyName];
        }
        _getValue_array(t, e) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i];
        }
        _getValue_arrayElement(t, e) {
          t[e] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(t, e) {
          this.resolvedProperty.toArray(t, e);
        }
        _setValue_direct(t, e) {
          this.targetObject[this.propertyName] = t[e];
        }
        _setValue_direct_setNeedsUpdate(t, e) {
          (this.targetObject[this.propertyName] = t[e]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
          (this.targetObject[this.propertyName] = t[e]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_array(t, e) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
        }
        _setValue_array_setNeedsUpdate(t, e) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
          this.targetObject.needsUpdate = !0;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
          this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_arrayElement(t, e) {
          this.resolvedProperty[this.propertyIndex] = t[e];
        }
        _setValue_arrayElement_setNeedsUpdate(t, e) {
          (this.resolvedProperty[this.propertyIndex] = t[e]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
          (this.resolvedProperty[this.propertyIndex] = t[e]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_fromArray(t, e) {
          this.resolvedProperty.fromArray(t, e);
        }
        _setValue_fromArray_setNeedsUpdate(t, e) {
          this.resolvedProperty.fromArray(t, e),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
          this.resolvedProperty.fromArray(t, e),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _getValue_unbound(t, e) {
          this.bind(), this.getValue(t, e);
        }
        _setValue_unbound(t, e) {
          this.bind(), this.setValue(t, e);
        }
        bind() {
          let t = this.node;
          const e = this.parsedPath,
            n = e.objectName,
            i = e.propertyName;
          let r = e.propertyIndex;
          if (
            (t ||
              ((t = Y_.findNode(this.rootNode, e.nodeName)), (this.node = t)),
            (this.getValue = this._getValue_unavailable),
            (this.setValue = this._setValue_unavailable),
            !t)
          )
            return void console.warn(
              "THREE.PropertyBinding: No target node found for track: " +
                this.path +
                "."
            );
          if (n) {
            let i = e.objectIndex;
            switch (n) {
              case "materials":
                if (!t.material)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                    this
                  );
                if (!t.material.materials)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                    this
                  );
                t = t.material.materials;
                break;
              case "bones":
                if (!t.skeleton)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                    this
                  );
                t = t.skeleton.bones;
                for (let e = 0; e < t.length; e++)
                  if (t[e].name === i) {
                    i = e;
                    break;
                  }
                break;
              case "map":
                if ("map" in t) {
                  t = t.map;
                  break;
                }
                if (!t.material)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                    this
                  );
                if (!t.material.map)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
                    this
                  );
                t = t.material.map;
                break;
              default:
                if (void 0 === t[n])
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                    this
                  );
                t = t[n];
            }
            if (void 0 !== i) {
              if (void 0 === t[i])
                return void console.error(
                  "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                  this,
                  t
                );
              t = t[i];
            }
          }
          const s = t[i];
          if (void 0 === s) {
            const n = e.nodeName;
            return void console.error(
              "THREE.PropertyBinding: Trying to update property for track: " +
                n +
                "." +
                i +
                " but it wasn't found.",
              t
            );
          }
          let o = this.Versioning.None;
          (this.targetObject = t),
            void 0 !== t.needsUpdate
              ? (o = this.Versioning.NeedsUpdate)
              : void 0 !== t.matrixWorldNeedsUpdate &&
                (o = this.Versioning.MatrixWorldNeedsUpdate);
          let a = this.BindingType.Direct;
          if (void 0 !== r) {
            if ("morphTargetInfluences" === i) {
              if (!t.geometry)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                  this
                );
              if (!t.geometry.morphAttributes)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                  this
                );
              void 0 !== t.morphTargetDictionary[r] &&
                (r = t.morphTargetDictionary[r]);
            }
            (a = this.BindingType.ArrayElement),
              (this.resolvedProperty = s),
              (this.propertyIndex = r);
          } else
            void 0 !== s.fromArray && void 0 !== s.toArray
              ? ((a = this.BindingType.HasFromToArray),
                (this.resolvedProperty = s))
              : Array.isArray(s)
              ? ((a = this.BindingType.EntireArray),
                (this.resolvedProperty = s))
              : (this.propertyName = i);
          (this.getValue = this.GetterByBindingType[a]),
            (this.setValue = this.SetterByBindingTypeAndVersioning[a][o]);
        }
        unbind() {
          (this.node = null),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
      }
      (Y_.Composite = class {
        constructor(t, e, n) {
          const i = n || Y_.parseTrackName(e);
          (this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
        }
        getValue(t, e) {
          this.bind();
          const n = this._targetGroup.nCachedObjects_,
            i = this._bindings[n];
          void 0 !== i && i.getValue(t, e);
        }
        setValue(t, e) {
          const n = this._bindings;
          for (
            let i = this._targetGroup.nCachedObjects_, r = n.length;
            i !== r;
            ++i
          )
            n[i].setValue(t, e);
        }
        bind() {
          const t = this._bindings;
          for (
            let e = this._targetGroup.nCachedObjects_, n = t.length;
            e !== n;
            ++e
          )
            t[e].bind();
        }
        unbind() {
          const t = this._bindings;
          for (
            let e = this._targetGroup.nCachedObjects_, n = t.length;
            e !== n;
            ++e
          )
            t[e].unbind();
        }
      }),
        (Y_.prototype.BindingType = {
          Direct: 0,
          EntireArray: 1,
          ArrayElement: 2,
          HasFromToArray: 3,
        }),
        (Y_.prototype.Versioning = {
          None: 0,
          NeedsUpdate: 1,
          MatrixWorldNeedsUpdate: 2,
        }),
        (Y_.prototype.GetterByBindingType = [
          Y_.prototype._getValue_direct,
          Y_.prototype._getValue_array,
          Y_.prototype._getValue_arrayElement,
          Y_.prototype._getValue_toArray,
        ]),
        (Y_.prototype.SetterByBindingTypeAndVersioning = [
          [
            Y_.prototype._setValue_direct,
            Y_.prototype._setValue_direct_setNeedsUpdate,
            Y_.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
          ],
          [
            Y_.prototype._setValue_array,
            Y_.prototype._setValue_array_setNeedsUpdate,
            Y_.prototype._setValue_array_setMatrixWorldNeedsUpdate,
          ],
          [
            Y_.prototype._setValue_arrayElement,
            Y_.prototype._setValue_arrayElement_setNeedsUpdate,
            Y_.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
          ],
          [
            Y_.prototype._setValue_fromArray,
            Y_.prototype._setValue_fromArray_setNeedsUpdate,
            Y_.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
          ],
        ]),
        new Float32Array(1),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("register", {
              detail: {
                revision: Hh,
              },
            })
          ),
        "undefined" != typeof window &&
          (window.__THREE__
            ? console.warn(
                "WARNING: Multiple instances of Three.js being imported."
              )
            : (window.__THREE__ = Hh));
      const K_ = Math.PI / 180,
        Z_ = 180 / Math.PI;
      const $_ = {
        name: "CopyShader",
        uniforms: {
          tDiffuse: {
            value: null,
          },
          opacity: {
            value: 1,
          },
        },
        vertexShader:
          "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
        fragmentShader:
          "\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}",
      };
      class J_ {
        constructor() {
          (this.isPass = !0),
            (this.enabled = !0),
            (this.needsSwap = !0),
            (this.clear = !1),
            (this.renderToScreen = !1);
        }
        setSize() {}
        render() {
          console.error(
            "THREE.Pass: .render() must be implemented in derived pass."
          );
        }
        dispose() {}
      }
      const Q_ = new cg(-1, 1, 1, -1, 0, 1),
        ty = new hm();
      ty.setAttribute("position", new im([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)),
        ty.setAttribute("uv", new im([0, 2, 0, 0, 2, 0], 2));
      class ey {
        constructor(t) {
          this._mesh = new Cm(ty, t);
        }
        dispose() {
          this._mesh.geometry.dispose();
        }
        render(t) {
          t.render(this._mesh, Q_);
        }
        get material() {
          return this._mesh.material;
        }
        set material(t) {
          this._mesh.material = t;
        }
      }
      class ny extends J_ {
        constructor(t, e) {
          super(),
            (this.textureID = void 0 !== e ? e : "tDiffuse"),
            t instanceof Nm
              ? ((this.uniforms = t.uniforms), (this.material = t))
              : t &&
                ((this.uniforms = Fm.clone(t.uniforms)),
                (this.material = new Nm({
                  name: void 0 !== t.name ? t.name : "unspecified",
                  defines: Object.assign({}, t.defines),
                  uniforms: this.uniforms,
                  vertexShader: t.vertexShader,
                  fragmentShader: t.fragmentShader,
                }))),
            (this.fsQuad = new ey(this.material));
        }
        render(t, e, n) {
          this.uniforms[this.textureID] &&
            (this.uniforms[this.textureID].value = n.texture),
            (this.fsQuad.material = this.material),
            this.renderToScreen
              ? (t.setRenderTarget(null), this.fsQuad.render(t))
              : (t.setRenderTarget(e),
                this.clear &&
                  t.clear(
                    t.autoClearColor,
                    t.autoClearDepth,
                    t.autoClearStencil
                  ),
                this.fsQuad.render(t));
        }
        dispose() {
          this.material.dispose(), this.fsQuad.dispose();
        }
      }
      class iy extends J_ {
        constructor(t, e) {
          super(),
            (this.scene = t),
            (this.camera = e),
            (this.clear = !0),
            (this.needsSwap = !1),
            (this.inverse = !1);
        }
        render(t, e, n) {
          const i = t.getContext(),
            r = t.state;
          let s, o;
          r.buffers.color.setMask(!1),
            r.buffers.depth.setMask(!1),
            r.buffers.color.setLocked(!0),
            r.buffers.depth.setLocked(!0),
            this.inverse ? ((s = 0), (o = 1)) : ((s = 1), (o = 0)),
            r.buffers.stencil.setTest(!0),
            r.buffers.stencil.setOp(i.REPLACE, i.REPLACE, i.REPLACE),
            r.buffers.stencil.setFunc(i.ALWAYS, s, 4294967295),
            r.buffers.stencil.setClear(o),
            r.buffers.stencil.setLocked(!0),
            t.setRenderTarget(n),
            this.clear && t.clear(),
            t.render(this.scene, this.camera),
            t.setRenderTarget(e),
            this.clear && t.clear(),
            t.render(this.scene, this.camera),
            r.buffers.color.setLocked(!1),
            r.buffers.depth.setLocked(!1),
            r.buffers.color.setMask(!0),
            r.buffers.depth.setMask(!0),
            r.buffers.stencil.setLocked(!1),
            r.buffers.stencil.setFunc(i.EQUAL, 1, 4294967295),
            r.buffers.stencil.setOp(i.KEEP, i.KEEP, i.KEEP),
            r.buffers.stencil.setLocked(!0);
        }
      }
      class ry extends J_ {
        constructor() {
          super(), (this.needsSwap = !1);
        }
        render(t) {
          t.state.buffers.stencil.setLocked(!1),
            t.state.buffers.stencil.setTest(!1);
        }
      }
      class sy {
        constructor(t, e) {
          if (
            ((this.renderer = t),
            (this._pixelRatio = t.getPixelRatio()),
            void 0 === e)
          ) {
            const n = t.getSize(new tp());
            (this._width = n.width),
              (this._height = n.height),
              ((e = new Tp(
                this._width * this._pixelRatio,
                this._height * this._pixelRatio,
                {
                  type: md,
                }
              )).texture.name = "EffectComposer.rt1");
          } else (this._width = e.width), (this._height = e.height);
          (this.renderTarget1 = e),
            (this.renderTarget2 = e.clone()),
            (this.renderTarget2.texture.name = "EffectComposer.rt2"),
            (this.writeBuffer = this.renderTarget1),
            (this.readBuffer = this.renderTarget2),
            (this.renderToScreen = !0),
            (this.passes = []),
            (this.copyPass = new ny($_)),
            (this.copyPass.material.blending = 0),
            (this.clock = new B_());
        }
        swapBuffers() {
          const t = this.readBuffer;
          (this.readBuffer = this.writeBuffer), (this.writeBuffer = t);
        }
        addPass(t) {
          this.passes.push(t),
            t.setSize(
              this._width * this._pixelRatio,
              this._height * this._pixelRatio
            );
        }
        insertPass(t, e) {
          this.passes.splice(e, 0, t),
            t.setSize(
              this._width * this._pixelRatio,
              this._height * this._pixelRatio
            );
        }
        removePass(t) {
          const e = this.passes.indexOf(t);
          -1 !== e && this.passes.splice(e, 1);
        }
        isLastEnabledPass(t) {
          for (let e = t + 1; e < this.passes.length; e++)
            if (this.passes[e].enabled) return !1;
          return !0;
        }
        render(t) {
          void 0 === t && (t = this.clock.getDelta());
          const e = this.renderer.getRenderTarget();
          let n = !1;
          for (let e = 0, i = this.passes.length; e < i; e++) {
            const i = this.passes[e];
            if (!1 !== i.enabled) {
              if (
                ((i.renderToScreen =
                  this.renderToScreen && this.isLastEnabledPass(e)),
                i.render(
                  this.renderer,
                  this.writeBuffer,
                  this.readBuffer,
                  t,
                  n
                ),
                i.needsSwap)
              ) {
                if (n) {
                  const e = this.renderer.getContext(),
                    n = this.renderer.state.buffers.stencil;
                  n.setFunc(e.NOTEQUAL, 1, 4294967295),
                    this.copyPass.render(
                      this.renderer,
                      this.writeBuffer,
                      this.readBuffer,
                      t
                    ),
                    n.setFunc(e.EQUAL, 1, 4294967295);
                }
                this.swapBuffers();
              }
              void 0 !== iy &&
                (i instanceof iy ? (n = !0) : i instanceof ry && (n = !1));
            }
          }
          this.renderer.setRenderTarget(e);
        }
        reset(t) {
          if (void 0 === t) {
            const e = this.renderer.getSize(new tp());
            (this._pixelRatio = this.renderer.getPixelRatio()),
              (this._width = e.width),
              (this._height = e.height),
              (t = this.renderTarget1.clone()).setSize(
                this._width * this._pixelRatio,
                this._height * this._pixelRatio
              );
          }
          this.renderTarget1.dispose(),
            this.renderTarget2.dispose(),
            (this.renderTarget1 = t),
            (this.renderTarget2 = t.clone()),
            (this.writeBuffer = this.renderTarget1),
            (this.readBuffer = this.renderTarget2);
        }
        setSize(t, e) {
          (this._width = t), (this._height = e);
          const n = this._width * this._pixelRatio,
            i = this._height * this._pixelRatio;
          this.renderTarget1.setSize(n, i), this.renderTarget2.setSize(n, i);
          for (let t = 0; t < this.passes.length; t++)
            this.passes[t].setSize(n, i);
        }
        setPixelRatio(t) {
          (this._pixelRatio = t), this.setSize(this._width, this._height);
        }
        dispose() {
          this.renderTarget1.dispose(),
            this.renderTarget2.dispose(),
            this.copyPass.dispose();
        }
      }
      class oy extends J_ {
        constructor(t, e, n = null, i = null, r = null) {
          super(),
            (this.scene = t),
            (this.camera = e),
            (this.overrideMaterial = n),
            (this.clearColor = i),
            (this.clearAlpha = r),
            (this.clear = !0),
            (this.clearDepth = !1),
            (this.needsSwap = !1),
            (this._oldClearColor = new Kf());
        }
        render(t, e, n) {
          const i = t.autoClear;
          let r, s;
          (t.autoClear = !1),
            null !== this.overrideMaterial &&
              ((s = this.scene.overrideMaterial),
              (this.scene.overrideMaterial = this.overrideMaterial)),
            null !== this.clearColor &&
              (t.getClearColor(this._oldClearColor),
              t.setClearColor(this.clearColor)),
            null !== this.clearAlpha &&
              ((r = t.getClearAlpha()), t.setClearAlpha(this.clearAlpha)),
            1 == this.clearDepth && t.clearDepth(),
            t.setRenderTarget(this.renderToScreen ? null : n),
            !0 === this.clear &&
              t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
            t.render(this.scene, this.camera),
            null !== this.clearColor && t.setClearColor(this._oldClearColor),
            null !== this.clearAlpha && t.setClearAlpha(r),
            null !== this.overrideMaterial && (this.scene.overrideMaterial = s),
            (t.autoClear = i);
        }
      }
      var ay = {
          uniforms: {
            tDiffuse: {
              type: "t",
              value: null,
            },
            time: {
              type: "f",
              value: 0,
            },
            distortion: {
              type: "f",
              value: 3,
            },
            distortion2: {
              type: "f",
              value: 5,
            },
            speed: {
              type: "f",
              value: 0.2,
            },
            rollSpeed: {
              type: "f",
              value: 0.1,
            },
          },
          vertexShader: [
            "varying vec2 vUv;",
            "void main() {",
            "vUv = uv;",
            "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
            "}",
          ].join("\n"),
          fragmentShader: [
            "uniform sampler2D tDiffuse;",
            "uniform float time;",
            "uniform float distortion;",
            "uniform float distortion2;",
            "uniform float speed;",
            "uniform float rollSpeed;",
            "varying vec2 vUv;",
            "vec3 mod289(vec3 x) {",
            "  return x - floor(x * (1.0 / 289.0)) * 289.0;",
            "}",
            "vec2 mod289(vec2 x) {",
            "  return x - floor(x * (1.0 / 289.0)) * 289.0;",
            "}",
            "vec3 permute(vec3 x) {",
            "  return mod289(((x*34.0)+1.0)*x);",
            "}",
            "float snoise(vec2 v)",
            "  {",
            "  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0",
            "                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)",
            "                     -0.577350269189626,  // -1.0 + 2.0 * C.x",
            "                      0.024390243902439); // 1.0 / 41.0",
            "  vec2 i  = floor(v + dot(v, C.yy) );",
            "  vec2 x0 = v -   i + dot(i, C.xx);",
            "  vec2 i1;",
            "  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);",
            "  vec4 x12 = x0.xyxy + C.xxzz;",
            " x12.xy -= i1;",
            "  i = mod289(i); // Avoid truncation effects in permutation",
            "  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))",
            "\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));",
            "  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);",
            "  m = m*m ;",
            "  m = m*m ;",
            "  vec3 x = 2.0 * fract(p * C.www) - 1.0;",
            "  vec3 h = abs(x) - 0.5;",
            "  vec3 ox = floor(x + 0.5);",
            "  vec3 a0 = x - ox;",
            "  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );",
            "  vec3 g;",
            "  g.x  = a0.x  * x0.x  + h.x  * x0.y;",
            "  g.yz = a0.yz * x12.xz + h.yz * x12.yw;",
            "  return 130.0 * dot(m, g);",
            "}",
            "void main() {",
            "vec2 p = vUv;",
            "p -= vec2(0.5);",
            "p *= 1. - (distortion * 0.03);",
            "p += vec2(0.5);",
            "float ty = time*speed;",
            "float yt = p.y - ty;",
            "float offset = snoise(vec2(yt*3.0,0.0))*0.2;",
            "offset = offset * distortion * offset * distortion * offset;",
            "offset += snoise(vec2(yt*50.0,0.0))*distortion2*0.001;",
            "gl_FragColor = texture2D(tDiffuse, vec2(fract(p.x + offset), fract(p.y+ offset)));",
            "}",
          ].join("\n"),
        },
        ly = {
          uniforms: {
            tDiffuse: {
              type: "t",
              value: null,
            },
            time: {
              type: "f",
              value: 0,
            },
            amount: {
              type: "f",
              value: 0.5,
            },
            size: {
              type: "f",
              value: 4,
            },
          },
          vertexShader: [
            "varying vec2 vUv;",
            "void main() {",
            "vUv = uv;",
            "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
            "}",
          ].join("\n"),
          fragmentShader: [
            "uniform sampler2D tDiffuse;",
            "uniform float time;",
            "uniform float amount;",
            "uniform float size;",
            "varying vec2 vUv;",
            "float rand(vec2 co){",
            "return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);",
            "}",
            "void main() {",
            "vec2 p = vUv;",
            "vec4 color = texture2D(tDiffuse, p);",
            "float xs = floor(gl_FragCoord.x / size);",
            "float ys = floor(gl_FragCoord.y / size);",
            "vec4 snow = vec4(rand(vec2(xs * time,ys * time))*amount);",
            "gl_FragColor = color+ snow;",
            "}",
          ].join("\n"),
        };
      function cy(t, e) {
        return (
          (cy = Object.setPrototypeOf
            ? Object.setPrototypeOf.bind()
            : function (t, e) {
                return (t.__proto__ = e), t;
              }),
          cy(t, e)
        );
      }
      var uy = (function (t) {
          var e, n;
          function i() {
            var e;
            return (
              ((e = t.apply(this, arguments) || this).header =
                e.el.querySelector(".cb-footer-header")),
              (e.bgMedia = e.el.querySelector(".cb-footer-bg-media")),
              (e.bgVideo = e.bgMedia.querySelector("video")),
              (e.action = e.el.querySelector(".cb-footer-action")),
              (e.actionBtn = e.action.querySelector("a")),
              (e.tag = e.el.querySelectorAll(".cb-footer-tag")),
              (e.link = e.el.querySelectorAll(".cb-footer-link")),
              (e.sceneVisible = !1),
              e
            );
          }
          (n = t),
            ((e = i).prototype = Object.create(n.prototype)),
            (e.prototype.constructor = e),
            cy(e, n);
          var r = i.prototype;
          return (
            (r.onInit = function () {
              try {
                var t = this;
                return Promise.resolve(t.loadScene()).then(function () {
                  t.magicShow();
                });
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (r.onLeave = function () {
              try {
                var t = this;
                return (
                  ta.isTouch ||
                    ((t.sceneVisible = !1),
                    t.bgVideo.pause(),
                    t.renderFn && Zi.ticker.remove(t.renderFn),
                    t.resizeFn &&
                      window.removeEventListener("resize", t.resizeFn)),
                  Promise.resolve()
                );
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (r.loadScene = function () {
              try {
                var t = this;
                return (
                  ta.isTouch ||
                    ((t.bgVideo.style.display = "none"),
                    t.bgVideo.pause(),
                    ta.create({
                      trigger: t.el,
                      onToggle: function (e) {
                        e.progress, e.direction;
                        var n = e.isActive;
                        (t.sceneVisible = n),
                          n ? t.bgVideo.play() : t.bgVideo.pause();
                      },
                    }),
                    (t.sceneTexture = new C_(t.bgVideo)),
                    (t.sceneTexture.minFilter = 1006),
                    (t.sceneTexture.magFilter = 1006),
                    (t.sceneMaterial = new $f({
                      map: t.sceneTexture,
                    })),
                    (t.sceneGeometry = new Jm(1600, 900, 1, 1)),
                    (t.scenePlane = new Cm(t.sceneGeometry, t.sceneMaterial)),
                    (t.scenePlane.z = 0),
                    (t.sceneFov = 45),
                    (t.sceneCamera = new km(
                      t.sceneFov,
                      t.bgMedia.offsetWidth / t.bgMedia.offsetHeight,
                      20,
                      3e3
                    )),
                    (t.sceneCamera.position.z = 1e3),
                    (t.sceneMain = new A_()),
                    t.sceneMain.add(t.scenePlane),
                    (t.sceneRenderer = new D_({
                      antialias: !1,
                      alpha: !1,
                      powerPreference: "high-performance",
                    })),
                    t.sceneRenderer.setSize(
                      t.bgMedia.offsetWidth,
                      t.bgMedia.offsetHeight
                    ),
                    t.bgMedia.appendChild(t.sceneRenderer.domElement),
                    (t.sceneComposer = new sy(t.sceneRenderer)),
                    (t.sceneRenderPass = new oy(t.sceneMain, t.sceneCamera)),
                    (t.sceneBadTVPass = new ny(ay)),
                    (t.sceneStaticPass = new ny(ly)),
                    t.sceneComposer.addPass(t.sceneRenderPass),
                    t.sceneComposer.addPass(t.sceneBadTVPass),
                    t.sceneComposer.addPass(t.sceneStaticPass),
                    (t.sceneBadTVPass.uniforms.distortion.value = 0),
                    (t.sceneBadTVPass.uniforms.distortion2.value = 0),
                    (t.sceneBadTVPass.uniforms.speed.value = 0.22),
                    (t.sceneBadTVPass.uniforms.rollSpeed.value = 0),
                    (t.sceneStaticPass.uniforms.amount.value = 0.03),
                    (t.sceneStaticPass.uniforms.size.value = 3),
                    (t.renderFn = function (e) {
                      t.sceneVisible &&
                        (t.sceneComposer.render(0.1),
                        (t.sceneBadTVPass.uniforms.time.value = e),
                        (t.sceneStaticPass.uniforms.time.value = e));
                    }),
                    Zi.ticker.add(t.renderFn),
                    (t.resizeFn = function () {
                      setTimeout(function () {
                        if (
                          (t.sceneRenderer.setSize(
                            t.bgMedia.offsetWidth,
                            t.bgMedia.offsetHeight
                          ),
                          (t.sceneCamera.aspect =
                            t.bgMedia.offsetWidth / t.bgMedia.offsetHeight),
                          t.sceneCamera.updateProjectionMatrix(),
                          t.sceneCamera.aspect > 16 / 9)
                        ) {
                          var e = Math.tan((t.sceneFov / 2) * K_),
                            n = t.sceneCamera.aspect / (16 / 9);
                          t.sceneCamera.fov = 2 * (Math.atan(e / n) * Z_);
                        } else t.sceneCamera.fov = t.sceneFov;
                      }, 1e3);
                    }),
                    window.addEventListener("resize", t.resizeFn),
                    t.actionBtn.addEventListener("mouseenter", function () {
                      Zi.to(t.sceneBadTVPass.uniforms.distortion, {
                        value: 5,
                        duration: 0.5,
                      }),
                        Zi.to(t.sceneStaticPass.uniforms.amount, {
                          value: 0.1,
                          duration: 0.5,
                        });
                    }),
                    t.actionBtn.addEventListener("mouseleave", function () {
                      Zi.to(t.sceneBadTVPass.uniforms.distortion, {
                        value: 0,
                        duration: 0.5,
                      }),
                        Zi.to(t.sceneStaticPass.uniforms.amount, {
                          value: 0.03,
                          duration: 0.5,
                        });
                    })),
                  Promise.resolve()
                );
              } catch (t) {
                return Promise.reject(t);
              }
            }),
            (r.magicShow = function () {
              this.header &&
                kc(this.header.firstElementChild, {
                  type: "lines",
                  stagger: 0.3,
                }),
                this.actionBtn && qc(this.actionBtn),
                this.tag.length &&
                  this.link.length &&
                  jc([this.tag, this.link]);
            }),
            i
          );
        })(o),
        hy = new s({
          define: [
            {
              namespace: "ajax",
              component: a,
              options: {
                updateSelectors: ["title", "meta", ".cb-menu", "#view-main"],
              },
            },
            {
              namespace: "layout",
              assign: ".cb-layout",
              component: Ol,
            },
            {
              namespace: "cursor",
              component: Nl,
            },
            {
              namespace: "loader",
              assign: ".cb-loader",
              component: kl,
            },
            {
              namespace: "divider",
              assign: ".cb-divider",
              component: cc,
            },
            {
              namespace: "button",
              assign: ".cb-btn",
              component: hc,
            },
            {
              namespace: "checkbox",
              assign: ".cb-checkbox",
              component: Kc,
            },
            {
              namespace: "input.light",
              assign: ".cb-input_light",
              component: iu,
            },
            {
              namespace: "input.file",
              assign: ".cb-input_file",
              component: ru,
            },
            {
              namespace: "modal",
              assign: ".cb-modal",
              component: ou,
            },
            {
              namespace: "navbar",
              assign: ".cb-navbar",
              component: lu,
            },
            {
              namespace: "menu",
              assign: ".cb-menu",
              component: uu,
            },
            {
              namespace: "intouch",
              assign: ".cb-intouch",
              component: du,
            },
            {
              namespace: "embedded",
              assign: ".cb-embedded",
              component: fu,
            },
            {
              namespace: "tophead",
              assign: ".cb-tophead",
              component: gu,
            },
            {
              namespace: "contact",
              assign: ".cb-contact",
              component: yu,
            },
            {
              namespace: "work",
              assign: ".cb-work",
              component: bu,
            },
            {
              namespace: "entrylist",
              assign: ".cb-entrylist",
              component: Eu,
            },
            {
              namespace: "featured",
              assign: ".cb-featured",
              component: Mu,
            },
            {
              namespace: "overview",
              assign: ".cb-overview",
              component: wh,
            },
            {
              namespace: "splitshow",
              assign: ".cb-splitshow",
              component: Ah,
            },
            {
              namespace: "summary",
              assign: ".cb-summary",
              component: Lh,
            },
            {
              namespace: "screenshot",
              assign: ".cb-screenshot",
              component: Ih,
            },
            {
              namespace: "nextcase",
              assign: ".cb-nextcase",
              component: Nh,
            },
            {
              namespace: "smfeed",
              assign: ".cb-smfeed",
              component: kh,
            },
            {
              namespace: "outro",
              assign: ".cb-outro",
              component: Bh,
            },
            {
              namespace: "footer",
              assign: ".cb-footer",
              component: uy,
            },
          ],
        });
      (window.app = hy),
        window.addEventListener("pagehide", function () {
          return window.scrollTo(0, 0);
        });
    })();
})();
